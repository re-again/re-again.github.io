<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>8086汇编-寄存器-内存访问（3）</title>
      <link href="/2023/05/01/3.%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/"/>
      <url>/2023/05/01/3.%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1内存种字的存储"><a href="#3-1内存种字的存储" class="headerlink" title="3.1内存种字的存储"></a>3.1内存种字的存储</h2><p>1.一个内存单元的大小是1B，任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个内存单元，也可以看出一个地址为N的字单元中的高位字节单元和低位字节单元</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406150702374.png" alt="image-20230406150702374"></p><p>**两个十六进制位是一个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0地址单元中存放的字节型数据：20H</span><br><span class="line">0地址单元中存放的字型数据：4E20H</span><br><span class="line"></span><br><span class="line">后面的是高位</span><br></pre></td></tr></table></figure><h2 id="3-2DS和-address"><a href="#3-2DS和-address" class="headerlink" title="3.2DS和[address]"></a>3.2DS和[address]</h2><p>1.CPU要读取一个内存单元的时候，必须先给出 这个单元的地址；</p><p>2.在8086CPU中，内存地址由段地址和偏移地址组成</p><p>3.8086CPU中由一个DS寄存器，通常用来存放要访问的数据的段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CS寄存器就是当前要读取指令的地址。</span><br></pre></td></tr></table></figure><p>4.例子：我们要读取1000H单元的内容，可以用如下的程序进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H//这里就是在bx寄存器中放入了1000H这个数据</span><br><span class="line">mov ds,bx//把bx寄存器中的1000H数据放到DS寄存器中</span><br><span class="line">mov al,[0]//[0],这里是偏移地址的意思，CPU在用到偏移地址的时候，会先去找到段地址，在第二部已经把段地址设置成1000H了，所以这句话的意思就是把地址位1000:0的数据放入al寄存器中【这个al的寄存器是ax下的一个low低位寄存器】</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">这里不能mov dx,1000H</span><br><span class="line">只能通过通用寄存器导过来</span><br></pre></td></tr></table></figure><p>5.mov指令的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.将数据之间送入寄存器；【不能直接放入段寄存器】</span><br><span class="line">mov ax,2</span><br><span class="line">2.将一个寄存器中的内容送入另一个寄存器中</span><br><span class="line">mov ax,bx</span><br><span class="line">【通过这种方式来送入段寄存器】</span><br><span class="line">3.将一个内存单元中的内容送入一个寄存器</span><br><span class="line">mov ax,[0]</span><br><span class="line">某个内存单元中的内容，需要用DS[address]指向这个地址后，才会送入另外一个寄存器</span><br><span class="line">也就是说，在有[]的时候是去直接读取DS和address[偏移地址]找到这个地址里面的内容，放入ax寄存器中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx ==&gt;寄存器寻址 </span><br><span class="line">mov ax,1000H  ==&gt;立即寻址</span><br><span class="line">mov ax,[0]  ==&gt;直接寻址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在修改DS段寄存器中的内容的时候是：利用了通用寄存器结合mov实现的</span><br><span class="line"></span><br><span class="line">但是修改CS段的寄存器的时候是直接使用jmp命令修改的</span><br><span class="line">jmp DS:IP  --&gt; 这个就是DS和IP一起修改</span><br><span class="line">jmp ax--&gt;这个就是DS不变，IP变成AX寄存器中的值</span><br></pre></td></tr></table></figure><p>6.写几条指令，将al中的数据送入内存单元10000H？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov BX,1000H</span><br><span class="line">mov DS,BX</span><br><span class="line">mov [0],AL</span><br><span class="line">这里是把数据放入某单元</span><br></pre></td></tr></table></figure><h2 id="3-3字的传送"><a href="#3-3字的传送" class="headerlink" title="3.3字的传送"></a>3.3字的传送</h2><p>1.因为8086CPU是16位结构，有16根数据线，所以一次性传入16位的数据，也就是一次性传送一个字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx  //前面俩个是为了确定段地址</span><br><span class="line">mov ax,[0]//1000:0处的字型数据送入ax中</span><br><span class="line">mov [],cx//cx中16位数据送到1000:0处</span><br></pre></td></tr></table></figure><h3 id="小结一下【实验】P14"><a href="#小结一下【实验】P14" class="headerlink" title="小结一下【实验】P14"></a>小结一下【实验】P14</h3><p>首先CS:IP 和 DS[偏移地址]是密不可分的【好像有点奇怪，现在姑且这样理解】</p><p>CS:IP确定了指向命令的地址 【在我看来就是地址总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好像也不是很对，emmmm，反正就是说在CS:IP的地址中的内容可以放入命令，然后进行执行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先在地址中写入要执行命令的汇编指令，</span><br><span class="line">然后用CS:IP指向这些地址，在运行的时候，这些地址里面的内容就会指向命令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406160947921.png" alt="image-20230406160947921"></p><p>通过运行CS:IP地址中的内容就可以去改变DS中的内容，然后读取DS地址中的内容放入或者运算入AX BX CX DX通用寄存器中</p><p>DS确定了读取数据的地址 【在我看来就是数据总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反正就是说运行的命令，都是在CS:IP地址中的内容，如果CS:IP中的某些命令需要用到DS，则就会去调用DS[]地址中的值。</span><br><span class="line">差不多就是这个意思</span><br></pre></td></tr></table></figure><p>当通用寄存器用的是X的时候【16位的时候】就需要把该地址和该地址+1的内容当作字来看</p><p>但是如果使用的是L/H的时候，就需要当作字节来看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为，这个传入的内容不能大于放入的寄存器</span><br><span class="line">mov ax,[0]//这样就是当作字来看，因为ax寄存器中可以存16位【一个字】</span><br><span class="line">mov al,[0]//这样就要当作字节来看，因为al寄存器中只能放入8位【一个字节】</span><br><span class="line"></span><br><span class="line">寄存器有多大，就放多少，在选中的该地址往后加就好了</span><br><span class="line">以寄存器为标准，内存按照寄存器的大小对寄存器放入值</span><br></pre></td></tr></table></figure><h2 id="3-4mov-add-sub指令"><a href="#3-4mov-add-sub指令" class="headerlink" title="3.4mov,add, sub指令"></a>3.4mov,add, sub指令</h2><p>1.mov</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">已知：</span><br><span class="line">mov 寄存器，数据</span><br><span class="line">mov ax,100</span><br><span class="line">mov 寄存器，寄存器</span><br><span class="line">mov ax,bx</span><br><span class="line">mov 寄存器，内存单元 //内存单元这里就是DS[address]指向的位置</span><br><span class="line">mov ax,[0]</span><br><span class="line">mov 内存单元，寄存器</span><br><span class="line">mov [0],ax</span><br><span class="line">mov 段寄存器，寄存器</span><br><span class="line">mov ds,ax</span><br><span class="line">新的：</span><br><span class="line">mov 寄存器，段寄存器</span><br><span class="line">mov ax,ds</span><br></pre></td></tr></table></figure><p> 2.add【➕】和sub【➖】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add 寄存器，数据</span><br><span class="line">add ax，3</span><br><span class="line">add 寄存器，寄存器</span><br><span class="line">add ax，bx</span><br><span class="line">add 寄存器，内存单元</span><br><span class="line">add ax，[0]</span><br><span class="line">add 内存单元，寄存器</span><br><span class="line">add [0]，ax</span><br><span class="line">注意：！！！</span><br><span class="line">add不能对段寄存器进行操作</span><br><span class="line">比如：add ds，ax  ==&gt;  这样是错误的！！【段寄存器不是这么用的，所以没有设置这个功能】</span><br><span class="line"></span><br><span class="line">##然后sub和add完全一样</span><br></pre></td></tr></table></figure><h2 id="3-5数据段"><a href="#3-5数据段" class="headerlink" title="3.5数据段"></a>3.5数据段</h2><p>1.前面讲过，对于8086PC机，我们可以根据需要将一组内存单元定义为一个段（这个段，可以是代码段，也可以是数据段）</p><p>2.我们可以将一组长度为N(N&lt;=64K)，地址连续，起始地址是16的倍数的内存单元当作专门存储数据的内存空间，这个空间就是定义的数据段</p><p>3.比如我们用123BOH~123B9H这段空间来存放数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">段地址：123BH  ==&gt;这里会经过加工厂*16=123BOH</span><br><span class="line">长度是10字节【123B0~123B9有10个存储单元【一个存储单元就是1B】】</span><br></pre></td></tr></table></figure><p>4.如何访问你数据段的中数据？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目1：我们将123BOH~123BAH的内存单元定义为数据段，我们现在要累加这个数据段中的前3个单元中的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解：</span><br><span class="line">mov ax,123BH</span><br><span class="line">mov ds,ax</span><br><span class="line">mov al,0//因为数题目是前三个单元中的数据，每一个存储单元的大小是1B也就是8位，所以这里需要使用低位的al 而不是 使用ax，如果使用ax的话，就会把数据放入字中【16位】这样所求得的就不是前三个单元中的数据的累加，而是前三个字中数据的累加</span><br><span class="line">add al,[0]//计算机都是从0开始哦</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目2：我们将123BOH~123BAH的内存单元定义为数据段，我们现在要累加这个数据段中的前3个字型中的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里就是把al改成ax就好啦，当然偏移地址也要累加2【懂的都懂，不懂的就别学了】</span><br><span class="line">add ax,[0]//为了放入ax中其实这里是[0]放入低位[1]放入高</span><br><span class="line">add ax,[2]</span><br><span class="line">add ax,[4] </span><br><span class="line">注意：一个字型数据占2个单元，所以偏移地址是0，2，4</span><br></pre></td></tr></table></figure><h3 id="3-1-3-5小结一下"><a href="#3-1-3-5小结一下" class="headerlink" title="3.1~3.5小结一下"></a>3.1~3.5小结一下</h3><p>1**.字在内存中存储的时候，要用俩个地址连续的内存单元来存放，字的低位字节【al】存放在低地址单元【0】中，高位字节【ah】存放在高地址单元【1】中</p><p>2.用mov指令要访问内存单元，可以在mov指令中只给处单元的偏移地址，此时，段地址默认在DS寄存器中</p><p>3.[address]表示一个偏移地址位address的内存单元</p><p>4.在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应</p><p>5.mov add sub 是具有两个操作对象的指令。jmp是具有一个操作对象的指令</p><p>6.可以根据自己的推测，在debug中实验指令的新格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据弹幕： mov ax,1000:[0]  ==&gt;  这样不error的【我也不确定】</span><br></pre></td></tr></table></figure><h2 id="3-6栈"><a href="#3-6栈" class="headerlink" title="3.6栈"></a>3.6栈</h2><p>1.我们研究栈的角度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先：栈是内存空间的一部分</span><br><span class="line"></span><br><span class="line">栈是一种具有特殊的访问方式的存储空间，它的特殊性就在于，最后进入这个空间的数据，最先出去【迟到早退】</span><br></pre></td></tr></table></figure><p>2.栈有俩个基本的操作：入栈和出栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">入栈：将一个新的元素放到栈顶</span><br><span class="line">出栈：从栈顶取出一个元素</span><br></pre></td></tr></table></figure><p>3.栈顶的元素总是最后入栈，需要出栈的时候，又是最先被从栈中取出</p><p>4.栈的操作规则：LIFO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last In First Out</span><br><span class="line">后进先出</span><br></pre></td></tr></table></figure><h2 id="3-7CPU提供的栈机制"><a href="#3-7CPU提供的栈机制" class="headerlink" title="3.7CPU提供的栈机制"></a>3.7CPU提供的栈机制</h2><p>1.如今的CPU中都有栈的设计</p><p>2.8086CPU提供相关的指令来以栈的方式访问内存空间</p><p>3.这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只是我们当作栈来使用，sb计算机只会0和1</span><br></pre></td></tr></table></figure><p>4.8086CPU提供入栈和出栈指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最基本：</span><br><span class="line">PUSH:（入栈）【入就入到最底部】</span><br><span class="line">POP（出栈）【出就是从顶部出】</span><br><span class="line">push ax：将寄存器ax中的数据送入栈中</span><br><span class="line">pop ax：从栈顶取出数据放入ax</span><br></pre></td></tr></table></figure><p>5.8086CPU的入栈和出栈操作都是以字【16位】为单位进行【这个是因为8086CPU内部是以16位为单位运算的，现在都是32/64位咯】</p><p>6.CPU如何知道一段内存空间被当作栈使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先我们知道</span><br><span class="line">段寄存器CI:IP所指向的就是指令</span><br><span class="line">段寄存器DS所指向的就是数据</span><br><span class="line">所以，以此类推，肯定有一个栈寄存器</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在8086CPU中，有俩个寄存器：</span><br><span class="line">段寄存器SS ：存放栈顶的段地址</span><br><span class="line">寄存器SP : 存放栈顶的偏移地址</span><br><span class="line">任意时刻，SS:SP指向栈顶元素</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里我们要注意的是：栈顶不是某个栈的顶部，而是某栈存放了数据，然后栈顶就是最后放入数据的位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406173524469.png" alt="image-20230406173524469"></p><p>7.在执行PUSH和POP的时候，如何知道那个单元是栈顶单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在指向PUSH和POP的时候，栈顶的位置是动态变化的，那么它是如何知道的呢？</span><br></pre></td></tr></table></figure><h3 id="push-ax"><a href="#push-ax" class="headerlink" title="push ax"></a>push ax</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个步骤在计算机中其实是两步</span><br><span class="line">1.SP=SP-2//这里是-2而不是+2的原因是：在push的时候，数据会首先放入栈的最底部【也就是偏移地址最大的时候，高地址】</span><br><span class="line">//这个就类似于IP=IP+所读指令长度</span><br><span class="line">2.将ax中的内容送入SS:SP指向的内存单元出【字】，SS:SP此时指向新栈顶</span><br></pre></td></tr></table></figure><h3 id="pop-ax"><a href="#pop-ax" class="headerlink" title="pop ax"></a>pop ax</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">就是push的逆运算</span><br><span class="line">1.将SS:SP指向的字中的内容放入ax后</span><br><span class="line">2.SP=SP+2</span><br><span class="line"></span><br><span class="line">在使用POP之后，取出来原来地址上的内容还是存在的，【可以理解成，SP变了，只是把内容copy出去了】</span><br><span class="line">内存中的数据是不会被删除，只能一次一次的被覆盖被覆盖</span><br></pre></td></tr></table></figure><p>8.问题：如果我们将10000H~1000FH这段空间当作栈，初始状态栈是空的，此时SS=1000H,那SP=？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当然是不是000FH啦</span><br><span class="line">**是最高单元的下一个地址</span><br><span class="line">SP=0010</span><br><span class="line">因为只有指向最高单元的下一个地址</span><br><span class="line">在push 的时候，整出俩个地址才会对应上哦</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406201341990.png" alt="image-20230406201341990"></p><p>换个角度看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.任何时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就步存在栈顶元素</span><br><span class="line">2.所以在栈为空的时候，SS:SP就只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2【这里是字单元，如过是字节的话，就是+1】</span><br><span class="line">3.栈最底部子单元地址是1000:000E,所以栈为空的时候，SP=0010H</span><br></pre></td></tr></table></figure><h2 id="3-8栈顶超界的问题"><a href="#3-8栈顶超界的问题" class="headerlink" title="3.8栈顶超界的问题"></a>3.8栈顶超界的问题</h2><p>1.SS和SP只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈的时候找到栈顶。</p><p>2.但是，如何能够保证在入栈和出栈的时候，栈顶不会超出栈空间</p><p>3.当栈满的时候在使用PUSH指令入栈，栈空的时候在使用POP指令出栈，都会发生栈顶出界的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哟~出现了溢出</span><br><span class="line">向上的溢出--push</span><br><span class="line">向下的溢出--pop</span><br></pre></td></tr></table></figure><p>4.栈顶越界是危险的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为我们既然将一段空间安排为栈，那么在占空间之外的空间里面很可能存放了具有其他用途的数据，代码。这些数据，代码可能是我们自己程序中的，也可能是贝格程序中的（毕竟一个计算机系统并不是只有我们自己程序在运行）</span><br><span class="line"></span><br><span class="line">相当于在溢出的时候，可以用PUSH或POP把栈之外的内容给搞出来，然后就会出现一些泄露或者，覆盖掉其他的东西。【类似吧】</span><br></pre></td></tr></table></figure><p>5.但是由于我们在入栈和出栈时候的不小心（故意）加上一些其他工具【乱说的，可能可以把这些内容收集起来，就可以无限可能】</p><p>6.8086CPU不保证对栈的操作不会越界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8086CPU只知道栈顶在何处</span><br><span class="line">因为栈的大小是我们自己定义的，CPU不知道我们定义了多大，不知上线和下线，所以CPU就会很SB的以为还在栈里面【但是这个时候已经跑出去了】</span><br><span class="line">CPU只知道要执行的栈顶在何处，但是不知道要栈空间的大小是多少</span><br></pre></td></tr></table></figure><p>7.总的一句话，我要想办法使他溢出【哈哈】</p><h2 id="3-9PUSH和POP指令"><a href="#3-9PUSH和POP指令" class="headerlink" title="3.9PUSH和POP指令"></a>3.9PUSH和POP指令</h2><p>1.首先PUSH和POP是可以在寄存器和内存之间传送数据的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.栈空间是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间</span><br></pre></td></tr></table></figure><p>2.看看POP和PUSH指令的格式把</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器：</span><br><span class="line">1.PUSH 寄存器：将一个寄存器中的数据入栈</span><br><span class="line">2.POP 寄存器：出栈，用一个寄存器接受出栈的数据</span><br><span class="line">段寄存器：</span><br><span class="line"> 1.PUSH 段寄存器：将一个段寄存器中的数据入栈</span><br><span class="line"> 2.POP 段寄存器：出栈，用一个段寄存器接受出栈的数据</span><br><span class="line"> 【也就是说，PUSH和POP可以对段寄存器使用】</span><br><span class="line"> 【补充，ADD和SUB不能对段寄存器使用】</span><br><span class="line">内存单元：</span><br><span class="line">1.PUSH 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）</span><br><span class="line">2.POP内存单元：出栈，用一个内存字单元接收出栈的数据</span><br><span class="line">PUSH [0] //字型的数据</span><br><span class="line">POP [2]</span><br><span class="line"></span><br><span class="line">指令执行的时候，CPU要知道内存单元的地址，可以在PUSH POP 指令中给处内存单元的偏移地址，段地址在指令执行的时候,CPU从DS取得</span><br><span class="line"></span><br><span class="line">数据的段地址在ds中获得   用[]来偏移地址</span><br><span class="line">代码的段地址在cs中获得   用ip来偏移地址</span><br><span class="line">栈的段地址在ss中获得    用sp来偏移地址</span><br></pre></td></tr></table></figure><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编程将10000H~1000FH这段空间当作栈，初始状态是空的，将AX,BX,DS中的数据入栈</span><br><span class="line">入栈就是push</span><br></pre></td></tr></table></figure><p> 解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.mov ax,1000H</span><br><span class="line"></span><br><span class="line">2.mov ss,ax //这里之前说过，段地址不能直接用数据，必须得用通用寄存器来过度。所以这里先把1000H存入ax，后放入ss</span><br><span class="line"></span><br><span class="line">3.mov sp,0010H //这个sp不是段寄存器，段寄存器【CS,DS,SS,ES】.这里为什么是0010H呢？因为栈是到1000FH所以要指向这个的下一个</span><br><span class="line"></span><br><span class="line">4.push ax</span><br><span class="line">5.push bx</span><br><span class="line">6.push ds</span><br></pre></td></tr></table></figure><h3 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.将10000H~1000FH这段空间当作栈，初始状态是空的</span><br><span class="line">2.设置AX=001AH,BX=001BH</span><br><span class="line">3.将AX BX 中的数据入栈</span><br><span class="line">4.然后将AX BX 清零</span><br><span class="line">5.从栈中恢复AX BX 原来的内容</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个很简单啦，要注意的是</span><br><span class="line">最后进入的最先出来的</span><br><span class="line">清零是</span><br><span class="line">sub ax,ax或者mov ax,0 或者xor ax,ax[这个是异或]</span><br></pre></td></tr></table></figure><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.将10000H~1000FH这段空间当作栈，初始状态是空的</span><br><span class="line">2.设置AX=002AH,BX=002BX</span><br><span class="line">3.利用栈，交换AX和BX中的数据</span><br></pre></td></tr></table></figure><p>解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">pop ax //把原来bx的值放入ax</span><br><span class="line">pop bx //把原来ax的值放入bx</span><br></pre></td></tr></table></figure><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果要在10000H处写入字型数据2266H这么搞？</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax // 这步就是要让ds段寄存器指向1000H</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax //把2266H的值放入10000H</span><br><span class="line">相当于100000H是66；100001H是22</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">现在进阶</span><br><span class="line">1.________</span><br><span class="line">2.________</span><br><span class="line">3.________</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">完成代码，实现上诉的结果</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">分析一波，我们看哈，最后俩个是：</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line">读一下：这里是把2266H放入ax寄存器中，然后通过栈的PUSH把ax寄存器中的内容push进10000H处</span><br><span class="line">所以：我们需要在这个之前需要把栈的指针指向10000H处</span><br><span class="line">所以:</span><br><span class="line">1.mov ax,1000H</span><br><span class="line">2.mov ss,ax</span><br><span class="line">3.mov sp,2  //这里要想明白：sp的步骤是什么先-2后入栈，这里后面push ax,指针是在10002H的位置，然后push ax 也就是说在10001H的位置会存入22，10000H的位置会存入66</span><br><span class="line"></span><br><span class="line">这个指针是sp-2是往上【低】走</span><br></pre></td></tr></table></figure><p>总的分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">我想问一下:我这样的分析是不是对的</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax</span><br><span class="line"></span><br><span class="line">如果cpu运行了这段命令，然后在地址10000H处和10001H处10002H处的内容是什么？</span><br><span class="line">【我本身想实验的，但是在win11下没有debuf，然后虚拟机我没有下xp，由于急于想知道答案所以没有下】【附加上我不知道还有什么调试器可以用-目前只知道debug】</span><br><span class="line">我感觉像是：，然后在10000H中存入的是66 在10001H中是22</span><br><span class="line">【因为电子书--王爽的汇编在3.1~3.5的小结里面有字在内存中存储的时候，需要用2个连续的内存单元来存放，字的低位字节存放在低地址中[这里我认为是al]高位字节放入高地址中[这个我认为是ah]】</span><br><span class="line"></span><br><span class="line">然后在3.9中的问题3.10中有一个</span><br><span class="line"></span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov ap,2</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line">这样的代码是等价于上面的代码【书上这么说的】</span><br><span class="line"></span><br><span class="line">分析这个命令：栈的段地址是1000H，然后偏移地址是0002，所以组合在一起这个地址是10002H</span><br><span class="line">然后在push,ax的时候【这个ax里面是2266】</span><br><span class="line">在高地址中存入的是22【10001H】低地址存入的是66【10000H】</span><br></pre></td></tr></table></figure><h3 id="问题得出的结论"><a href="#问题得出的结论" class="headerlink" title="问题得出的结论"></a>问题得出的结论</h3><p>1.PUSH和POP实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，和mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的</p><p>2.同时，push和pop指令还会改变sp的内容</p><h2 id="3-10栈段"><a href="#3-10栈段" class="headerlink" title="3.10栈段"></a>3.10栈段</h2><p>1.段–&gt;就是一组内存单元</p><p>2.我们可以将长度为N(&lt;=64K)的一组地址连续，起始地址为16倍数的内存单元，当作栈来用，从而定义了一个栈段</p><p>3.将内存当作栈段，只是我们在编程时候的一种安排，CPU并不会知道这个空间,CPU只知道SS:SP。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>如果我们将10000H~1FFFFH这段当作栈段是，初始状态是空的，此时SS=1000H那么SP是多少呢？</p><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">猜测的是:超出了啊不知道了FFFF已经是64KB了</span><br><span class="line"></span><br><span class="line">这里emmm SP=0</span><br></pre></td></tr></table></figure><p>换一个角度看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址是栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000:FFFE,所以栈空的时候，SP=0000H</span><br></pre></td></tr></table></figure><p> 栈的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">就是拿来临时保存东西的</span><br><span class="line">大概就是用来封装函数</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.我们可以将一段内存定义为一个段，用一个段地址来指示段，用偏移地址访问段内的单元。【这完全是我们的安排】</p><p>2.我们可以用一个段存放数据，将它定义成“数据段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DS:[]</span><br><span class="line">CPU就将我们定义的数据段中的内容当作数据来访问</span><br><span class="line">比如mov add sub </span><br></pre></td></tr></table></figure><p>我们可以用一个段存放代码，将它定义成“代码段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS:IP</span><br><span class="line">CPU就将执行我们定义的代码段中的指令</span><br></pre></td></tr></table></figure><p>我们可以用一个段当作  栈，将它定义成“栈段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SS:SP</span><br><span class="line">CPU在需要进行栈操作的时候，执行PUSH POP 指令的时候，就将我们定义的栈段当作栈空间来使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-寄存器-CPU互作原理（2）</title>
      <link href="/2023/05/01/2.%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%E4%BA%92%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"/>
      <url>/2023/05/01/2.%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%E4%BA%92%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h2><p>1.一个典型的CPU由运算器，控制器，寄存器等器件组成，这些器件靠内部的总线相连</p><p>2.区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内部总线：是CPU内部的【用于运算器，控制器，寄存器】</span><br><span class="line">外部总线：是我们之间学的那些【用于和主板联系的--&gt;地址总线，数据总线，控制总线】</span><br></pre></td></tr></table></figure><p>3.内部总线实现CPU内部各个器件之间的联系</p><p>4.外部总监实现CPU和主板上其他器件的联系</p><h2 id="寄存器概述"><a href="#寄存器概述" class="headerlink" title="寄存器概述"></a>寄存器概述</h2><p>1.8086CPU有14个寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1通用寄存器"><a href="#2-1通用寄存器" class="headerlink" title="2.1通用寄存器"></a>2.1通用寄存器</h3><p>1.8086CPU所有的寄存器都是16位的，可以存放2个字节，也就是一个字</p><p>2.AX  BX  CX  DX  通常用来存放一般性数据被称为通用寄存器</p><p>3.AX</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405132751383.png" alt="image-20230405132751383"></p><p>一个16位寄存器可以存储一个16位的数据</p><p>比如：数据18  –&gt; 二进制表示是10010</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405132946340.png" alt="image-20230405132946340">  </p><p>一个16位寄存器所能存储的数据的最大值是多少呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^16 - 1   --&gt;  二进制就是1111,1111,1111,1111</span><br></pre></td></tr></table></figure><p>4.为了保持和上一代CPU中的寄存器【都是8位】的兼容性，这4个寄存器可以分为2个独立的8位寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AX--&gt;AH AL  [high low]</span><br><span class="line">AL:0~7位</span><br><span class="line">AH:8~15位</span><br><span class="line">AL 和 AH 是可以独立使用的8位寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405133854304.png" alt="image-20230405133854304"></p><h3 id="2-2字在寄存器中的储存"><a href="#2-2字在寄存器中的储存" class="headerlink" title="2.2字在寄存器中的储存"></a>2.2字在寄存器中的储存</h3><p>1.一个字可以存放一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位和低8位寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字 --&gt; word</span><br><span class="line">1word=2Byte=16bit</span><br></pre></td></tr></table></figure><h4 id="关于数制的讨论"><a href="#关于数制的讨论" class="headerlink" title="关于数制的讨论"></a>关于数制的讨论</h4><p>1.由于1个内存单元可以放8位数据，CPU中的寄存器又可放N个8位数据。也就是说，计算机中的数据大多是由1~N个8位数据构成的。【进制转换的课程，有时间一定要去看啊】</p><p>2.用十六进制来表示数据可以直观的看出这个数据是由那些8位数据构成【每两位对应一个八进制】【4位对应一个16进制】</p><p>3.十六进制后面+H ； 二进制后面+B ； </p><h3 id="2-3几条汇编指令"><a href="#2-3几条汇编指令" class="headerlink" title="2.3几条汇编指令"></a>2.3几条汇编指令</h3><p>1.汇编的指令是不分大小写的</p><p>汇编指令                                控制CPU完成的操作                                        高级语言的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">move ax,18将18送入AXAX=18</span><br><span class="line">move ah,78将78送入AHAH=78</span><br><span class="line">add ax,8将寄存器AX中的值加上8AX=AX+8</span><br><span class="line">move ax,bx将寄存器BX中的数据送入寄存器AX中AX=BX</span><br><span class="line">add ax,bx将AX,BX中的内容相加，结果存在AX中AX=AX+BX</span><br><span class="line"></span><br><span class="line">在使用add的时候如果存放的数值大于了寄存器的容量怎么办？</span><br><span class="line">AX寄存器就存放2个字节，取后面的，前面的舍去掉（舍去的部分取哪里了，后面再说）</span><br><span class="line">比如：mov ax,8226H    mov bx,8226H</span><br><span class="line">add ax,bx</span><br><span class="line">这个时候的ax中的值是044cH</span><br><span class="line">但是8226H+8226H=1044c的，前面的1被抛弃</span><br><span class="line">同理：如果使用的是AL或者AH，虽然这俩个是AX分出来，但是在AL溢出的时候，也是只能放后面的</span><br><span class="line"></span><br><span class="line">比如AX中的值是00C5H</span><br><span class="line">add al,93H     ------&gt; c5+93=158 </span><br><span class="line">最后得出的AX的值是0058H</span><br></pre></td></tr></table></figure><p>**这里的丢失，指的是进制不能再8位寄存器中保存，但是CPU不是真正的抛弃这个进制位</p><h3 id="2-4物理地址"><a href="#2-4物理地址" class="headerlink" title="2.4物理地址"></a>2.4物理地址</h3><p>1.CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成了存储空间是一个一维的线性空间</p><p>2.我们将这个唯一的地址称为物理地址</p><h3 id="2-6-16位结构的CPU"><a href="#2-6-16位结构的CPU" class="headerlink" title="2.6 16位结构的CPU"></a>2.6 16位结构的CPU</h3><p>1.概括的讲，16位结构描述了一个CPU具有一下几个方面的特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.运算器一次最多可以处理16位的数据</span><br><span class="line">2.寄存器的最大宽度是16位</span><br><span class="line">3.寄存器和运算器之间的通路是16位的</span><br></pre></td></tr></table></figure><p>2.8086CPU给出物理地址的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.8086有20位地址总线，可传送20位地址，寻址能力是1M</span><br><span class="line">2.8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K</span><br></pre></td></tr></table></figure><p>3.问题：那么，8086CPU如何用内部16位的数据转化成20位的地址呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8086CPU采用一种再内部用俩个16位地址合成的方法形成一个20位的物理地址</span><br><span class="line"></span><br><span class="line">1.CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</span><br><span class="line">2.段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；</span><br><span class="line">3.地址加法器将两个16位地址合并成一个20位的地址</span><br><span class="line">4....</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405175513882.png" alt="image-20230405175513882"></p><h3 id="2-7地址加法器的互作原理"><a href="#2-7地址加法器的互作原理" class="headerlink" title="2.7地址加法器的互作原理"></a>2.7地址加法器的互作原理</h3><p>问题：地址加法器的互作原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址加法器合成物理地址的方法：</span><br><span class="line">物理地址=段地址*16+偏移地址</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230405180149132.png" alt="image-20230405180149132"></p><p>5.由段地址* 16引发的血案….</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">段地址*16 ==&gt; 有一个更常用的说法，就是数据左移4位（二进制位）</span><br><span class="line">移位位数二进制十六进制  十进制</span><br><span class="line">010B2H2</span><br><span class="line">1100B4H4</span><br><span class="line">21000B8H8</span><br><span class="line">310000B10H16</span><br><span class="line">4100000B20H32</span><br></pre></td></tr></table></figure><p>通过观察我们发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一个数据的二进制[16进制]形式左移1位，相当于该数*2[*16]</span><br><span class="line">2.一个数据的二进制形式左移N位，相当于该数*2的N次方</span><br><span class="line">3.所以段地址*16的运算就是，以二进制形式存放的段地址左移4位</span><br></pre></td></tr></table></figure><p>段地址*16+偏移地址=物理地址的本质含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.基础地址+偏移地址=物理地址</span><br><span class="line">2.段地址*16+偏移地址=物理地址</span><br><span class="line">就是说CPU一次只能提供不够的，第一个地址进行*16后加上去就是物理地址</span><br></pre></td></tr></table></figure><h3 id="2-8段的概念"><a href="#2-8段的概念" class="headerlink" title="2.8段的概念"></a>2.8段的概念</h3><p>1.错误的认识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存被划分成了一个一个的段，没一个段有一个段地址</span><br></pre></td></tr></table></figure><p>2.其实</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存并没有分段，段的划分来自于CPU，由于8086CPU“用（段地址*16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存</span><br></pre></td></tr></table></figure><p>3.以后在编程的时候，将若干个连续的内存单元看作一个段，用段地址*16 定位段的起始地址（基础地址）用偏移地址定位段中的内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.段地址*16必然十16的倍数，所以一个段的起始地址也一定是16的倍数</span><br><span class="line">2.偏移地址为16位，16位地址的寻址能力为64K,所以一个段的长度最大是64K</span><br></pre></td></tr></table></figure><h3 id="内存单元地址小结"><a href="#内存单元地址小结" class="headerlink" title="内存单元地址小结"></a>内存单元地址小结</h3><p>1.CPU访问内存单元的时候，必须向内存提供内存单元的物理地址</p><p>2.8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。</p><p>3.一个物理地址，可以由很多种段地址和偏移地址形成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>4.给定一个段地址，仅通过变化偏移地址来寻，最多可以定位64KB个内存单元</p><h3 id="没有小结的小结"><a href="#没有小结的小结" class="headerlink" title="没有小结的小结"></a>没有小结的小结</h3><p>1.段地址和偏移地址</p><p>2.数据在21F60H内存单元中。对于8086PC机中有俩种描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.数组存在内存2000:1F60单元种</span><br><span class="line">2.数据存在内存的2000段种的1F60H单元种</span><br></pre></td></tr></table></figure><p>3.可以根据需要，将地址连续，起始地址为16的位数的一组内存单元定义为一个段</p><h3 id="2-9段寄存器"><a href="#2-9段寄存器" class="headerlink" title="2.9段寄存器"></a>2.9段寄存器</h3><p>1.段寄存器就是提供段地址的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8086CPU有4个段寄存器</span><br><span class="line">CS  DS  SS  ES </span><br></pre></td></tr></table></figure><p>2.当8086CPU要访问内存时，由这四个段寄存器提供内存单元的段地址</p><h3 id="2-10CS和IP"><a href="#2-10CS和IP" class="headerlink" title="2.10CS和IP"></a>2.10CS和IP</h3><p>1.CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS为代码段寄存器</span><br><span class="line">IP为指令指针寄存器【偏移地址的寄存器】</span><br></pre></td></tr></table></figure><p>2.8086PC互作过程的简要描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲区；</span><br><span class="line">2.IP=IP+所读取指令的长度，从而指向下一条指令</span><br><span class="line">3.执行指令。转到步骤1</span><br></pre></td></tr></table></figure><p>3.在任何时候，CPU和CS,IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行</p><p>4.如果说，内存中的一段信息被CPU执行过的话，那么，它所在的内存单元必然是被CS:IP指向过</p><h3 id="2-11修改CS-IP的指令"><a href="#2-11修改CS-IP的指令" class="headerlink" title="2.11修改CS,IP的指令"></a>2.11修改CS,IP的指令</h3><p>1.在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制</p><p>2.CPU从何处执行指令是由CS,IP中的内容决定的，程序员可以通过改变CS,IP中的内容来控制CPU执行目标指令</p><p>3.同时修改CS.IP的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp 段地址:偏移地址</span><br><span class="line">jmp 2AE3:3   --&gt; 3AE33</span><br><span class="line">jmp 3:OB16   --&gt; 0003</span><br><span class="line">功能：用指令中给出的地段修改CS,偏移地址修改IP</span><br></pre></td></tr></table></figure><p>4.只修改IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jim 某一个合法寄存器完成：</span><br><span class="line">jmp ax 指令执行前：ax=1000H CS=2000H,IP=0003H</span><br><span class="line"> 后：ax=1000H CS=2000H,IP=1000H</span><br><span class="line">这个就是类似于：mov IP,ax</span><br></pre></td></tr></table></figure><h3 id="2-12代码段"><a href="#2-12代码段" class="headerlink" title="2.12代码段"></a>2.12代码段</h3><p>1.对于8086PC机，在编程的时候，可以根据需要，将一组内存单元定义为一个段</p><p>2.可以将长度为N(N&lt;=64KB)的一组代码，存在一组地址连续，起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段</p><p>3.如何使得代码段中的指令被执行呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用CS:IP指过去</span><br></pre></td></tr></table></figure><p>4.将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动的将我们定义的代码段中的指令当作指令来执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU只认被CS:IP指向的内存单元中的内容为指令</span><br><span class="line">如果是其他的来指向就可能是数据</span><br></pre></td></tr></table></figure><p>5.所以要将CS:IP指向对应的地址</p><h3 id="2-9-2-12节的小结"><a href="#2-9-2-12节的小结" class="headerlink" title="2.9~2.12节的小结"></a>2.9~2.12节的小结</h3><p>1.段地址在8086CPU的寄存器中存放。当8086CPU要访问内存的时候，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址</p><p>2.CS存放指令的段地址，IP存放指令的偏移地址。</p><p>3.8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行</p><p>4.8086CPU的互作过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从CS:IP指向内存单元读取指令，读取的指令进入缓冲区</span><br><span class="line">2.IP指向下一条指令；</span><br><span class="line">3.执行指令（转到步骤1）</span><br></pre></td></tr></table></figure><p>5.8086CPU提供转移指令修改CS,IP的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp</span><br></pre></td></tr></table></figure><h2 id="实验【完成就结束第二章】"><a href="#实验【完成就结束第二章】" class="headerlink" title="实验【完成就结束第二章】"></a>实验【完成就结束第二章】</h2><p>1.查看CPU和内存，用机器指令和汇编指令编程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用到DEBUG</span><br><span class="line">cmd--&gt;输入debug</span><br></pre></td></tr></table></figure><p>什么是debug？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug是DOS，Windows都提供的实模式（8086方式）程序的调试工具，使用它可以查看CPU各种寄存器中的内容，内存的情况和在机器码级跟踪程序的运行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">指令：</span><br><span class="line">-r查看，改变CPU寄存器的内容</span><br><span class="line">-d查看内容中的内容</span><br><span class="line">-e改写内存中的内容</span><br><span class="line">-u将内存中的机器指令翻译成汇编指令</span><br><span class="line">-t命令执行一条机器指令</span><br><span class="line">-a以汇编指令的格式在内容中写入一条机器指令</span><br></pre></td></tr></table></figure><p>这里还是去看视频吧P12</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-基础知识（1）</title>
      <link href="/2023/05/01/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/01/1.%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>汇编语言是直接在硬件之上互作的编程语言</p><p>学会用汇编的思维去使用C语言</p><p>比汇编更底层的  –&gt;  机器语言</p><p>【进制转化】【可以再去学一下】</p><p>【王爽的汇编语言】</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单讲是CPU中可以存储数据的器件，一个CPU中有多个寄存</span><br><span class="line">AX</span><br><span class="line">BX</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以后还会讲咯</span><br></pre></td></tr></table></figure><p>程序–&gt;汇编指令–&gt;编译器–&gt;机器码</p><p>汇编语言和机器指令是一一调用的</p><h3 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h3><p>1.汇编语言有3类组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.汇编指令【机器码的助记符】</span><br><span class="line">2.伪指令【由编译器执行】</span><br><span class="line">3.其他符号【由编译器识别】</span><br></pre></td></tr></table></figure><p>2.汇编语言的核心是汇编指令，它决定了汇编语言的特性</p><p>【编码的奥秘】这本书推荐看看。</p><h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>1.CPU是计算机的核心部件，它控制整个计算机的运作并进行运算，要想让一个CPU互作，就必须向它提供指令和数据</p><p>2.指令和数据在存储器中存放，也就是平时说的内存</p><p>3.在一台PC中的内存的作用仅次于CPU</p><p>4.离开了内存，性能在好的CPU也无法互作</p><p>5.磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被cpu使用</p><h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>1.指令和数据是应用上的概念</p><p>2.在内存或磁盘上，指令和数据没有任何区别，都是二进制信息</p><p>3.二进制信息：–&gt;【进制转化】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1000100111011000  ==&gt;转成Hex</span><br><span class="line">--&gt;89D8H(数据)</span><br><span class="line">1000100111011000</span><br><span class="line">--&gt;MOV AX,BX(程序)</span><br></pre></td></tr></table></figure><h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>1.储存区被划分为若干个存储单元，每个存储单元从0开始顺序编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：一个储存区有128个存储单元，那么编号从0~127</span><br></pre></td></tr></table></figure><p>2.对于大容量的储存区一般还用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KB = 1024B</span><br><span class="line">MB = 1024KB</span><br><span class="line">GB = 1024MB</span><br><span class="line">TB = 1024GB</span><br></pre></td></tr></table></figure><p>3.磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位</p><h3 id="CPU对储存区的读写"><a href="#CPU对储存区的读写" class="headerlink" title="CPU对储存区的读写"></a>CPU对储存区的读写</h3><p>1.CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.存储单元的地址（地址信息）</span><br><span class="line">2.器件的选择，读或写命令（控制信息）</span><br><span class="line">3.读或写的数据（数据信息）</span><br></pre></td></tr></table></figure><h3 id="CPU对储存区的读写-1"><a href="#CPU对储存区的读写-1" class="headerlink" title="CPU对储存区的读写"></a>CPU对储存区的读写</h3><p>1.那么CPU是通过什么将地址，数据和控制信息传递到存储芯片的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">电子计算能处理，传递的信息都是电信号，电信号当然要用导线传送</span><br></pre></td></tr></table></figure><p>2.在计算机中专门有连接CPU和其他芯片的导线【称为总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在物理上：一根根导线的集合；</span><br><span class="line">逻辑上划分为：</span><br><span class="line">地址总线</span><br><span class="line">数据总线</span><br><span class="line">控制总线</span><br><span class="line"></span><br><span class="line">通过哪条线过来的数据就当作某来算</span><br><span class="line">就像上面的：</span><br><span class="line">1000100111011000  ==&gt;转成Hex</span><br><span class="line">--&gt;89D8H(数据)  【通过数据总线】</span><br><span class="line">1000100111011000</span><br><span class="line">--&gt;MOV AX,BX(程序)  【通过控制总线】</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230404232205006.png" alt="image-20230404232205006"></p><p>3.CPU是如何进行读和写的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先通过地址总线，找到相对应的地址。</span><br><span class="line">然后通过控制总线，传入要读或者写的命令</span><br><span class="line">最后通过数据总线进行数据上的传递</span><br><span class="line">如果是读，就是从内存上的该地址通过数据总线把内容传递给CPU</span><br><span class="line">写，就是在CPU上通过数据总线找到该地址，写入内存中</span><br></pre></td></tr></table></figure><p>对于8086CPU，下面的机器码能完成从三号单元读数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">机器码：101000000000001100000000</span><br><span class="line">含义：从三号单元读取数据送入寄存器AX</span><br><span class="line">CPU接受这条机器码后将完成上面所述的读写互作</span><br></pre></td></tr></table></figure><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>1.CPU是通过地址总线来指定存储单元的</p><p>2.地址总线上能传送多少个不同的信息，CPU就可以堆叠多少个存储单元进行寻址</p><p>3.一个CPU有N根地址总线，则可以说整个CPU的地址总线的宽度为N</p><p>4.这样的CPU最多可以寻找2的N次方个内存单元</p><p>5.地址是从下面往上面读</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405103334221.png" alt="image-20230405103334221"></p><p>这样读出来的是1011【前面的补上0】</p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>1.CPU与内存或其他器件之前的数据传送是通过数据总线来进行的</p><p>2.数据总线的宽度决定了CPU和外界数据传送速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宽度越高，一次传入的数据就越多。</span><br></pre></td></tr></table></figure><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>1.CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是一个总称，控制总线是一些不同的控制线的集合</p><p>2.有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制</p><p>3.所以，控制总线的宽度决定 看CPU对外部器件的控制能力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制总线上发送的控制信息</span><br></pre></td></tr></table></figure><p>4.前面所讲的内存读或写的命令是由几根控制线综合发出的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.其中由一根名为读信号输出控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据</span><br><span class="line">2.有一根名为写信号输出控制线负责又CPU向外传送写信号</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.汇编指令是机器指令的助记符，同机器指令一一对应</p><p>2.每种CPU都有自己的汇编指令集</p><p>3.CPU可以直接使用的信息在存储器中存放</p><p>4.在存储器中指令和数据没有任何区别都是二进制信息</p><p>5.存储单元从零开始顺序编号</p><p>6.一个存储单元可以存储8个bit，即8位二进制数。</p><p>7.每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.地址总线的宽度决定了CPU的寻址能力；</span><br><span class="line">2.数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量；</span><br><span class="line">3.控制总线宽度决定了CPU对系同种其他器件的控制能力</span><br></pre></td></tr></table></figure><p>8.在汇编课程中，我们从功能的角度介绍了这三类中线，对实际的连接情况不做讨论。</p><h3 id="内存地址空间（概述）"><a href="#内存地址空间（概述）" class="headerlink" title="内存地址空间（概述）"></a>内存地址空间（概述）</h3><p>1.上面是内存地址空间？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024可寻到的内存单元就构成了这个CPU的内存地址空间</span><br></pre></td></tr></table></figure><p>2.主板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件</span><br><span class="line">2.这些器件通过总线（地址，数据，控制）相连接</span><br></pre></td></tr></table></figure><p>3.接口卡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.计算机系统中，所有可用程序控制其互作的设备，必修收到CPU的控制</span><br><span class="line">2.CPU对外部设备不能直接控制。直接控制这些设备进行互作的是插在扩展插槽上的接口卡</span><br></pre></td></tr></table></figure><p>4.各类储存区芯片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.从读写属性上看分为2类：</span><br><span class="line">随机存储器（RAM）【比如内存】和只读存储器（ROM）</span><br><span class="line"></span><br><span class="line">2.从功能和连接上分类：</span><br><span class="line">随机存储器RAM</span><br><span class="line">装有BIOS的ROM</span><br><span class="line">BIOS：基本输入输出系统</span><br><span class="line">BIOS：是由主板和各类接口卡（比如：显卡，网卡...）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插由存储相应的BIOS的ROM</span><br><span class="line">接口上的RAM</span><br><span class="line">PC机中各类存储器的逻辑相连接情况</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405125056876.png" alt="image-20230405125056876"></p><h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>1.上述的拿下存储器在物理上是独立的器件</p><p>2.但是它们在一下俩点上是相同的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.都和CPU的总线相连</span><br><span class="line">2.CPU对他们进行读或写的时候都通过控制线发出内存读写命令</span><br></pre></td></tr></table></figure><p>3.将各类存储器看作一个逻辑存储器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；</span><br><span class="line">2.每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；</span><br><span class="line">3.CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据</span><br><span class="line"></span><br><span class="line">每一个PC的内存地址空间都是不一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405125649612.png" alt="image-20230405125649612"></p><p>内存地址空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.最终运行的程序都是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题</span><br><span class="line">2.核心思维</span><br><span class="line">3.对CPU来讲，系统中的所有存储器中的存储单元都是处于一个统一的逻辑存储器中，它的容量受到CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>张明宇的博客计划</title>
      <link href="/2023/04/30/%E8%AE%A1%E5%88%92/"/>
      <url>/2023/04/30/%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><strong>为了监督我的学习和记录我的成长，我的博客计划是：</strong></p><p>一周一小更，一个月一大更。每周天晚上写一写最近的学习情况和内容【可以是几个字也能是几百字】。每一个月写一个收获到的知识内容，或者这一个月所得到的东西。</p><ul><li><p>会开放一个计划想法区：把突发奇想的东西都放上去。</p></li><li><p>会开放一个娱乐区：用来记录我学后的放松娱乐。</p></li><li><p>会开放一个日常笔记区：把写的笔记都上传到一个地方，并且把不同的笔记内容进行分类。【该功能还在探索】【因为是刚刚开始学，所以很多笔记可能有不当之处】</p></li><li><p>会开放一个汽车展览区：帅气的汽车都放上去。</p></li><li><p>会开放一个剪辑区：把酷酷的视频和美美的视频放上去。</p></li><li><p>由于我对渗透测试和二进制安全都蛮有兴趣的，加上我还年轻【才大一，刚刚接触这个网络】所以我可能两个方向都会学一学，在未来的日子里定下专攻的方向。</p></li><li><p>因为是才刚刚搭建起来的博客，很多地方都不很懂，并且有很多的东西都还未能开放【还不太会】。所以请大家多给建议，谢谢。</p></li></ul><p><strong>以前浪费的时间太多，希望我能在搭建该博客后能自觉，自立的进行学习。</strong></p><ul><li>只要即可起步，永远都不会嫌迟。</li><li>细节决定成败，习惯成就未来。</li></ul><p><strong>来自皮皮虾的正能量</strong>【简单的记录一下神评，下次我也能神评啦~】</p><ul><li>聪明是一种天赋，而善良是一种选择。</li><li>保持求同存异，不要带有知识上的优越感。</li><li>你在背后议论我，说明我走在你前面。</li></ul><p>注：现在的背景图不符合我的审美，我后面会把我的“海贼王”放上去。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
