<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>逆向-编程基础（1）</title>
      <link href="/2023/05/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-1-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
      <url>/2023/05/04/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%AE%89%E5%85%A8-1-%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="1-进制"><a href="#1-进制" class="headerlink" title="1.进制"></a>1.进制</h1><p>进制之间的转化，emmm 这里就不累赘了。</p><p>现在这么先进了，能计算机就计算机吧。当然原理肯定还是要懂的。</p><h1 id="2-编程基础之常见字符编码"><a href="#2-编程基础之常见字符编码" class="headerlink" title="2.编程基础之常见字符编码"></a>2.编程基础之常见字符编码</h1><h2 id="数据宽度"><a href="#数据宽度" class="headerlink" title="数据宽度"></a><strong>数据宽度</strong></h2><p>超出最多宽度的数据会被丢弃</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bit 1</span><br><span class="line">byte80xFF</span><br><span class="line">word160xFFFF</span><br><span class="line">doubleword320xFFFFFFFF</span><br><span class="line">Qword64</span><br></pre></td></tr></table></figure><h2 id="⽆符号数、有符号数"><a href="#⽆符号数、有符号数" class="headerlink" title="⽆符号数、有符号数"></a><strong>⽆符号数、有符号数</strong></h2><p>不说了</p><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a><strong>原码、反码、补码</strong></h2><p>在计算机中，存储形式是通过补码来存储的</p><p><strong>原码</strong>：最⾼位为符号位，其余各位为数值本身的绝对值</p><p><strong>反码</strong>：<strong>正数</strong>反码与原码相同，<strong>负数</strong>符号位为1，其余位对原码取反</p><p><strong>补码</strong>：<strong>正数</strong>补码与原码相同，<strong>负数</strong>符号位为1，其余位对原码取反加1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-1 </span><br><span class="line">1000 0001 </span><br><span class="line">原码：1000 0001</span><br><span class="line">反码 1111 1110</span><br><span class="line">补码 1111 1111</span><br></pre></td></tr></table></figure><h2 id="与运算"><a href="#与运算" class="headerlink" title="与运算"></a><strong>与运算</strong></h2><p>and     &amp;</p><p>两个位都是1才是1。【一假即假】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011 0001</span><br><span class="line">1101 1000</span><br><span class="line">——————</span><br><span class="line">1001 0000</span><br></pre></td></tr></table></figure><h2 id="或运算"><a href="#或运算" class="headerlink" title="或运算"></a><strong>或运算</strong></h2><p>｜｜</p><p>只要有一个为1就为1。【一真即真】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011 0001</span><br><span class="line">1101 1000</span><br><span class="line">——————</span><br><span class="line">1111 1001</span><br></pre></td></tr></table></figure><h2 id="异或运算"><a href="#异或运算" class="headerlink" title="异或运算"></a><strong>异或运算</strong></h2><p>xor     ^</p><p>不⼀样时则为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1011 0001</span><br><span class="line">1101 1000</span><br><span class="line">——————</span><br><span class="line">0110 1001</span><br></pre></td></tr></table></figure><h2 id="⾮运算"><a href="#⾮运算" class="headerlink" title="⾮运算"></a><strong>⾮运算</strong></h2><p>Not     ~</p><p>0就是1、1就是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1101 1000</span><br><span class="line">0010 0111</span><br></pre></td></tr></table></figure><h2 id="左移"><a href="#左移" class="headerlink" title="左移"></a><strong>左移</strong></h2><p>&lt;&lt;     shl </p><p>各⼆进制位全部左移若⼲位，⾼位丢弃，低位补0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1101 1000 </span><br><span class="line">shl2;左移2位</span><br><span class="line">0110 0000</span><br></pre></td></tr></table></figure><h2 id="右移"><a href="#右移" class="headerlink" title="右移"></a><strong>右移</strong></h2><p>Shr     &gt;&gt;</p><p>各⼆进制位全部右移若⼲位，低位丢弃，⾼位补0（shr）或补符号位（sar）</p><h2 id="位运算加减乘除"><a href="#位运算加减乘除" class="headerlink" title="位运算加减乘除"></a><strong>位运算加减乘除</strong></h2><p><strong>4+5的运算过程</strong></p><p>1.转为⼆进制：0000 0100 、0000 0101</p><p>2.两者进⾏异或得出：0000 0001</p><p>3.判断是否存在进位（两者进⾏<strong>与</strong>运算）：0000 0100 .这⾥与运算结果不为0（⼆进制：00000000）则表示存在进位</p><p>4.0000 0001 xor 0000 1000 = 0000 1001</p><p>5.步骤四的结果还需要判断是否存在进位（与运算）：步骤⼆的结果与左移⼀位的步骤三结果 → <strong>0000 0001 and 0000 1000</strong>，得出：0000 0000，则表示不存在进位，步骤四的结果</p><p>则为4+5的最后结果</p><p>6.⼆进制：0000 1001转为⼗进制：9</p><h2 id="什么是编码与解码"><a href="#什么是编码与解码" class="headerlink" title="什么是编码与解码"></a>什么是编码与解码</h2><p><strong>常⻅编码表 ASCII</strong></p><p>网上搜搜就好啦，这里就不赘述了</p><p>在中国是GB2312、GBK、GB18030，UTF-8</p><h1 id="3-二进制安全之反汇编理论"><a href="#3-二进制安全之反汇编理论" class="headerlink" title="3.二进制安全之反汇编理论"></a>3.二进制安全之反汇编理论</h1><h2 id="反汇编器"><a href="#反汇编器" class="headerlink" title="反汇编器"></a><strong>反汇编器</strong></h2><p>反汇编是将⼆进制代码转换成汇编代码</p><p>⾃⼰写⼀个反汇编引擎：【这里了解一下就好啦】</p><p>1.CPU x86 ，⾸先根据不同的CPU,找到CPU⼚商关于CPU指令相关的标准,根据⼆进制与汇编指令的对应关系,写出来⼆进制到汇编代码的转换模块.</p><p>2.根据不同的可执⾏⽂件,找到对应的格式标准,去解析可执⾏⽂件的结构,知道哪⼀块⼆进制是代码,哪⼀块是数据等.</p><h2 id="高级持久威胁-APT"><a href="#高级持久威胁-APT" class="headerlink" title="高级持久威胁(APT)"></a><strong>高级持久威胁</strong>(APT)</h2><p>⼀种网络攻击，这些攻击往往来自多个入口点，并且能使用多个攻击媒介【网络，物理，欺骗】</p><h2 id="PoC和Exploit"><a href="#PoC和Exploit" class="headerlink" title="PoC和Exploit"></a>PoC和Exploit</h2><p>PoC(Proof of Conecpt)，概念性证明，是证明漏洞存在而提供的⼀段代码或方法，只要能触发漏洞即可。</p><p>Exploit是指能够实现漏洞利用的代码，程序或者方法。是PoC的子集。</p><h2 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h2><p>就是溢出了，超出了边界，造成的程序崩溃或者执行了攻击者的命令。</p><h2 id="攻击载荷-Payload"><a href="#攻击载荷-Payload" class="headerlink" title="攻击载荷 Payload"></a>攻击载荷 Payload</h2><p>是系统被攻陷后执行的多阶段恶意代码。</p><p>攻击载荷是在漏洞攻击模块之上的【这里可以想一想MSF咋用的】这个payload就是用来造成破坏的。</p><h2 id="加壳"><a href="#加壳" class="headerlink" title="加壳"></a>加壳</h2><p>UPX ， vmp</p><p> 利用特殊的算法，将EXE可执行程序或者DLL动态连接文件的编码进行改变【实现压缩，加密】，实现缩小文件体积或者加密程序编码，或者躲过杀毒软件的查杀【加壳不单单用来躲过杀毒软件的哦】</p><h2 id="软件脱壳"><a href="#软件脱壳" class="headerlink" title="软件脱壳"></a>软件脱壳</h2><p>利用工具，脱去壳。</p><h2 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h2><p>加壳，加密，修改特征码，花指令…逃过杀毒软件的查杀。</p><h2 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h2><p>就是垃圾指令【写一堆注释】恶心杀毒软件</p><h2 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h2><p>Command and Control</p><p>常见于APT【红队】攻击场景中，就是恶意软件和攻击者进行交互，也是攻击者的“基础设施”【Metasploit    Cobalt Strike…】</p><h2 id="打补丁（Patching）"><a href="#打补丁（Patching）" class="headerlink" title="打补丁（Patching）"></a>打补丁（Patching）</h2><p>提高安全性增强性能</p><h2 id="Rootkit"><a href="#Rootkit" class="headerlink" title="Rootkit"></a>Rootkit</h2><p>攻击者，隐藏自己的行踪和保留权限的工具。达到长时间控制对方的目的，和后面木马差不多</p><h2 id="模糊测试（fuzz-testing-fuzzing）"><a href="#模糊测试（fuzz-testing-fuzzing）" class="headerlink" title="模糊测试（fuzz testing, fuzzing）"></a>模糊测试（fuzz testing, fuzzing）</h2><p>就是软件测试技术。核心就是将自动或者半自动的生成的随机数输入到一个程序中。并监视程序异常，用来发现程序错误</p><h2 id="是汇编语言？"><a href="#是汇编语言？" class="headerlink" title="是汇编语言？"></a>是汇编语言？</h2><p>Arm，X86，mips….</p><p>之前写的8086和win32。</p><p>BUUCTF</p><h1 id="3-如何反汇编？"><a href="#3-如何反汇编？" class="headerlink" title="3.如何反汇编？"></a>3.如何反汇编？</h1><h2 id="反汇编工具"><a href="#反汇编工具" class="headerlink" title="反汇编工具"></a>反汇编工具</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OD</span><br><span class="line">IDA Pro</span><br><span class="line">radare2</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h2 id="虚拟机的建设"><a href="#虚拟机的建设" class="headerlink" title="虚拟机的建设"></a>虚拟机的建设</h2><p>1.win 7 的 【集成了很多工具的】</p><p>2.ubunt （含有PWN环境）</p><p>【如果需要可以找我】</p><p>【这里需要学一学linux的相关的命令】–以后也会初相对应的内容的</p><p>然后进入ubunt 开始编译一个c文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">下面的命令可以用tab补全，别傻乎乎的全部记</span><br><span class="line"></span><br><span class="line">cd Desktop/ 进入桌面</span><br><span class="line">ls查看一下</span><br><span class="line">mkdir class创建一个目录</span><br><span class="line">cd class进入class</span><br><span class="line">vim add.c用vim这个编辑器创建一个add.c的文件</span><br><span class="line">回车</span><br><span class="line">进入一个页面后 按下 a  进入插入模式</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>写入如下的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">static int add_a_and_b(int a, int b)</span><br><span class="line">&#123;</span><br><span class="line"> return a + b;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, const char *argv[])</span><br><span class="line">&#123;</span><br><span class="line"> int a = 1;</span><br><span class="line"> int b = 2;</span><br><span class="line"> int c;</span><br><span class="line"> </span><br><span class="line"> c = add_a_and_b(a, b);</span><br><span class="line"> printf(&quot; %d + %d = %d\n&quot;, a, b, c);</span><br><span class="line"> </span><br><span class="line"> return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按下 esc</span><br><span class="line">按下shitf + :</span><br><span class="line">输入wq 保存并退出</span><br></pre></td></tr></table></figure><p>出来后可以查看一下这个add.c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat add.c</span><br></pre></td></tr></table></figure><p>现在是写了一个c文件但是没有编译</p><p>对之进行编译，并且保存在add这个文件中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o add add.c</span><br></pre></td></tr></table></figure><p>然后可以ls一下，现在发现多了一个add【绿色的】和一个add.c</p><p>查看一下add 这个文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file add</span><br></pre></td></tr></table></figure><p>通过file命令，就知道这个add可执行文件是一个elf文件。</p><p>查看权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al</span><br></pre></td></tr></table></figure><p>运行一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./add</span><br></pre></td></tr></table></figure><p>就能看到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 2 = 3</span><br></pre></td></tr></table></figure><p>按照elf文件【add】为输入，得到汇编代码==&gt;就是反汇编</p><p>来反汇编一下【现在看一下就好了，后面会学】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objdump -l -x -d add &gt; add.dmp</span><br></pre></td></tr></table></figure><p>然后来看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat add.dmp</span><br></pre></td></tr></table></figure><p>emm 卧槽好多….找到这个目录，把他复制出来可以用编译器打开看着舒服点..</p><p>之前大概学过汇编，所以大概也能看懂。首先找到程序的入口点也就是main函数</p><p>到此，这里就结束了，让我们一起去下一章吧！</p>]]></content>
      
      
      <categories>
          
          <category> 二进制安全逆向 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-使用资源（5）</title>
      <link href="/2023/05/04/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5-%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90/"/>
      <url>/2023/05/04/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-5-%E4%BD%BF%E7%94%A8%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<ul><li>资源文件的“源文件”是 .rc 的脚本文件</li></ul><h1 id="菜单和加速健"><a href="#菜单和加速健" class="headerlink" title="菜单和加速健"></a>菜单和加速健</h1><h2 id="1-菜单和加速键的组成"><a href="#1-菜单和加速键的组成" class="headerlink" title="1.菜单和加速键的组成"></a>1.菜单和加速键的组成</h2><ul><li>加速健就是快捷键</li><li>/# sharp</li><li>这里有一个工具 resedit-x64 </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">闪退：</span><br><span class="line">在文件：ResEdit.xml中查找行&quot;&lt;autoCheckupdate value=&quot;true&quot;/&gt;&quot;，并将其替换为&quot;&lt;autocheckUpdate value=&quot;false&quot; /&gt;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">设置中文</span><br><span class="line">ctrl+P 在第一个地方把语言 english设置成chinese</span><br></pre></td></tr></table></figure><p>ok用这个工具，创建一个菜单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$F -&gt; </span><br><span class="line">\t -&gt; tab健</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230504163520949.png" alt="image-20230504163520949"></p><h2 id="2-菜单和加速键的定义"><a href="#2-菜单和加速键的定义" class="headerlink" title="2.菜单和加速键的定义"></a>2.菜单和加速键的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">#include&lt;resource.h&gt;</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">#defineICO_MAIN0x1000//图标</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">#defineIDM_MAIN0x2000//菜单</span><br><span class="line">#defineIDA_MAIN0x2000//加速键</span><br><span class="line">#defineIDM_OPEN0x4101</span><br><span class="line">#defineIDM_OPTION0x4102</span><br><span class="line">#defineIDM_EXIT0x4103   </span><br><span class="line">#defineIDM_SETFONT0x4201</span><br><span class="line">#defineIDM_SETCOLOR0x4202</span><br><span class="line">#defineIDM_INACT0x4203</span><br><span class="line">#defineIDM_GRAY0x4204</span><br><span class="line">#defineIDM_BIG0x4205</span><br><span class="line">#defineIDM_SMALL0x4206</span><br><span class="line">#defineIDM_LIST0x4207</span><br><span class="line">#defineIDM_DETAIL0x4208</span><br><span class="line">#defineIDM_TOOLBAR0x4209</span><br><span class="line">#defineIDM_TOOLBARTEXT0x4210</span><br><span class="line">#defineIDM_INPUTBAR0x4211</span><br><span class="line">#defineIDM_STATUSBAR0x4212</span><br><span class="line">#defineIDM_HELP0x4301</span><br><span class="line">#defineIDM_ABOUT0x4302</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">ICO_MAINICON&quot;Main.ico&quot;</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">IDM_MAINmenudiscardable</span><br><span class="line">BEGIN</span><br><span class="line">popup&quot;文件(&amp;F)&quot;</span><br><span class="line">BEGIN</span><br><span class="line">menuitem&quot;打开文件(&amp;O)...&quot;,IDM_OPEN</span><br><span class="line">menuitem&quot;关闭文件(&amp;C)...&quot;,IDM_OPTION</span><br><span class="line">menuitemseparator</span><br><span class="line">menuitem&quot;退出(&amp;X)&quot;,IDM_EXIT</span><br><span class="line">END</span><br><span class="line">popup&quot;查看(&amp;V)&quot;</span><br><span class="line">BEGIN</span><br><span class="line">menuitem&quot;字体(&amp;F)...\tAlt+F&quot;,IDM_SETFONT</span><br><span class="line">menuitem&quot;背景色(&amp;B)...\tCtrl+Alt+B&quot;,IDM_SETCOLOR</span><br><span class="line">menuitemSEPARATOR//这个的意思是:画一个分隔符</span><br><span class="line">menuitem&quot;被禁用的菜单项&quot;,IDM_INACT,INACTIVE</span><br><span class="line">menuitem&quot;被灰化的菜单项&quot;,IDM_GRAY,GRAYED</span><br><span class="line">menuitemSEPARATOR</span><br><span class="line">menuitem&quot;大图标(&amp;G)&quot;,IDM_BIG</span><br><span class="line">menuitem&quot;小图标(&amp;M)&quot;,IDM_SMALL</span><br><span class="line">menuitem&quot;列表(&amp;L)&quot;,IDM_LIST</span><br><span class="line">menuitem&quot;详细资料(&amp;D)&quot;,IDM_DETAIL</span><br><span class="line">menuitemseparator</span><br><span class="line">popup&quot;工具栏(&amp;T)&quot;</span><br><span class="line">BEGIN</span><br><span class="line">   menuitem&quot;标准按钮(&amp;S)&quot;,IDM_TOOLBAR</span><br><span class="line">   menuitem&quot;文字标签(&amp;C)&quot;,IDM_TOOLBARTEXT</span><br><span class="line">   menuitem&quot;命令栏(&amp;I)&quot;,IDM_INPUTBAR</span><br><span class="line">END</span><br><span class="line">menuitem&quot;状态栏(&amp;U)&quot;,IDM_STATUSBAR</span><br><span class="line">END</span><br><span class="line">popup&quot;帮助(&amp;H)&quot;,HELP</span><br><span class="line">BEGIN</span><br><span class="line">menuitem&quot;帮助主题(&amp;H)\tF1&quot;,IDM_HELP</span><br><span class="line">menuitemseparator</span><br><span class="line">menuitem&quot;关于本程序(&amp;A)...&quot;,IDM_ABOUT</span><br><span class="line">END</span><br><span class="line">END</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">IDA_MAINaccelerators</span><br><span class="line">BEGIN</span><br><span class="line">VK_F1,IDM_HELP,VIRTKEY//这个是使用头文件里面包含好了的，加速键的定义方式</span><br><span class="line">&quot;B&quot;,IDM_SETCOLOR,VIRTKEY,CONTROL,ALT</span><br><span class="line">&quot;F&quot;,IDM_SETFONT,VIRTKEY,ALT</span><br><span class="line">END</span><br><span class="line">//&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="1-）菜单的定义"><a href="#1-）菜单的定义" class="headerlink" title="1.）菜单的定义"></a>1.）菜单的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">菜单ID MENU [DISCARDABLE] </span><br><span class="line">BEGIN</span><br><span class="line">菜单项定义</span><br><span class="line">...</span><br><span class="line">END </span><br></pre></td></tr></table></figure><p>在上面的代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#defineIDM_MAIN0x2000//菜单</span><br><span class="line"></span><br><span class="line">IDM_MAINmenudiscardable</span><br><span class="line">BEGIN</span><br><span class="line">...</span><br><span class="line">END</span><br></pre></td></tr></table></figure><ul><li><p>API函数在检测参数的时候，发现小于10000H的时候就把他认为是数值型，大于10000H的时候就把他当作字符串指针处理</p></li><li><p>discardable 是菜单的存属性，表示菜单在不使用的时候可以展示从内存中释放来节省空间</p></li><li><p>begin 和 end 可以用 { } 来代替</p></li></ul><p>菜单项的定义有3种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MENUITEM    菜单文字,命令ID [,选项列表] （用法1）</span><br><span class="line">MENUITEM    SEPARATOR                    （用法2）</span><br><span class="line">POPUP  菜单文字 [,选项列表] （用法3）    </span><br><span class="line">BEGIN            </span><br><span class="line">item-definitions</span><br><span class="line">...       </span><br><span class="line">END   </span><br></pre></td></tr></table></figure><p>用法1定义的是普通菜单项</p><p>●选项——用来定义菜单项的各种属性，它可以是下列数值：</p><p>■CHECKED——表示打上选定标志（对钩）。</p><p>■GRAYED——表示菜单项是灰化的。</p><p>■INACTIVE——表示菜单项是禁用的。</p><p>■MENUBREAK或MENUBARBREAK——表示将这个菜单项和以后的菜单项列到新的列中</p><p>用法2定义的是菜单项之间的分隔线。</p><p>用法3定义弹出式菜单</p><p>popup菜单的选项列表可以是以下的值：</p><p>●GRAYED——表示菜单项是灰化的。</p><p>●INACTIVE——表示菜单项是禁用的</p><p>●HELP——表示本项和以后的菜单项是右对齐的</p><h3 id="2-）加速键的定义"><a href="#2-）加速键的定义" class="headerlink" title="2.）加速键的定义"></a>2.）加速键的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">加速键ID ACCELERATORS </span><br><span class="line">BEGIN </span><br><span class="line">键名, 命令ID [,类型] [,选项]     </span><br><span class="line">... </span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>上面的代码就是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">IDA_MAINaccelerators</span><br><span class="line">BEGIN</span><br><span class="line">VK_F1,IDM_HELP,VIRTKEY//这个是使用头文件里面包含好了的，加速键的定义方式</span><br><span class="line">&quot;B&quot;,IDM_SETCOLOR,VIRTKEY,CONTROL,ALT</span><br><span class="line">&quot;F&quot;,IDM_SETFONT,VIRTKEY,ALT</span><br><span class="line">END</span><br></pre></td></tr></table></figure><ul><li>加速键ID同样可以是一个字符串或者是1～65 535之间的数字</li><li>整个定义内容也是用begin和end（或花括号）包含起来</li></ul><p>字段的含义如下所示</p><p>●键名——表示加速键对应的按键，可以有3种方式定义。</p><p>■”^字母”：表示Ctrl键加上字母键。</p><p>■”字母”：表示字母，这时类型必须指明是VIRTKEY。</p><p>■数值：表示ASCII码为该数值的字母，这时类型必须指明为ASCII。</p><p>●命令ID——按下加速键后，Windows向程序发送的命令ID。如果想把加速键和菜单项关联起来，这里就是要关联菜单项的命令ID。</p><p>●类型——用来指定键的定义方式，可以是VIRTKEY和ASCII，分别用来表示“键名”字段定义的是虚拟键还是ASCII码。</p><p>●选项——可以是Alt，Control或Shift中的单个或多个，如果指定多个，则中间用逗号隔开，表示加速键是按键加上这些控制键的组合键。</p><h3 id="3-）使用菜单和加速键"><a href="#3-）使用菜单和加速键" class="headerlink" title="3.）使用菜单和加速键"></a>3.）使用菜单和加速键</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Sample code for &lt; Win32ASM Programming 3rd Edition&gt;</span><br><span class="line">; by 罗云彬, http://www.win32asm.com.cn</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Menu.asm</span><br><span class="line">; 菜单资源的使用例子</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 使用 nmake 或下列命令进行编译和链接:</span><br><span class="line">; ml /c /coff Menu.asm</span><br><span class="line">; rc Menu.rc</span><br><span class="line">; Link /subsystem:windows Menu.obj Menu.res</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.386</span><br><span class="line">.model flat, stdcall</span><br><span class="line">option casemap :none</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">includewindows.inc</span><br><span class="line">includeuser32.inc</span><br><span class="line">includelibuser32.lib</span><br><span class="line">includekernel32.inc</span><br><span class="line">includelibkernel32.lib</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; Equ 等值定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">ICO_MAINequ1000h;图标</span><br><span class="line">IDM_MAINequ2000h;菜单</span><br><span class="line">IDA_MAINequ2000h;加速键</span><br><span class="line">IDM_OPENequ4101h</span><br><span class="line">IDM_OPTIONequ4102h</span><br><span class="line">IDM_EXITequ4103h</span><br><span class="line">IDM_SETFONTequ4201h</span><br><span class="line">IDM_SETCOLORequ4202h</span><br><span class="line">IDM_INACTequ4203h</span><br><span class="line">IDM_GRAYequ4204h</span><br><span class="line">IDM_BIGequ4205h</span><br><span class="line">IDM_SMALLequ4206h</span><br><span class="line">IDM_LISTequ4207h</span><br><span class="line">IDM_DETAILequ4208h</span><br><span class="line">IDM_TOOLBARequ4209h</span><br><span class="line">IDM_TOOLBARTEXTequ4210h</span><br><span class="line">IDM_INPUTBARequ4211h</span><br><span class="line">IDM_STATUSBARequ4212h</span><br><span class="line">IDM_HELPequ4301h</span><br><span class="line">IDM_ABOUTequ4302h</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.data?</span><br><span class="line">hInstancedd?</span><br><span class="line">hWinMaindd?</span><br><span class="line">hMenudd?</span><br><span class="line">hSubMenudd?</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 数据段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.const</span><br><span class="line">szClassNamedb&#x27;Menu Example&#x27;,0</span><br><span class="line">szCaptionMaindb&#x27;Menu&#x27;,0</span><br><span class="line">szMenuHelpdb&#x27;帮助主题(&amp;H)&#x27;,0</span><br><span class="line">szMenuAboutdb&#x27;关于本程序(&amp;A)...&#x27;,0</span><br><span class="line">szCaptiondb&#x27;菜单选择&#x27;,0</span><br><span class="line">szFormatdb&#x27;您选择了菜单命令：%08x&#x27;,0</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">; 代码段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">.code</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_DisplayMenuItemproc_dwCommandID</span><br><span class="line">local@szBuffer[256]:byte</span><br><span class="line"></span><br><span class="line">pushad</span><br><span class="line">invokewsprintf,addr @szBuffer,addr szFormat,_dwCommandID</span><br><span class="line">invokeMessageBox,hWinMain,addr @szBuffer,offset szCaption,MB_OK</span><br><span class="line">popad</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">_DisplayMenuItemendp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_Quitproc</span><br><span class="line"></span><br><span class="line">invokeDestroyWindow,hWinMain</span><br><span class="line">invokePostQuitMessage,NULL</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">_Quitendp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_ProcWinMainprocuses ebx edi esi hWnd,uMsg,wParam,lParam</span><br><span class="line">local@stPos:POINT</span><br><span class="line">local@hSysMenu</span><br><span class="line"></span><br><span class="line">moveax,uMsg</span><br><span class="line">.ifeax ==WM_CREATE</span><br><span class="line">invokeGetSubMenu,hMenu,1</span><br><span class="line">movhSubMenu,eax</span><br><span class="line">;********************************************************************</span><br><span class="line">;在系统菜单中添加菜单项</span><br><span class="line">;********************************************************************</span><br><span class="line">invokeGetSystemMenu,hWnd,FALSE</span><br><span class="line">mov@hSysMenu,eax</span><br><span class="line">invokeAppendMenu,@hSysMenu,MF_SEPARATOR,0,NULL</span><br><span class="line">invokeAppendMenu,@hSysMenu,0,IDM_HELP,offset szMenuHelp</span><br><span class="line">invokeAppendMenu,@hSysMenu,0,IDM_ABOUT,offset szMenuAbout</span><br><span class="line">;********************************************************************</span><br><span class="line">; 处理菜单及加速键消息</span><br><span class="line">;********************************************************************</span><br><span class="line">.elseifeax ==WM_COMMAND</span><br><span class="line">invoke_DisplayMenuItem,wParam</span><br><span class="line">moveax,wParam</span><br><span class="line">movzxeax,ax</span><br><span class="line">.ifeax ==IDM_EXIT</span><br><span class="line">call_Quit</span><br><span class="line">.elseifeax &gt;=IDM_TOOLBAR &amp;&amp; eax &lt;= IDM_STATUSBAR</span><br><span class="line">movebx,eax</span><br><span class="line">invokeGetMenuState,hMenu,ebx,MF_BYCOMMAND</span><br><span class="line">.ifeax ==MF_CHECKED</span><br><span class="line">moveax,MF_UNCHECKED</span><br><span class="line">.else</span><br><span class="line">moveax,MF_CHECKED</span><br><span class="line">.endif</span><br><span class="line">invokeCheckMenuItem,hMenu,ebx,eax</span><br><span class="line">.elseifeax &gt;=IDM_BIG &amp;&amp; eax &lt;= IDM_DETAIL</span><br><span class="line">invokeCheckMenuRadioItem,hMenu,IDM_BIG,IDM_DETAIL,eax,MF_BYCOMMAND</span><br><span class="line">.endif</span><br><span class="line">;********************************************************************</span><br><span class="line">; 处理系统菜单消息</span><br><span class="line">;********************************************************************</span><br><span class="line">.elseifeax == WM_SYSCOMMAND</span><br><span class="line">moveax,wParam</span><br><span class="line">movzxeax,ax</span><br><span class="line">.ifeax == IDM_HELP || eax == IDM_ABOUT</span><br><span class="line">invoke_DisplayMenuItem,wParam</span><br><span class="line">.else</span><br><span class="line">invokeDefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">ret</span><br><span class="line">.endif</span><br><span class="line">;********************************************************************</span><br><span class="line">; 按下右键时弹出一个POPUP菜单</span><br><span class="line">;********************************************************************</span><br><span class="line">.elseif eax == WM_RBUTTONDOWN</span><br><span class="line">invokeGetCursorPos,addr @stPos</span><br><span class="line">invokeTrackPopupMenu,hSubMenu,TPM_LEFTALIGN,@stPos.x,@stPos.y,NULL,hWnd,NULL</span><br><span class="line">;********************************************************************</span><br><span class="line">.elseifeax ==WM_CLOSE</span><br><span class="line">call_Quit</span><br><span class="line">;********************************************************************</span><br><span class="line">.else</span><br><span class="line">invokeDefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">ret</span><br><span class="line">.endif</span><br><span class="line">;********************************************************************</span><br><span class="line">xoreax,eax</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">_ProcWinMainendp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">_WinMainproc</span><br><span class="line">local@stWndClass:WNDCLASSEX</span><br><span class="line">local@stMsg:MSG</span><br><span class="line">local@hAccelerator</span><br><span class="line"></span><br><span class="line">invokeGetModuleHandle,NULL</span><br><span class="line">movhInstance,eax</span><br><span class="line">invokeLoadMenu,hInstance,IDM_MAIN</span><br><span class="line">movhMenu,eax</span><br><span class="line">invokeLoadAccelerators,hInstance,IDA_MAIN</span><br><span class="line">mov@hAccelerator,eax</span><br><span class="line">;********************************************************************</span><br><span class="line">; 注册窗口类</span><br><span class="line">;********************************************************************</span><br><span class="line">invokeRtlZeroMemory,addr @stWndClass,sizeof @stWndClass</span><br><span class="line">invokeLoadIcon,hInstance,ICO_MAIN</span><br><span class="line">mov@stWndClass.hIcon,eax</span><br><span class="line">mov@stWndClass.hIconSm,eax</span><br><span class="line">invokeLoadCursor,0,IDC_ARROW</span><br><span class="line">mov@stWndClass.hCursor,eax</span><br><span class="line">pushhInstance</span><br><span class="line">pop@stWndClass.hInstance</span><br><span class="line">mov@stWndClass.cbSize,sizeof WNDCLASSEX</span><br><span class="line">mov@stWndClass.style,CS_HREDRAW or CS_VREDRAW</span><br><span class="line">mov@stWndClass.lpfnWndProc,offset _ProcWinMain</span><br><span class="line">mov@stWndClass.hbrBackground,COLOR_WINDOW + 1</span><br><span class="line">mov@stWndClass.lpszClassName,offset szClassName</span><br><span class="line">invokeRegisterClassEx,addr @stWndClass</span><br><span class="line">;********************************************************************</span><br><span class="line">; 建立并显示窗口</span><br><span class="line">;********************************************************************</span><br><span class="line">invokeCreateWindowEx,WS_EX_CLIENTEDGE,\</span><br><span class="line">offset szClassName,offset szCaptionMain,\</span><br><span class="line">WS_OVERLAPPEDWINDOW,\</span><br><span class="line">100,100,400,300,\</span><br><span class="line">NULL,hMenu,hInstance,NULL</span><br><span class="line">movhWinMain,eax</span><br><span class="line">invokeShowWindow,hWinMain,SW_SHOWNORMAL</span><br><span class="line">invokeUpdateWindow,hWinMain</span><br><span class="line">;********************************************************************</span><br><span class="line">; 消息循环</span><br><span class="line">;********************************************************************</span><br><span class="line">.whileTRUE</span><br><span class="line">invokeGetMessage,addr @stMsg,NULL,0,0</span><br><span class="line">.break.if eax== 0</span><br><span class="line">invokeTranslateAccelerator,hWinMain,@hAccelerator,addr @stMsg</span><br><span class="line">.ifeax == 0</span><br><span class="line">invokeTranslateMessage,addr @stMsg</span><br><span class="line">invokeDispatchMessage,addr @stMsg</span><br><span class="line">.endif</span><br><span class="line">.endw</span><br><span class="line">ret</span><br><span class="line"></span><br><span class="line">_WinMainendp</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">start:</span><br><span class="line">call_WinMain</span><br><span class="line">invokeExitProcess,NULL</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line">endstart</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>emmm,我们不需要用这个东西来开发，所以我们看得懂就好啦</p><p>内容有点繁琐，看看书啦</p>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-第一个窗口程序（4）</title>
      <link href="/2023/05/04/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/04/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="开始了解窗口"><a href="#开始了解窗口" class="headerlink" title="开始了解窗口"></a>开始了解窗口</h1><h2 id="1-窗口是什么"><a href="#1-窗口是什么" class="headerlink" title="1.窗口是什么"></a>1.窗口是什么</h2><h3 id="1-）使用窗口的原因"><a href="#1-）使用窗口的原因" class="headerlink" title="1.）使用窗口的原因"></a>1.）使用窗口的原因</h3><ul><li>懒得说了，自行查阅</li></ul><h3 id="2-）窗口和程序的关系"><a href="#2-）窗口和程序的关系" class="headerlink" title="2.）窗口和程序的关系"></a>2.）窗口和程序的关系</h3><ul><li>一个窗口不一定是程序。可能是一个程序的一部分</li><li>一个程序也不能是一个窗口</li><li>窗口是人和计算机交互的界面</li><li>第一个标准的窗口为界面的程序的架构，而不是windows所有程序</li></ul><h2 id="2-窗口界面"><a href="#2-窗口界面" class="headerlink" title="2.窗口界面"></a>2.窗口界面</h2><ul><li>窗口大部分都长得差不多</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类的继承</span><br></pre></td></tr></table></figure><ul><li>窗口中有很多的部分，每一个部分都有自己的行为模式。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">类--&gt;对象</span><br><span class="line">就是使用api函数来写程序</span><br></pre></td></tr></table></figure><h2 id="3-窗口程序是如何工作的"><a href="#3-窗口程序是如何工作的" class="headerlink" title="3.窗口程序是如何工作的"></a>3.窗口程序是如何工作的</h2><h3 id="1-）窗口程序的运行模式"><a href="#1-）窗口程序的运行模式" class="headerlink" title="1.）窗口程序的运行模式"></a>1.）窗口程序的运行模式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">面向对象面向过程</span><br></pre></td></tr></table></figure><ul><li>窗口程序是事件驱动的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类似：面向对象</span><br></pre></td></tr></table></figure><h3 id="2-）FirstWindow源代码"><a href="#2-）FirstWindow源代码" class="headerlink" title="2.）FirstWindow源代码"></a>2.）FirstWindow源代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">.386 </span><br><span class="line">.model flat,stdcall </span><br><span class="line">option casemap:none </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">; Include 文件定义</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">include windows.inc </span><br><span class="line">include gdi32.inc </span><br><span class="line">includelib gdi32.lib </span><br><span class="line">include user32.inc </span><br><span class="line">includelib user32.lib </span><br><span class="line">include kernel32.inc </span><br><span class="line">includelib kernel32.lib </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">; 数据段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">.data? </span><br><span class="line"></span><br><span class="line">hInstance dd ? </span><br><span class="line">hWinMain dd ? </span><br><span class="line"></span><br><span class="line">.const </span><br><span class="line"></span><br><span class="line">szClassName db &#x27;MyClass&#x27;,0 </span><br><span class="line">szCaptionMain db &#x27;My first Window !&#x27;,0 </span><br><span class="line">szText db &#x27;Win32 Assembly, Simple and powerful !&#x27;,0 </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">; 代码段</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">.code </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">; 窗口过程</span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">_ProcWinMain proc uses ebx edi esi,hWnd,uMsg,wParam,lParam </span><br><span class="line">local @stPs:PAINTSTRUCT </span><br><span class="line">local @stRect:RECT </span><br><span class="line">local @hDc </span><br><span class="line"></span><br><span class="line">mov eax,uMsg </span><br><span class="line">;******************************************************************** </span><br><span class="line">.if eax == WM_PAINT </span><br><span class="line">invoke BeginPaint,hWnd,addr @stPs </span><br><span class="line">mov @hDc,eax</span><br><span class="line"></span><br><span class="line">invoke GetClientRect,hWnd,addr @stRect </span><br><span class="line">invoke DrawText,@hDc,addr szText,-1,\ </span><br><span class="line">addr @stRect,\ </span><br><span class="line">DT_SINGLELINE or DT_CENTER or DT_VCENTER </span><br><span class="line">invoke EndPaint,hWnd,addr @stPs </span><br><span class="line">;******************************************************************** </span><br><span class="line">.elseif eax == WM_CLOSE </span><br><span class="line">invoke DestroyWindow,hWinMain </span><br><span class="line">invoke PostQuitMessage,NULL </span><br><span class="line">;******************************************************************** </span><br><span class="line">.else </span><br><span class="line">invoke DefWindowProc,hWnd,uMsg,wParam,lParam </span><br><span class="line">ret </span><br><span class="line">.endif </span><br><span class="line">;******************************************************************** </span><br><span class="line">xor eax,eax </span><br><span class="line">ret </span><br><span class="line"></span><br><span class="line">_ProcWinMain endp </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">_WinMain proc </span><br><span class="line">local @stWndClass:WNDCLASSEX </span><br><span class="line">local @stMsg:MSG </span><br><span class="line"></span><br><span class="line">invoke GetModuleHandle,NULL </span><br><span class="line">mov hInstance,eax </span><br><span class="line">invoke RtlZeroMemory,addr @stWndClass,sizeof @stWndClass </span><br><span class="line">;******************************************************************** </span><br><span class="line">; 注册窗口类</span><br><span class="line">;******************************************************************* </span><br><span class="line"> invoke LoadCursor,0,IDC_ARROW </span><br><span class="line"> mov @stWndClass.hCursor,eax </span><br><span class="line"> pushhInstance </span><br><span class="line"> pop @stWndClass.hInstance </span><br><span class="line"> mov @stWndClass.cbSize,sizeof WNDCLASSEX </span><br><span class="line"> mov@stWndClass.style,CS_HREDRAW or CS_VREDRAW </span><br><span class="line"> mov @stWndClass.lpfnWndProc,offset _ProcWinMain </span><br><span class="line"> mov @stWndClass.hbrBackground,COLOR_WINDOW + 1 </span><br><span class="line"> mov @stWndClass.lpszClassName,offset szClassName </span><br><span class="line"> invoke RegisterClassEx,addr @stWndClass </span><br><span class="line">;******************************************************************** </span><br><span class="line">; 建立并显示窗口</span><br><span class="line">;******************************************************************** </span><br><span class="line"> invoke CreateWindowEx,WS_EX_CLIENTEDGE,\ </span><br><span class="line"> offsetszClassName,offset szCaptionMain,\ </span><br><span class="line">WS_OVERLAPPEDWINDOW,\ </span><br><span class="line">100,100,600,400,\ </span><br><span class="line">NULL,NULL,hInstance,NULL </span><br><span class="line"> mov hWinMain,eax </span><br><span class="line"> invoke ShowWindow,hWinMain,SW_SHOWNORMAL </span><br><span class="line"> invoke UpdateWindow,hWinMain </span><br><span class="line">;******************************************************************** </span><br><span class="line">; 消息循环</span><br><span class="line">;******************************************************************** </span><br><span class="line"> .while TRUE </span><br><span class="line"> invoke GetMessage,addr @stMsg,NULL,0,0 </span><br><span class="line"> .break .if eax == 0 </span><br><span class="line"> invoke TranslateMessage,addr @stMsg </span><br><span class="line"> invoke DispatchMessage,addr @stMsg </span><br><span class="line"> .endw </span><br><span class="line"> ret </span><br><span class="line">_WinMain endp </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; </span><br><span class="line">start: </span><br><span class="line"> call _WinMain </span><br><span class="line"> invoke ExitProcess,NULL </span><br><span class="line">;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span><br><span class="line"></span><br><span class="line">endstart</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>在windows下的编程，基本都是调用API函数</li></ul><h3 id="3-框架分析"><a href="#3-框架分析" class="headerlink" title="3.)框架分析"></a>3.)框架分析</h3><ul><li>读代码首先要找入口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">start -&gt; _WinMain -&gt; Exitprocess</span><br></pre></td></tr></table></figure><ul><li>从调用的API函数入手</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetModuleHandle--&gt;RtlZeroMemory--&gt;LoadCursor--&gt;RegisterClassEx--&gt;CreateWindowEx--&gt;ShowWindow--&gt;UpdateWindow</span><br></pre></td></tr></table></figure><ul><li>然后是三个API函数的循环</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.while TRUE </span><br><span class="line">invoke GetMessage,addr @stMsg,NULL,0,0 </span><br><span class="line">.break .if eax == 0 </span><br><span class="line">invoke TranslateMessage,addr @stMsg </span><br><span class="line">invoke DispatchMessage,addr @stMsg </span><br><span class="line">.endw</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GetMessage --&gt;TranslateMessage --&gt;DispatchMessage</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230423230508501.png" alt="image-20230423230508501"></p><ul><li><p> 回调函数，就是windows自己调用的函数，不是我们自己调用的</p></li><li><p>  windows在系统内部有一个系统消息队列，当输入设备有所动作的时候，windows都会记录在队列里面</p></li></ul><h3 id="4-）PostMessage和SendMessage"><a href="#4-）PostMessage和SendMessage" class="headerlink" title="4.）PostMessage和SendMessage"></a>4.）PostMessage和SendMessage</h3><ul><li>PostMessage是吧消息放到其他程序的消息队列中</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：图中的d箭头，目标程序收到了这条消息就把他放入该程序的消息队列处理</span><br></pre></td></tr></table></figure><ul><li>SendMessage则越过直接调用目标程序的窗口</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如：途中的箭头I，窗口过程返回以后才从SendMessage返回，如箭头II</span><br></pre></td></tr></table></figure><h1 id="分析窗口程序"><a href="#分析窗口程序" class="headerlink" title="分析窗口程序"></a>分析窗口程序</h1><ul><li>下边将详细分析窗口程序咯</li><li>调用API函数，来实现功能。</li></ul><h2 id="1-模块和句柄"><a href="#1-模块和句柄" class="headerlink" title="1.模块和句柄"></a>1.模块和句柄</h2><h3 id="1-）句柄是什么"><a href="#1-）句柄是什么" class="headerlink" title="1.）句柄是什么"></a>1.）句柄是什么</h3><ul><li>句柄是windows用来表示各种资源的编号</li><li>windows中的东西都是用句柄来标识的，直接用就好了</li></ul><h3 id="2-）模块是什么"><a href="#2-）模块是什么" class="headerlink" title="2.）模块是什么"></a>2.）模块是什么</h3><ul><li>一个模块代表的是一个运行中的exe文件或dll文件，用来代表这个文件中所有的代码和资源，磁盘上的文件不是模块，装入内存后运行的时候叫模块</li><li>取模块句柄使用的API函数是    GetModuleHandle</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke GetModuleHandle,lpModuleName</span><br></pre></td></tr></table></figure><ul><li><p>lpModuleName 参数是指向该模块名称 字符串的指针</p></li><li><p>比如想得到User32.dll的句柄</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">szUserDlldb&#x27;User32.dll&#x27;,0</span><br><span class="line">...</span><br><span class="line">invokeGetModuleHandle,addr szUserDll</span><br><span class="line">.ifeax</span><br><span class="line">movhUserDllHandle,eax</span><br><span class="line">.endif</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>如果参数是NULL则GetModuleHandle，那么得到的是调用本模块的句柄</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">invokeGetModuleHandle,NULL</span><br><span class="line">movhInstance,eax</span><br></pre></td></tr></table></figure><ul><li>h的意思就是句柄</li></ul><h2 id="2-创建窗口"><a href="#2-创建窗口" class="headerlink" title="2.创建窗口"></a>2.创建窗口</h2><ul><li>类【不多说】</li><li>windows中创建窗口使用这样的层次结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.定义一个床亏类</span><br></pre></td></tr></table></figure><h3 id="1-）注册窗口类"><a href="#1-）注册窗口类" class="headerlink" title="1.）注册窗口类"></a>1.）注册窗口类</h3><ul><li>注册窗口类的API函数是  RegisterClassEx </li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ex是扩展的意思</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">local@stWndClass:WNDCLASSEX</span><br><span class="line">...[通过索引这个对象中的东西去修改]</span><br><span class="line">invokeRegisterClassEx,addr @stWndClass</span><br></pre></td></tr></table></figure><ul><li>这个函数里面会有很多属性，这些属性应该用多个参数送过去，但是太多了，所以就吧这些参数定义在一个类中WNDCLASSEX</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX STRUCT</span><br><span class="line">  cbSize            DWORD      ?;结构的字节数</span><br><span class="line">  style             DWORD      ?;类风格</span><br><span class="line">  lpfnWndProc       DWORD      ?;窗口过程的地址</span><br><span class="line">  cbClsExtra        DWORD      ?</span><br><span class="line">  cbWndExtra        DWORD      ?</span><br><span class="line">  hInstance         DWORD      ?;所属的实例句柄</span><br><span class="line">  hIcon             DWORD      ?;窗口句柄</span><br><span class="line">  hCursor           DWORD      ?;窗口光标</span><br><span class="line">  hbrBackground     DWORD      ?;背景色</span><br><span class="line">  lpszMenuName      DWORD      ?;窗口菜单</span><br><span class="line">  lpszClassName     DWORD      ?;类名字符串的地址</span><br><span class="line">  hIconSm           DWORD      ?;小图标</span><br><span class="line">WNDCLASSEX ENDS</span><br></pre></td></tr></table></figure><ul><li><p>程序定义了一个WNDCLASSEX结构的变量@stWndClass，用RtlZeroMemory   API函数将他里面的内容全部填写0【这里是局部变量，所以需要置为0】，再填写结构的各个字段。</p></li><li><p>这里每一个参数都有自己的意义和用法，强烈建议查资料，或者看书P101-102</p></li><li><p>补充一个知识点，对于不同二进制位组合的计算。强烈建议使用or</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当某个东西是靠着，二进制某些位上的0/1来判断是否使用的某功能的时候，如果好几张功能想同时使用，一般下是使用or【逻辑或】来进行。</span><br><span class="line">比如：P102下面的小灯泡。</span><br><span class="line"></span><br><span class="line">or ==&gt; 一真即真【不懂自己百度】</span><br><span class="line">and ==&gt; 一假即假</span><br></pre></td></tr></table></figure><h3 id="2-）建立窗口"><a href="#2-）建立窗口" class="headerlink" title="2.）建立窗口"></a>2.）建立窗口</h3><ul><li>在注册窗口类的时候，是把窗口很多“共性”都写在了一起。</li><li>建立窗口，就还需要去指定窗口的很多“个性化”的参数</li><li>建立窗口的API函数是：CreateWindowEx</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke  CreateWindowEx,dwExStyle,lpClassName,lpWindowName,dwStyle,\          x,y,nWidth,nHeight,hWndParent,hMenu,hInstance,lpParam</span><br></pre></td></tr></table></figure><ul><li>它每一个参数都有自己的意义</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请结合书P103-104</span><br></pre></td></tr></table></figure><ul><li>把窗口显示出来的API函数是：ShowWindow</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ShowWindow,句柄,显示方式</span><br><span class="line">第一个参数是句柄，第二个是显示方式P106</span><br></pre></td></tr></table></figure><h3 id="3-整一个按钮"><a href="#3-整一个按钮" class="headerlink" title="3.)整一个按钮"></a>3.)整一个按钮</h3><ul><li>这个去看windowpro文件</li></ul><h2 id="3-消息循环"><a href="#3-消息循环" class="headerlink" title="3.消息循环"></a>3.消息循环</h2><ul><li>windows是一个以消息驱动的操作系统</li><li>windows中有一个消息队列</li><li>应用程序中含有一段称为“消息循环”的代码，用来从消息队列中检索这些消息并把他们分发到相应的窗口函数中</li></ul><h3 id="1-）消息循环的一般形式"><a href="#1-）消息循环的一般形式" class="headerlink" title="1.）消息循环的一般形式"></a>1.）消息循环的一般形式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local @stMsg:MSG</span><br><span class="line"> </span><br><span class="line">.while TRUE </span><br><span class="line"> invoke GetMessage,addr @stMsg,NULL,0,0 </span><br><span class="line"> .break .if eax == 0 </span><br><span class="line"> invoke TranslateMessage,addr @stMsg </span><br><span class="line"> invoke DispatchMessage,addr @stMsg </span><br><span class="line"> .endw </span><br></pre></td></tr></table></figure><ul><li>消息循环中要用到一个MSG结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MSGSTRUCT</span><br><span class="line">hwndDWORD?</span><br><span class="line">messageDWORD?</span><br><span class="line">wparamDWORD?</span><br><span class="line">lparamDWORD?</span><br><span class="line">timeDWORD?</span><br><span class="line">ptPOINT&lt;&gt;</span><br><span class="line">MSGENDS</span><br></pre></td></tr></table></figure><ul><li>其中的含义请看书P107</li><li>这个结构定义了消息的所有属性，GetMessage就是从消息队列中取出这样一条消息的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invokeGetMessage,lpMsg,hWnd,wMsgFilterMin,wMsgFilterMax</span><br></pre></td></tr></table></figure><ul><li><p>hWnd参数指定要获得哪个窗口的消息，例子中为NULL则就是本程序所属窗口的消息</p></li><li><p> TranslateMessage</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TranslateMessage,addr @stMsg </span><br></pre></td></tr></table></figure><ul><li>DispatchMessage</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DispatchMessage,addr @stMsg </span><br></pre></td></tr></table></figure><ul><li>作用请看P108【确实很烦，多看几遍】</li></ul><h3 id="2-）其他形式的消息循环"><a href="#2-）其他形式的消息循环" class="headerlink" title="2.）其他形式的消息循环"></a>2.）其他形式的消息循环</h3><ul><li>首先我们得知道的是：任务之间是20ms切换一次，在到某个任务的时候，不论在工作或者等待，都得等待20ms才会进入下一个任务</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">所以如果GetMessage中没有任何消息的话，就会等待20ms，从而浪费时间。【这个浪费时间其实是对CPU的内耗，因为CPU要一直从消息队列里面去获取消息，但是又获取不到消息，这样就会白白的消耗CPU】</span><br></pre></td></tr></table></figure><ul><li>GetMessage函数是程序空闲的时候主动将控制权 windows的一种方式，windows是一个抢占式的多任务系统…</li><li>这里如果啥都没有就会时间内耗，在while循环中等待，没任何意义，所以有更好的办法。<ul><li>用PeekMessage      api函数</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">.whileTRUE</span><br><span class="line">invoke PeekMessage,addr @stMsg,NULL,0,0,PM_REMOVE</span><br><span class="line">        .ifeax</span><br><span class="line">        .break.if  @stMsg.message == WM_QUIT</span><br><span class="line">        invokeTranslateMessage,addr @stMsg </span><br><span class="line">        invokeDispatchMessage,addr @stMsg </span><br><span class="line">        .else</span><br><span class="line">        &lt;其他的工作&gt;</span><br><span class="line">        .endif</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure><ul><li>PeekMessage是一个类似GetMessage的函数，区别在于当消息队列里面有消息的时候，PeekMessage取回消息，并在eax中返回非零值。</li><li>当消息队列里面没有消息的时候，就可以直接去运行其他工作，达到很好的使用。</li><li>PeekMessage前面的参数和GetMessage一样。</li><li>最后一个参数表示在取回消息后，对消息队列中的消息是否保留。这里使用PM_REMOVE就是不保留。</li></ul><h2 id="4-窗口过程"><a href="#4-窗口过程" class="headerlink" title="4.窗口过程"></a>4.窗口过程</h2><ul><li><p>首先窗口过程，是给windows回调用的。【也就是说它是一个函数】并且是一个自己创建的函数【这个函数的参数是定好的了的】</p></li><li><p>这个窗口过程，对于windows来说，地址来才是所需要的。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WindowProcprochwnd, uMsg, wParam, lParam</span><br></pre></td></tr></table></figure><ul><li><p>第一个参数是窗口句柄，由于一个窗口过程可能为多个基于同一个窗口类的窗口服务，所以windows回调的时候必须指定要操作的，要对这个对象进行运用都需要句柄</p></li><li><p>第二个参数是消息标志，后面俩个参数是消息的俩个参数</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">WindowProcprocuses ebx edi esi hWnd,uMsg,wParam,lParam</span><br><span class="line">moveax,uMsg</span><br><span class="line">.ifeax == WM_XXX</span><br><span class="line">&lt;处理WM_XXX消息&gt;</span><br><span class="line">.elseifeax == WM_YYY</span><br><span class="line">&lt;处理WM_YYY消息&gt;</span><br><span class="line">.elseifeax == WM_CLOSE</span><br><span class="line">invoke Desinvoke DestroyWindow,hWinMain </span><br><span class="line">invoke PostQuitMessage,NULL </span><br><span class="line">.else</span><br><span class="line">invokeDefWindowProc,hWnd,uMsg,wParam,lParam</span><br><span class="line">ret</span><br><span class="line">.endif</span><br><span class="line"></span><br><span class="line">xoreax,eax</span><br><span class="line">ret</span><br><span class="line">WindowProcendp</span><br></pre></td></tr></table></figure><ul><li><p>这个过程主要是对uMsg参数中的消息编号构成一个分支语句</p></li><li><p>但对于需要处理的消息分别处理。不感兴趣的消息都给DefWindowProc处理</p></li><li><p>ebx edi esi ebp 是指针寄存器，需要保存起来</p></li><li><p>ecx edx 就不需要咯 </p></li><li><p>又很多内容，请看P110</p></li></ul><h3 id="2-收到消息的顺序"><a href="#2-收到消息的顺序" class="headerlink" title="2.)收到消息的顺序"></a>2.)收到消息的顺序</h3><p>P111-112</p><h3 id="3-消息默认处理–DefWindowProc"><a href="#3-消息默认处理–DefWindowProc" class="headerlink" title="3.)消息默认处理–DefWindowProc"></a>3.)消息默认处理–DefWindowProc</h3><h1 id="窗口间的通信"><a href="#窗口间的通信" class="headerlink" title="窗口间的通信"></a>窗口间的通信</h1><h2 id="1-窗口间的消息互发"><a href="#1-窗口间的消息互发" class="headerlink" title="1.窗口间的消息互发"></a>1.窗口间的消息互发</h2><p>Emmmm 学了这么多，总感觉迷迷糊糊的。要不直接来学学二进制吧。哈哈啊哈</p>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-阅读必看（0)</title>
      <link href="/2023/05/03/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-0-%E9%98%85%E8%AF%BB%E5%BF%85%E7%9C%8B/"/>
      <url>/2023/05/03/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-0-%E9%98%85%E8%AF%BB%E5%BF%85%E7%9C%8B/</url>
      
        <content type="html"><![CDATA[<p>该内容来自《琢石成器》——Windwos环境下32位汇编语言程序设计</p><p>和b站小甲鱼win32视频</p><p>所自己写的部分笔记</p>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-使用MASM（3）</title>
      <link href="/2023/05/03/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-%E4%BD%BF%E7%94%A8MASM/"/>
      <url>/2023/05/03/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-3-%E4%BD%BF%E7%94%A8MASM/</url>
      
        <content type="html"><![CDATA[<h1 id="Win32汇编源程序的结构"><a href="#Win32汇编源程序的结构" class="headerlink" title="Win32汇编源程序的结构"></a>Win32汇编源程序的结构</h1><ul><li>通过helloword走进win32汇编</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szCaption db &#x27;A MessageBox&#x27;,0</span><br><span class="line">szText db &#x27;Hello,World!&#x27;,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke MessageBox,NULL,offset szText,\</span><br><span class="line">offset szCaption,MB_OK</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1.模式定义"></a>1.模式定义</h2><ul><li>程序的第一部分是模式和源程序格式的定义语句</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br></pre></td></tr></table></figure><ul><li>这些指令定义了程序使用的指令集，互作模式和格式</li></ul><p>1.指令集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.386p</span><br><span class="line">.......</span><br></pre></td></tr></table></figure><ul><li>后面带有p的伪指令，表示可以使用特权指令【0级】</li></ul><p>2.互作模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.model 内存模式[,语言模式][,其他模式]</span><br><span class="line">内存模式的定义影响最后生成的可执行文件，可执行文件的规模从小到大，可以有很多种类型。</span><br></pre></td></tr></table></figure><ul><li>windows程序运行在保护模式下，系统把每一个win32应用程序都放到分开的虚拟地址空间中去运行，耶就是说，每一个应用程序都拥有其相互独立的4GB地址空间</li><li>对于win32程序来说，只有一种内存模式，也就是flat模式</li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230421101920721.png" alt="image-20230421101920721"></p><ul><li><p> 在win32汇编中，.model语句还应该指定语言模式，也就是子程序和调用方法</p></li><li><p> 例子中用的是stdcall，它指出了伊奥用子程序或win32 API时参数传递的次序和堆栈平衡的方法</p></li><li><p>相对于stdcall，不同的语言类型还有C,syscall,BASIC , FORTRAN和PASCALL，虽然各种高级语言在调用子程序的时候，都是用堆栈来传递参数</p></li><li><p>windows的api调用使用的是stdcall格式，所以在win32汇编中没有选择，必须在.model中加上stdcall参数</p></li><li><p>理解stdcall和cdecl</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_stdcall调用：</span><br><span class="line">是pascal程序的缺省调用方式，参数采用从右到左的压栈方式，被调用函数自身在返回前清空堆栈。win32 api 都采用_stdcall调用方式</span><br><span class="line"></span><br><span class="line">_cdecl调用</span><br><span class="line">_cdecl是c/c++的缺省调用方式，参数采用从右往左的压栈方式，传送参数的内存由调用者维护。_cdecl约定的函数只能被c/c++调用，每一个调用它的函数都包含清空堆栈的代码，所以产生的可执行文件大小回避_stdcall函数大</span><br></pre></td></tr></table></figure><p>3.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">option语句</span><br><span class="line">意义是对大小写是否敏感</span><br><span class="line">由于win32 api函数是分大小写的所以</span><br><span class="line">必须得有这个</span><br></pre></td></tr></table></figure><h2 id="2-段的定义"><a href="#2-段的定义" class="headerlink" title="2.段的定义"></a>2.段的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">模式定义</span><br><span class="line">&lt;一些include语句&gt;</span><br><span class="line">.stack[堆栈段的大小]</span><br><span class="line">.data</span><br><span class="line">&lt;一些初始化过的变量定义&gt;</span><br><span class="line">.data?</span><br><span class="line">&lt;一些没有初始化过的变量的定义&gt;</span><br><span class="line">.const</span><br><span class="line">&lt;常量的定义&gt;</span><br><span class="line">.code</span><br><span class="line">&lt;代码&gt;</span><br><span class="line">&lt;开始标号&gt;</span><br><span class="line">&lt;其他语句&gt;</span><br><span class="line">end 开始标号</span><br></pre></td></tr></table></figure><ul><li>win32汇编源程序中“分段”的概念实际上是把不同类型的数据或代码归类，在放到不同属性的内存页（耶就是不同的“分段”）中，这中间不涉及使用不同的段寄存器【仅仅是配合分页机制罢了】</li></ul><p>1.数据段</p><ul><li>.data .data？ .const定义的是数据段，分别对应不同方式放在不同的区域</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">是可读可写的数据,定义好的变量</span><br><span class="line">int a=1;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data?</span><br><span class="line">可读可写的数据，未定义变量</span><br><span class="line">有空间，但是没有初始化罢了</span><br><span class="line">int a;</span><br><span class="line">定义在data?段中不会增加.exe文件的大小</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.const</span><br><span class="line">只能读的数据，不能写，只要写了就会报错</span><br></pre></td></tr></table></figure><p>2.代码段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.code段就是代码段，直接操控CPU咯</span><br><span class="line">但是！我们是在等级3下运行程序，所以对于code段是不能写的，不能修改code段中的东西</span><br><span class="line">在优先级为3下运行的程序耶不是一定不能写代码段，代码段的属性是由可执行文件PE头部中的属性位所决定的</span><br><span class="line">通过编译磁盘上的.exe文件 ，把代码段的属性位改成可写的，那么就可以修改自己的代码段了</span><br></pre></td></tr></table></figure><ul><li><p>一个典型的引用就是针对可执行文件的压缩软件和加壳软件【UPX和PoCompact……】</p></li><li><p>这些软件靠把代码进行变换来达到解压缩和解密的目的，被处理过的可执行文件在执行的时候需要由解压代码来讲代码段解压缩</p></li><li><p>这就需要写代码段咯</p></li></ul><h2 id="3-程序结束和程序入口"><a href="#3-程序结束和程序入口" class="headerlink" title="3.程序结束和程序入口"></a>3.程序结束和程序入口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">end start</span><br><span class="line">这个在一个程序里面的话，就需要写这个，来指明结束和入口地址</span><br><span class="line">但是：</span><br><span class="line">如果有多个模块，需要把这些模块都链接在一起的时候，就只能有一个主模块指定入口地址，不然入口太多会爆炸</span><br></pre></td></tr></table></figure><h2 id="4-注释"><a href="#4-注释" class="headerlink" title="4.注释"></a>4.注释</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用 ;</span><br><span class="line">在字符串里面的 ; 不是注释</span><br></pre></td></tr></table></figure><h2 id="5-换行"><a href="#5-换行" class="headerlink" title="5.换行"></a>5.换行</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用 (\) 做换行符</span><br><span class="line">能提高阅读性罢了</span><br></pre></td></tr></table></figure><h1 id="调用API函数"><a href="#调用API函数" class="headerlink" title="调用API函数"></a>调用API函数</h1><h2 id="1-首先，说明是API？"><a href="#1-首先，说明是API？" class="headerlink" title="1.首先，说明是API？"></a>1.首先，说明是API？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">应用函数接口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">win32程序是架构在win32api基础上的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">windows自身的运行也调用这个api函数</span><br></pre></td></tr></table></figure><h2 id="2-调用API函数"><a href="#2-调用API函数" class="headerlink" title="2.调用API函数"></a>2.调用API函数</h2><ul><li><p>api函数，它实际上就是一种新的方法代替了DOS下的中断</p></li><li><p>DLL【动态链接库文件】是一种windows的可执行文件，采用的是和我们熟悉.exe文件同样的PE约定格式</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">依靠dll文件，程序才能和内核联系</span><br></pre></td></tr></table></figure><h3 id="1-）关于dll"><a href="#1-）关于dll" class="headerlink" title="1.）关于dll"></a>1.）关于dll</h3><ul><li>dll实质上是一个打打的集装箱，装着各种系统的API函数，应用程序在使用的时候由windows自动载入dll程序并且调用相应的函数</li><li>实在上，win32的基础就是由dll组成的。win32api的核心由3哥dll提供</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.kernel32.dll -- 系统服务功能。包含内存管理，任务管理和动态链接</span><br><span class="line">2.gdi32.dll -- 图形设备接口，处理图形绘制</span><br><span class="line">3.user32.dll -- 用户接口服务，建立窗口和传送消息</span><br></pre></td></tr></table></figure><ul><li><p>win32api还包含起来的很多的函数，都是由dll提供</p></li><li><p>比如：TCP/IP协议进行网络通信的dll是wsock32.dll。。。等</p></li><li><p>所有的DLL提供的函数组成了现在使用的win32编程环境</p></li></ul><h3 id="2-）api函数的参数"><a href="#2-）api函数的参数" class="headerlink" title="2.）api函数的参数"></a>2.）api函数的参数</h3><ul><li><p>win32api是用堆栈来传递函数的，dll中的函数程序从堆栈中取出参数进行处理，并且在返回之前讲堆栈中已经无用的参数丢去【从右边往左压入栈中 】</p></li><li><p>参数，参数名字很多，但就只是用于定义这个参数的大小，而不是一定要怎样怎样，参数的名字只是用来描述这个参数的作用罢了，实质上是开辟一个空间的大小</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int MessageBox(</span><br><span class="line">HWND hWnd,//handle to ouner window</span><br><span class="line">LPCTSTR lp Text,//text in message box</span><br><span class="line">LPCTSTR lpCaption,//message box title</span><br><span class="line">UINT uType,//message box style</span><br><span class="line">    </span><br><span class="line">)//这个是c语言来表示的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto hWnd:dword,ip Text:dword,ipCaption:dword,uType:dword</span><br><span class="line">//这样是用汇编的格式来表达</span><br></pre></td></tr></table></figure><ul><li>在汇编中调用MessageBox函数的方法</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push uType</span><br><span class="line">push lpCaption</span><br><span class="line">push lpText</span><br><span class="line">push hWnd</span><br><span class="line">call MessageBox</span><br></pre></td></tr></table></figure><ul><li>在源程序编译链接成可执行文件后，call MessageBox语句中的MessageBox会被换成一个地址，指向可执行文件中的导入表的一个索引【函数名或者索引号】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">导入表：程序会在导入表中写入【将要调用xxx函数】，然后里面就会存放着来自导出表中的函数的地址。。里面会动态的存放着这些将被调用的函数的地址</span><br><span class="line"></span><br><span class="line">导出表：就是动态链接库里面所有函数的一一对应的地址，在加载的时候就会把这些地址【将要用到的】给导入表。</span><br></pre></td></tr></table></figure><h3 id="3-）使用invoke语句"><a href="#3-）使用invoke语句" class="headerlink" title="3.）使用invoke语句"></a>3.）使用invoke语句</h3><ul><li>invoke伪指令【相当于call指令，多了参数个数检查的功能】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invoke 参数名字[,参数1][,参数2]...[,参数n]</span><br></pre></td></tr></table></figure><p>它能对参数个数进行检查，看是否合格</p><p>对于不带参数的api调用，invoke或者call都可以</p><h3 id="4-）api函数的返回值"><a href="#4-）api函数的返回值" class="headerlink" title="4.）api函数的返回值"></a>4.）api函数的返回值</h3><ul><li>返回值各种各样，但是在汇编程序中，只有dword这一种类型，它永远放在eax中</li><li>如果返回的东西比较大，放不下，就会返回一个指针。把数据放在缓冲区中【指针指向这里】</li></ul><h3 id="5-）函数的声明"><a href="#5-）函数的声明" class="headerlink" title="5.）函数的声明"></a>5.）函数的声明</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">函数名 proto [距离][语言][参数1]:数据类型,[参数2]:数据类型</span><br></pre></td></tr></table></figure><ul><li>句中的proto是函数声明的伪指令。</li><li> 距离–种类很多【near far near16….】，但是在win32中不管【因为平坦的段】</li><li>语言–忽略就使用   .model定义的值</li></ul><p>对于汇编来说，只关心参数的数量，名字只是为了好看，所以可以略去</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto hWnd:dword,lpText:dowrd,\</span><br><span class="line">lpCaption:dword,uType:dword</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MessageBox Proto :dword,:dword,:dword,:dword</span><br></pre></td></tr></table></figure><ul><li>上面这2种是一样的</li></ul><h3 id="6-）include语句"><a href="#6-）include语句" class="headerlink" title="6.）include语句"></a>6.）include语句</h3><ul><li><p>用include来声明某些函数</p></li><li><p>.inc 文件</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">include &lt;文件名&gt;</span><br><span class="line">include 文件名</span><br><span class="line">都可以</span><br></pre></td></tr></table></figure><h3 id="7-）includelib语句"><a href="#7-）includelib语句" class="headerlink" title="7.）includelib语句"></a>7.）includelib语句</h3><ul><li><p>在win32汇编种使用api函数，程序必须知道调用的api函数存放在那个dll中，需要有一个文件包括dll库正确的定位信息，这个任务是由导入库来实现的。</p></li><li><p>在使用外部函数的时候，DOS下有函数库的概念，那时的函数库实际上是静态库，静态库是一组已经编写号的代码模块，在程序中可以自由引用</p></li><li><p>最后用link 从库中找出相应的函数代码，一起链接到最后的可执行文件中</p></li><li><p>Win32环境中，程序连接的时候任然要使用函数库定位函数信息，只不过由于函数代码放在dll文件中，库文件中留有函数的定位信息和参数数码等简单信息，这种库文件叫做导入库</p></li><li><p>一个dll文件对应一个导入库，比如：user32.dll文件用于编程的导入库是user32.lib，masm32互具包中包含了所有dll的导入库</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">includelib 库文件名</span><br><span class="line">includelib &lt;库文件名&gt;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230421190312235.png" alt="image-20230421190312235"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">咋说呢，我理解的是，函数是存在.dll中</span><br><span class="line">然后我们导入的是.lib，这个里面存放的是.dll的地址信息啥的 </span><br></pre></td></tr></table></figure><h2 id="3-API参数中的等值定义"><a href="#3-API参数中的等值定义" class="headerlink" title="3.API参数中的等值定义"></a>3.API参数中的等值定义</h2><p>这里看书去吧【忘了写笔记】，p62</p><p> 在masm下，我们可以用.if .elseif .else </p><h1 id="标号，变量，数据结构"><a href="#标号，变量，数据结构" class="headerlink" title="标号，变量，数据结构"></a>标号，变量，数据结构</h1><h2 id="1-标号"><a href="#1-标号" class="headerlink" title="1.标号"></a>1.标号</h2><h3 id="1-）标号的定义"><a href="#1-）标号的定义" class="headerlink" title="1.）标号的定义"></a>1.）标号的定义</h3><ul><li>标号–&gt;地址</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.标号名:目的指令</span><br><span class="line">2.标号名::目的指令</span><br></pre></td></tr></table></figure><ul><li>1.只能在某一个子程序中跳</li><li>2.可以从一个子程序跳到其他子程序中，不和谐</li></ul><h3 id="2-）MASM中的"><a href="#2-）MASM中的" class="headerlink" title="2.）MASM中的@@"></a>2.）MASM中的@@</h3><ul><li>@@用于某些时候标号只会使用1.2次</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,1234h</span><br><span class="line">    cmp flag,1</span><br><span class="line">    jz @f;@f是跳到这个指令后的第一个@@处</span><br><span class="line">    mov cx,1000H</span><br><span class="line">@@:</span><br><span class="line">...</span><br><span class="line">loop @b;@是跳到本指令前的第一个@@的地方</span><br></pre></td></tr></table></figure><ul><li>相当于一个特殊的标号</li></ul><h2 id="2-变量–全局变量"><a href="#2-变量–全局变量" class="headerlink" title="2.变量–全局变量"></a>2.变量–全局变量</h2><h3 id="1-）定义全部变量"><a href="#1-）定义全部变量" class="headerlink" title="1.）定义全部变量"></a>1.）定义全部变量</h3><ul><li>全部变量的作用域是整个程序，可以用data 或者 data? </li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230421204810538.png" alt="image-20230421204810538"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">wHourdw?</span><br><span class="line">wMinutedw10</span><br><span class="line"></span><br><span class="line">变量名变量类型【可以用缩写】值</span><br></pre></td></tr></table></figure><ul><li>在使用byte类型变量的定义中，可以用引号来定义字符串和数值定义的方法混用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">szTextdb&#x27;Hello,world!&#x27;,0dh,0ah,&#x27;hello again&#x27;,0dh,0ah,0</span><br><span class="line">用 ， 隔开</span><br><span class="line">0dh和0ah其实就是回车和换行符</span><br><span class="line">用的是ascii码</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230421205538518.png" alt="image-20230421205538518"></p><h3 id="2-）全局变量的初始化"><a href="#2-）全局变量的初始化" class="headerlink" title="2.）全局变量的初始化"></a>2.）全局变量的初始化</h3><ul><li>在不想初始化的时候，可以用问好来预留空间</li><li>在data?段中只能用?来预留空间</li><li>并且未初始化的值都是 0 </li></ul><h2 id="3-变量–局部变量"><a href="#3-变量–局部变量" class="headerlink" title="3.变量–局部变量"></a>3.变量–局部变量</h2><ul><li><p>也就是用在函数内部的变量</p></li><li><p>作用域是单个子程序</p></li><li><p>这些变量就放在堆栈里面，在进入子程序的时候，通过堆栈指针esp来预留出空间，在使用ret指令返回主程序之前，同样通过恢复esp丢弃这些控件，这些变量就变得无效了</p></li><li><p>由于空间是临时分配的，所以无法定义含有初始化值的变量，对局部变量的初始化一般在子程序中由指令完成。</p></li></ul><h3 id="1-）局部变量的定义"><a href="#1-）局部变量的定义" class="headerlink" title="1.）局部变量的定义"></a>1.）局部变量的定义</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">local 变量名1[[重复数量]][:类型],变量名2[[重复数量]][:类型]...</span><br></pre></td></tr></table></figure><ul><li>local伪指令必须在子程序定义的伪指令 proc 后，其他指令之前。</li><li>不能使用缩写</li><li>默认的类型是dword</li><li>当定义数组的时候，可以用[]括起来</li><li>不能使用dup伪指令</li><li>不能和全局变量同名，但可以和局部变量重名</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localloc1[1024]:byte;定义了一个1024字节长的局部变量loc1</span><br><span class="line">localloc2;定义了名叫loc2的局部变量，类型默认是dword</span><br><span class="line">localloc3:WNDCLASS;定义了一个WNDCLASS数据结构，名loc3</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型：也就是占用空间的大小</span><br></pre></td></tr></table></figure><h3 id="2-）局部变量的使用"><a href="#2-）局部变量的使用" class="headerlink" title="2.）局部变量的使用"></a>2.）局部变量的使用</h3><ul><li>例子</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TestProcproc</span><br><span class="line">local loc1:dword,loc2:word</span><br><span class="line">local loc3:byte</span><br><span class="line"></span><br><span class="line">mov eax,loc1</span><br><span class="line">mov ax,loc2</span><br><span class="line">mov al,loc3</span><br><span class="line">ret</span><br><span class="line">TestProcendp</span><br></pre></td></tr></table></figure><ul><li>上面例子在创建局部变量的时候，真正的汇编语句是这样的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp;把esp中的内容放在了ebp中</span><br><span class="line">add esp,fffffff8;对esp操作</span><br><span class="line"></span><br><span class="line">mov eax,dword ptr [ebp-04];win32没有段寄存器的说法</span><br><span class="line">mov ax,word ptr [ebp-06]</span><br><span class="line">mov al,byte ptr [ebp-07]</span><br><span class="line"></span><br><span class="line">leave</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><ul><li>这些指令是必须的，前面的用于局部变量的准备工作，后面的用于扫尾工作</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp,esp</span><br></pre></td></tr></table></figure><ul><li>把ebp中的内容保存在栈里 面，然后把esp的内容给ebp，供存取局部变量做指针</li><li>在这个例子中一共是7个字节的大小来保存局部变量，所以esp这个指针要往下移动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里就是 add esp,fffffff8</span><br></pre></td></tr></table></figure><ul><li>为什么是腾出8个字节的空间呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为80386按照dword为界对其，运行速度最快。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在子程序中，该esp 而不该 ebp？</span><br></pre></td></tr></table></figure><ul><li>leave指令的功能</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov esp,ebp;在里面使用esp ， 原先的esp是放在ebp中的，最后把内容返回给它</span><br><span class="line">pop epb;在把ebp弹回去</span><br></pre></td></tr></table></figure><h3 id="3-）局部变量的初始化值"><a href="#3-）局部变量的初始化值" class="headerlink" title="3.）局部变量的初始化值"></a>3.）局部变量的初始化值</h3><ul><li><p>局部变量不初始化，得到的是一个奇奇怪怪的值【也就是指针指向的自带的值，之前的】</p></li><li><p>解决这个问题，就先全部都初始化为0</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RtlZeroMemory 这个API函数就可以做到该功能</span><br></pre></td></tr></table></figure><h2 id="4-变量的使用"><a href="#4-变量的使用" class="headerlink" title="4.变量的使用"></a>4.变量的使用</h2><h3 id="1-）以不同的类型访问变量"><a href="#1-）以不同的类型访问变量" class="headerlink" title="1.）以不同的类型访问变量"></a>1.）以不同的类型访问变量</h3><ul><li><p>类似和C语言中的数据类型强制转化</p></li><li><p>但是在masm中，它不会自动帮忙转。</p></li><li><p>在masm中，变量类型不一样的话就会报错</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如:</span><br><span class="line">sz db 1024 dup(?)</span><br><span class="line">mov ax,sz</span><br><span class="line"></span><br><span class="line">这样就会报错</span><br></pre></td></tr></table></figure><ul><li>所以需要使用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类型 ptr 变量名</span><br></pre></td></tr></table></figure><ul><li>这样就可以把变量转化成你所想要的类型</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,word ptr sz</span><br></pre></td></tr></table></figure><ul><li>要注意的是，在变量报错的时候，是高放高，低放低</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">adb12h</span><br><span class="line">bdw1234h</span><br><span class="line">cdd12345678h</span><br><span class="line">在这样的在内存中保存的是</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 34 12 78 56 34 12</span><br></pre></td></tr></table></figure><ul><li>在使用转换类型的时候，其实它不是转换类型，而是把地址的范围改变了，比如之前的是1个字的，转换成2个字，它的内容就会往后延申罢了</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">肯定还是要遵守 高地址放高  低地址放低</span><br></pre></td></tr></table></figure><ul><li><p>它只是用了变量的地址，所需要的变量的大小是取决于其他的东西</p></li><li><p>2个简单的命令</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.movzx将变量扩展到应该有的大小</span><br><span class="line">这个是直接在高位放0</span><br><span class="line">2.movsx将变量扩展到应该有的大小</span><br><span class="line">这个是带有符号位的扩展</span><br><span class="line">最高位是0，就扩展0//最高位就是符号的标识</span><br><span class="line">最高位是1，就扩展1</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230422175319183.png" alt="image-20230422175319183"></p><h3 id="2-）变量的尺寸和数量"><a href="#2-）变量的尺寸和数量" class="headerlink" title="2.）变量的尺寸和数量"></a>2.）变量的尺寸和数量</h3><ul><li>首先是2个伪指令</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.sizeof</span><br><span class="line">对于变量名，数据结构，数据结构名</span><br><span class="line">2.lengthof</span><br><span class="line">对于变量名</span><br></pre></td></tr></table></figure><ul><li>1.sizeof去识别某变量的长度</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">szdd1,2,3,4</span><br><span class="line"></span><br><span class="line">sizeof sz</span><br></pre></td></tr></table></figure><ul><li>这样的话，长度就是16【4*4】</li><li>在使用sizeof的时候只是去识别该变量的长度，在masm编译器中，变量的定义就是一行</li><li>所以有：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">szdb&#x27;hello&#x27;,0dh,0ah;0dh和0ah其实就是换行</span><br><span class="line">db&#x27;word&#x27;,0</span><br><span class="line"></span><br><span class="line">sizeof sz</span><br></pre></td></tr></table></figure><ul><li>这样去识别的时候，sz的长度就是7，而不是13，但是在用函数MessageBox的函数的时候，会显示出所有，因为字符串的结束是按照0所结束的。在没有识别到0的时候，就会继续识别【在地址中存放的时候，他是挨着向下存放的】</li><li>**所以在识别字符串的长度的时候，应该使用lstrlen函数去计算</li></ul><h3 id="3-）获取变量地址"><a href="#3-）获取变量地址" class="headerlink" title="3.）获取变量地址"></a>3.）获取变量地址</h3><ul><li>相当于获取指针咯</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov 寄存器,offset 变量名</span><br></pre></td></tr></table></figure><ul><li>1.这个offset就是取地址的伪操作符。【只能用于全局变量，不能用于局部变量】</li><li>为什么呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这个地方就要讲究一个先后顺序的操作了，伪指令是在编译器的时候进行，但是指令是在CPU来操作。</span><br><span class="line">局部变量，在编译的时候无从得知它的地址，所以不能用咯</span><br></pre></td></tr></table></figure><ul><li>2.所以在获取局部变量的地址的时候，就需要用到    lea    指令【该指令是CPU指令】</li><li>对于局部变量，它是用ebp来做指针进行操作的</li><li>lea的原理：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在使用lea的时候，按照ebp的值实际计算出来，然后放在eax中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">就比如：leaeax,[ebp-4]</span><br><span class="line">这样就能获取一个局部变量的地址</span><br></pre></td></tr></table></figure><ul><li><p>3.在invoke伪指令获取参数的时候，就也不能用lea了….【这个invoke 相当于有参数的call】</p></li><li><p>哦豁，这下怎么办呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">卧槽，肯定有办法啊。</span><br><span class="line">这个时候就是用addr 伪指令</span><br></pre></td></tr></table></figure><ul><li>注意：在使用addr的时候，只能在invoke下使用！！</li><li>addr的原理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当addr后面跟的是全局变量的时候，它的作用就和offset的用法一样。</span><br><span class="line">当addr后面跟的是局部变量的时候，它的作用就和lea一样，会把地址这玩意放在eax中</span><br></pre></td></tr></table></figure><ul><li>注意：在使用addr的时候，前面不能有eax进行传参</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比如：invoketext,eax,addr szHello</span><br><span class="line">这样是错误的！！</span><br></pre></td></tr></table></figure><ul><li>对上面的代码进行反汇编</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lea eax,[ebp-4];首先是对addr伪指令进行操作</span><br><span class="line">push eax;这个是放的addr szHello的地址</span><br><span class="line">push eax;这个放的是eax 第一个参数的地址</span><br><span class="line">call test</span><br><span class="line"></span><br><span class="line">这样的话，就会把eax中的值被覆盖掉，就会出现逻辑上的错误。 </span><br></pre></td></tr></table></figure><h1 id="使用子程序"><a href="#使用子程序" class="headerlink" title="使用子程序"></a>使用子程序</h1><ul><li><p>把一段代码封装起来【我咋感觉和函数差不多】</p></li><li><p>过程和函数，过程无返回值，函数有返回值</p></li><li><p>化繁为简，在主程序中用call</p></li><li><p>当然也是要用invoke</p></li></ul><h2 id="1-子程序的定义"><a href="#1-子程序的定义" class="headerlink" title="1.子程序的定义"></a>1.子程序的定义</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">子程序名 proc [距离][语言类型][可视区域][USES寄存器列表][,参数:类型]...[VARARG]</span><br><span class="line">local 局部变量列表</span><br><span class="line"></span><br><span class="line">指令</span><br><span class="line"></span><br><span class="line">子程序名 endp</span><br></pre></td></tr></table></figure><ul><li> 【距离】——有很多种，这里懒得列出来了（P75）win32种肯有无视它</li><li>【语言类型】——也有很多种（P75）忽略就是使用 .model中的值</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示参数的使用方式，和堆栈平衡的方式</span><br></pre></td></tr></table></figure><ul><li>【可视区域】——有PRIVATE,PUBLIC,EXPORT,三种</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PRIVATE：表示子程序只对本模块可见</span><br><span class="line">PUBLIC：表示对所有的模块可见(最后编译完成在.exe文件中)</span><br><span class="line">EXPORT：表示是到处的函数，当编写DLL的时候要将某个函数到处的时候可以这样使用</span><br><span class="line"></span><br><span class="line">默认是用PUBLIC</span><br></pre></td></tr></table></figure><ul><li>【USES寄存器列表】——就是把将用的寄存器push 最后 pop</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不如使用pushad在开头，最后使用popad指令，一次性保存和恢复所有的寄存器</span><br></pre></td></tr></table></figure><ul><li>【参数和类型】——参数指参数的名称，在定义参数名的时候不能和全局变量和局部变量重名。类型不用管，在win32中都是dw</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VARARG：表示在确定的参数后还可以跟多个数量不确定的参数。</span><br><span class="line">在win32中使用VARARG的API只有wsprintf。</span><br><span class="line">类似和printf</span><br></pre></td></tr></table></figure><ul><li><p>在完成定义之后，就可以用invoke来调用子程序咯。</p></li><li><p>在调用子程序的时候，需要首先声明子程序</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 proto 来声明子程序</span><br></pre></td></tr></table></figure><ul><li>也可以 把子程序写在invoke调用之前，就可以省略proto咯</li></ul><h2 id="2-参数传递和堆栈平衡"><a href="#2-参数传递和堆栈平衡" class="headerlink" title="2.参数传递和堆栈平衡"></a>2.参数传递和堆栈平衡</h2><ul><li>咋理解呢？参数的传递是通过栈这个东西传递的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">栈是共用的，相当于是一个内存空间，直接访问那个内存空间就好啦</span><br></pre></td></tr></table></figure><ul><li>堆栈平衡</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说，在进行参数传递的时候，会把参数先放到栈中，这个栈中的内容是现在这个子程序所有的。最后把这个栈的指针重新指回原来的位置，将相当于栈中的内容清空了【其实我理解的是，栈就是一部分内存空间，通过指针来确定这个栈中的内容或者大小，只要指针指回去了，就相当于栈清空了，其实内容是没有被清空的】【在内存空间中，内容只能被覆盖---个人理解罢了】</span><br></pre></td></tr></table></figure><ul><li>比如说：调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SubRouting(Var1,Var2,Var3)</span><br></pre></td></tr></table></figure><ul><li>编译后是：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">push Var3</span><br><span class="line">push Var2</span><br><span class="line">push Var1</span><br><span class="line">call SubRouting</span><br><span class="line">add esp,12;esp就相当于是栈指针【还是我的个人理解，可能会有偏差，但不影响】</span><br></pre></td></tr></table></figure><ul><li>堆栈平衡也就是：调用者首先把参数放入栈中，然后调用子程序，在完成后，把栈的指针还原到原来的位置。</li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230422220257841.png" alt="image-20230422220257841"></p><ul><li>这里有一段源程序【P76】我就不写过来了。</li><li>其实有点模糊，后面遇到了在来深入理解吧。</li></ul><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><ul><li><p>几乎所有的API所涉及的数据结构在windows.inc文件中都有定义</p></li><li><p>偷个懒，直接上图片【哈哈哈】</p></li><li><p>在C语言中</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230422222559450.png" alt="image-20230422222559450"></p><ul><li>在汇编中定义一个数据结构</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">结构名struct</span><br><span class="line">字段名1类型?</span><br><span class="line">字段名2类型?</span><br><span class="line">...</span><br><span class="line">结构名ends</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WNDCLASSEX STRUCT</span><br><span class="line">  cbSize            DWORD      ?</span><br><span class="line">  style             DWORD      ?</span><br><span class="line">  lpfnWndProc       DWORD      ?</span><br><span class="line">  cbClsExtra        DWORD      ?</span><br><span class="line">  cbWndExtra        DWORD      ?</span><br><span class="line">  hInstance         DWORD      ?</span><br><span class="line">  hIcon             DWORD      ?</span><br><span class="line">  hCursor           DWORD      ?</span><br><span class="line">  hbrBackground     DWORD      ?</span><br><span class="line">  lpszMenuName      DWORD      ?</span><br><span class="line">  lpszClassName     DWORD      ?</span><br><span class="line">  hIconSm           DWORD      ?</span><br><span class="line">WNDCLASSEX ENDS</span><br></pre></td></tr></table></figure><ul><li><p>我们要知道的是：数据结构只是一个样板</p></li><li><p>通过这个数据结构这个样板，在数据结构在数据段中定义数据</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data?</span><br><span class="line">stWndClassWNDCLASS&lt;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">stWndClassWNDCLASS&lt;1,2,3,4,5,6,7,8,9,10&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>这样就能定义按照WNDCLASS为结构的变量stWndClass。</li><li>如何调用其中的内容呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">1.用点</span><br><span class="line">mov eax,stWndClass.lpfnWndProc</span><br><span class="line">就是变量.字段==&gt;就相当于调用了3【在这里就是】</span><br><span class="line"></span><br><span class="line">2.用指针来找到地址</span><br><span class="line">mov esi,offset stWndClass</span><br><span class="line">moveax,[esi+WNDCLASS+lpfnWndProc]</span><br><span class="line">//这里要使用WNDCLASS+lpfnWndProc</span><br><span class="line">//相当于就是偏移地址</span><br><span class="line"></span><br><span class="line">3.用assume伪指令把寄存器预定义为结构指针。</span><br><span class="line">mov esi,offset stWndClass</span><br><span class="line">assume esi:ptr WNDCLASS</span><br><span class="line">moveax,[esi].lpfnWndProc</span><br><span class="line">...</span><br><span class="line">assume esi:nothing;当不在使用esi寄存器来做指针的时候，就用这个来取消定义</span><br></pre></td></tr></table></figure><ul><li>哈哈哈傻逼东西，可以嵌套哦</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NEW_WNDCLASSstruct</span><br><span class="line"></span><br><span class="line">dwOptiondword?</span><br><span class="line">oldWndClassWNDCLASS&lt;&gt;</span><br><span class="line"></span><br><span class="line">NEW_WNDCLASSends</span><br></pre></td></tr></table></figure><ul><li><p>这里中间这个部分就是嵌套，tmd。嵌套，可以理解成把这个字段啥的，全部都copy过来</p></li><li><p>假设esi指向了NEW_WNDCLASS，那么要引用oldWndClass里面的某个字段</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">moveax,[esi].oldWndClass.lpfnWndProc</span><br></pre></td></tr></table></figure><h1 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h1><h2 id="1-条件测试语句"><a href="#1-条件测试语句" class="headerlink" title="1.条件测试语句"></a>1.条件测试语句</h2><p>懒得说了</p><h2 id="2-分支语句"><a href="#2-分支语句" class="headerlink" title="2.分支语句"></a>2.分支语句</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.if</span><br><span class="line">.elseif</span><br><span class="line">.else</span><br><span class="line"></span><br><span class="line">.endif;最后需要用这个来表示结束</span><br></pre></td></tr></table></figure><h2 id="3-循环"><a href="#3-循环" class="headerlink" title="3.循环"></a>3.循环</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.while条件测试表达式</span><br><span class="line">    指令</span><br><span class="line">    [.break[.if 退出条件]]</span><br><span class="line">    [.continue]</span><br><span class="line">.endw</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.repeat</span><br><span class="line">指令</span><br><span class="line">[.break[.if退出条件]]</span><br><span class="line">[.continue]</span><br><span class="line">.until条件测试表达式(或.untilcxz[条件测试表达式])</span><br><span class="line"></span><br><span class="line">;这个和do while 一样</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-必读内容（0）</title>
      <link href="/2023/05/02/8086%E6%B1%87%E7%BC%96-0-%E5%BF%85%E8%AF%BB%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/02/8086%E6%B1%87%E7%BC%96-0-%E5%BF%85%E8%AF%BB%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p>该内容是根据</p><p>王爽的《汇编语言》＋小甲鱼的b站视频所自己写的笔记。<br>初学者，可能又会很多不当之处</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-第一个程序(2)</title>
      <link href="/2023/05/02/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%EF%BC%88win32%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B%EF%BC%89/"/>
      <url>/2023/05/02/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-2-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F%EF%BC%88win32%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E7%9A%84%E5%85%A8%E9%83%A8%E8%BF%87%E7%A8%8B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-MASM32-SDK介绍"><a href="#1-MASM32-SDK介绍" class="headerlink" title="1.MASM32 SDK介绍"></a>1.MASM32 SDK介绍</h1><ul><li>目标是用汇编写出专业的大型程序：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.除了编译器，连接器外，还包含了汇编需要用到的各种详尽的头文件和导入库文件，导入库文件取自Visual C++ 的导入库</span><br><span class="line">2.收集来自世界各地Win32汇编爱好者的源程序以及很多详细的列子程序</span><br><span class="line">3.发布者还为他编写了一个简单的IDE环境，包括一个专用的汇编源程序编译器和源程模板生成器</span><br></pre></td></tr></table></figure><ul><li>安装目录说明</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">D:\masm32：IDE环境，内带文本编译程序和模板生成程序</span><br><span class="line">D:\masm32\include：所有的导入库文件</span><br><span class="line">D:\masm32\lib：所有的导入库文件</span><br><span class="line">D:\masm32\bin：可执行文件目录，包括ml.exe，link.exe,rc.exe</span><br><span class="line">D:\masm32\help:帮助文档</span><br><span class="line">D:\masm32\m32lib：一些常用的c子程序的汇编实现源程序，很有价值</span><br><span class="line">还有一些其他奇奇怪怪的好用的【以后再说】</span><br></pre></td></tr></table></figure><ul><li>经过了很久的调试，最终在我的电脑上，如果想用win32汇编需要如下操作【手动操作】</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.在d:\masm32中运行cmd</span><br><span class="line">2.设置环境变量，这里用的是var.bat批处理【运行一下就好了】</span><br><span class="line">3.转到写得有汇编的目录下面【cd sources\test】</span><br><span class="line">4.首先用ml编译一下，【ml /c /coff /Cp *.asm】</span><br><span class="line">5.然后用link链接【link /subsystem:windows *.obj ...】</span><br><span class="line">6.就有exe文件啦</span><br></pre></td></tr></table></figure><ul><li>使用nmake ，快捷方式，首先在asm 的目录下创建一个 Makefile,内容如下。然后直接在cmd中运行 cmd</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">EXE = Test.exe#指定输出文件</span><br><span class="line">OBJS = Test.obj#需要的目标文件</span><br><span class="line">RES = Test.res#需要的资源文件</span><br><span class="line"></span><br><span class="line">LINK_FLAG = /subsystem:windows#连接选项</span><br><span class="line">ML_FLAG = /c /coff#编译选项</span><br><span class="line"></span><br><span class="line">$(EXE): $(OBJS) $(RES)</span><br><span class="line">Link $(LINK_FLAG) $(OBJS) $(RES)</span><br><span class="line"></span><br><span class="line">.asm.obj:</span><br><span class="line">ml $(ML_FLAG) $&lt;</span><br><span class="line">.rc.res:</span><br><span class="line">rc $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">del *.obj</span><br><span class="line">del *.res</span><br></pre></td></tr></table></figure><ul><li>经过修改后：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">EXE = test.exe#指定输出文件</span><br><span class="line">OBJS = test.obj#需要的目标文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LINK_FLAG = /subsystem:windows#连接选项</span><br><span class="line">ML_FLAG = /c /coff#编译选项</span><br><span class="line"></span><br><span class="line">$(EXE): $(OBJS) </span><br><span class="line">Link $(LINK_FLAG) $(OBJS) </span><br><span class="line"></span><br><span class="line">.asm.obj:</span><br><span class="line">ml $(ML_FLAG) $&lt;</span><br></pre></td></tr></table></figure><ul><li>helloword–.asm文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">.386</span><br><span class="line">.model flat,stdcall</span><br><span class="line">option casemap:none</span><br><span class="line"></span><br><span class="line">include windows.inc</span><br><span class="line">include user32.inc</span><br><span class="line">includelib user32.lib</span><br><span class="line">include kernel32.inc</span><br><span class="line">includelib kernel32.lib</span><br><span class="line"></span><br><span class="line">.data</span><br><span class="line">szCaption db &#x27;A MessageBox&#x27;,0</span><br><span class="line">szText db &#x27;Hello,World!&#x27;,0</span><br><span class="line"></span><br><span class="line">.code</span><br><span class="line">start:</span><br><span class="line">invoke MessageBox,NULL,offset szText,\</span><br><span class="line">offset szCaption,MB_OK</span><br><span class="line"></span><br><span class="line">invoke ExitProcess,NULL</span><br><span class="line"></span><br><span class="line">end start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>WIN32程序设计-必须了解的基础知识(1)</title>
      <link href="/2023/05/02/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1-%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/02/win32%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-1-%E5%BF%85%E9%A1%BB%E4%BA%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="大纲"><a href="#大纲" class="headerlink" title="大纲:"></a>大纲:</h1><h2 id="1-80x86处理器的互作模式"><a href="#1-80x86处理器的互作模式" class="headerlink" title="(1)80x86处理器的互作模式"></a>(1)80x86处理器的互作模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-实模式</span><br><span class="line">-保护模式</span><br><span class="line">-虚拟8086模式</span><br></pre></td></tr></table></figure><h2 id="2-Windows的内存管理机制"><a href="#2-Windows的内存管理机制" class="headerlink" title="(2)Windows的内存管理机制"></a>(2)Windows的内存管理机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-Dos操作系统的内存安排情况</span><br><span class="line">-80376的内存寻址机制</span><br><span class="line">-80386的内存分页机制</span><br><span class="line">-windows的内存安排</span><br><span class="line">-从Win32汇编的角度看内存寻址</span><br></pre></td></tr></table></figure><h2 id="3-Windows的特权保护机制"><a href="#3-Windows的特权保护机制" class="headerlink" title="(3)Windows的特权保护机制"></a>(3)Windows的特权保护机制</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-80386的中断和异常</span><br><span class="line">-80386的保护机制</span><br><span class="line">-Windows的保护机制</span><br></pre></td></tr></table></figure><h1 id="80x86处理器的互作模式"><a href="#80x86处理器的互作模式" class="headerlink" title="80x86处理器的互作模式"></a>80x86处理器的互作模式</h1><ul><li>80386以后的处理器有3种互作模式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-实模式</span><br><span class="line">-保护模式</span><br><span class="line">-虚拟8086模式</span><br></pre></td></tr></table></figure><ul><li>其实,实模式和虚拟8086模式都是为了向下兼容而设置的,保护模式才是我们的主角,是我们现代系统实际上的互作模式</li><li>只有在保护模式下,32位CPU的寻址才能达到4GB的地址空间,同时,也能实现多任务,内存分页管理和优先级保护等先进的机制</li></ul><h2 id="补-Windows-7的启动过程"><a href="#补-Windows-7的启动过程" class="headerlink" title="补:Windows 7的启动过程"></a>补:Windows 7的启动过程</h2><p>1.开启电源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">计算机系统将进行加电自检[POST].如果通过之后BIOS会读取主引导记录[MBR]---被标记位启动设备的硬盘的首扇区,并传送被Windows 7 建立的控制编码给MBR</span><br></pre></td></tr></table></figure><ul><li>引导型病毒</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x27;鬼影病毒&#x27;</span><br><span class="line">通过修改MBR,将病毒放在系统加载之前加载</span><br></pre></td></tr></table></figure><ul><li>MBR</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">是一个存储区,位于硬盘的第一个扇区.</span><br><span class="line">存放的是:系统的加载信息,各个分区的信息,以及它们的偏移地址,以及各个分区的状态</span><br><span class="line"></span><br><span class="line">它不属于任何一个操作系统,也不能用操作系统提供的磁盘操作命令来读取它.但是我们可以用ROM-BIOS提供的INT 13H中断的2号功能来读出改扇区的内容</span><br></pre></td></tr></table></figure><ul><li>注意:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">硬盘的0磁通的第一个扇区称为MBR,它的大小是512字节,而这个区域可以分为2个部分.第一个部分是pre-boot[预启动区],占446字节,第二个部分是Partition table区[分区表],占64个字节,该区相当于一个小程序,作用是判断哪个分区被标记为活动分区,然后去读取那个分区的启动区,并运行该分区中的代码.</span><br><span class="line">64个字节=16*4.只有4个主分区</span><br><span class="line">最后是一个55AA占2个字节的结束</span><br></pre></td></tr></table></figure><p>2.启动菜单生成</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows启动管理器读取&quot;启动配置数据存储[Boot Confi guration Data store]&quot;中的信息.此信息包含已被安装在计算机上的所有操作系统的配置信息,并且用以生成启动菜单</span><br></pre></td></tr></table></figure><p>当你启动菜单中选择下列动作的时候</p><ul><li>如果你选择的是:Windows 7</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Windows启动管理器[Windows Boot Manager]运的行%SystemRoot%\System32文件夹中的OS loader---Winload.exe</span><br></pre></td></tr></table></figure><ul><li>如果你选择的是:自休眠状态恢复Windows 7</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">那么启动管理器将装载Winresume.exe并恢复您先前的使用环境</span><br></pre></td></tr></table></figure><ul><li>如果你选择的是:早期Windows版本</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">启动管理器将定位系统安装所在的卷,并且加载Windows NT风格的早期OS loader(Ntldr.exe)---生成一个由boot.ini内容决定的启动菜单</span><br></pre></td></tr></table></figure><p>3.核心文件加载和登录</p><ul><li>windows7启动时,加载其核心文件Ntoskrnl.exe和hal.dll—从注册表中读取设置并加载驱动程序</li><li>接下来将运行Windows会话管理器(smss.exe)并且启动Windows启动程序(Wininit.exe)本地安全验证(Lsass.exe)和服务(services.exe)进程,完成后就可以登录系统了</li></ul><h2 id="1-实模式"><a href="#1-实模式" class="headerlink" title="1.实模式"></a>1.实模式</h2><ul><li><p>处理器被复位或者加电的时候以实模式启动</p></li><li><p>这时候处理器中各寄存器以实模式的初始化值互作</p></li><li><p>80386处理器在实模式下的存储器寻址方式和8086是一样的,由段寄存器的内容乘以16当作基地址,加上段内的偏移地址形成最终的物理地址,这时候它的32位地址只用了低20位</p></li><li><p>在实模式下,80386处理器不能对内存进行分页管理,所以指令寻址的地址就是内存中实际的物理地址,在实模式下,所有的段都是可以读.写和执行的</p></li><li><p>实模式下80386不支持优先级,所有的指令相当于互作在特权级,所以它可以执行所有特权指令,包括读写控制寄存器CR0等</p></li><li><p>实际上,80386就是通过在实模式下初始化控制寄存器,GDTR . LDTR . IDTR和TR等管理寄存器以及页表,然后再通过加载CR0使其中的保护模式使能位置位而进入保护模式的。当然实模式下不支持硬件上的多任务切换</p></li><li><p>实模式下的中断处理方式和8086处理器相同，也用中断向量表来定位中断服务程序地址</p></li><li><p>中断向量表的结构也和8086处理器一样：每4个字节组成一个中断向量，其中包括2个字节的段地址和2个字节的偏移地址</p></li><li><p>从编程的角度看，除了可以访问80386新增的一些寄存器外，实模式的80386处理器和8086有什么进步呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">最大的好处是可以使用80386的32位寄存器，用32位寄存器进行编程可以使计算机更加快速</span><br></pre></td></tr></table></figure><ul><li>80386中增加的两个辅助段寄存器FS和GS再实模式下也可以使用，这样，同时可以访问的段到达了6个而不必考虑从小装入的问题；最后，很多80386的新增指令也使一些原来不方便的操作得以简化</li></ul><h2 id="2-保护模式"><a href="#2-保护模式" class="headerlink" title="2.保护模式"></a>2.保护模式</h2><ul><li>当80386互作再保护模式下的时候，它的所有功能都是可用的，这个时候80386所有的32根地址线都可供寻址，物理寻址空间高达4GB</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这个时候就不需要和8086一样有什么段地址什么偏移地址了，直接偏移地址就能索引到4GB的空间</span><br></pre></td></tr></table></figure><ul><li><p>再保护模式下，支持内存分页机制，提供了对虚拟内存的良好支持。虽然和8086可寻址的1MB物理地址空间相比，80386可寻址的物理地址很大，但实际的微机系统不可能安装如此大的物理内存。【这是在以前】所以，为了运行大型程序和真正实现多任务，虚拟内存【再硬盘上开辟一段空间，来当内存使用】是一种必要的技术</p></li><li><p>保护模式下80386支持多任务，可以依靠硬件仅再一条指令中实现任务切换。任务环境的保护互作是由处理器自动完成的</p></li><li><p>再保护模式下，80386处理器还支持优先级机制，不同的程序可以运行再不同的优先级上</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">优先级一共分为0~3一共4个级别，操作系统运行再最高的优先级0上，应用程序则运行再比较低的级别上</span><br></pre></td></tr></table></figure><ul><li>配合良好的检查机制后，既可以再任务间实现数据的安全共享也可以很好地隔离各个任务。从实模式切换到保护模式是通过修改控制寄存器CR0的控制位PE（位0）来实现的。再这之间还需要建立保护模式必须的一些数据表，如全局描述符表GDT和中断描述符表IDT等</li><li>ODS操作系统运行再实模式下，而Windows操作系统运行于保护模式下</li></ul><h2 id="3-虚拟8086模式"><a href="#3-虚拟8086模式" class="headerlink" title="3.虚拟8086模式"></a>3.虚拟8086模式</h2><ul><li><p>虽说实模式兼容以前的系统，但是设想一下，如果Windows或80386处理器推出的时候，不能运行MS-DOS程序，那么就等于放弃了一个巨大的软件库，，，这是不可能的</p></li><li><p>由于这种特殊需求的普遍性，虚拟8086就来啦</p></li><li><p>虚拟86模式是以任务形式再保护模式上执行的，再80386上可以同时支持由多个真正的80386任务和虚拟86模式构成的任务</p></li><li><p>再虚拟86模式下，80386支持任务切换和内存分页，再Windows 操作系统中，有一部分程序专门用来管理虚拟86模式的任务，称为虚拟86管理程序</p></li><li><p>既然虚拟86模式以保护模式位基础，它的互作方式实际上是实模式和保护模式的混合</p></li><li><p>为了和8086程序的寻址方式兼容，虚拟86模式采用和8086一样的寻址方式</p></li><li><p>但显然多个虚拟86模式不能同时使用同一位置的1MB地址空间，否则会有冲突。操作系统利用分页机制将不同虚拟86任务的地址空间映射到不同的物理地址上去，这样每个虚拟86任务看起来都任务自己在使用0~1MB的地址空间</p></li><li><p>8086代码中有相当一部分再保护模式下属于特权指令，如屏蔽中断的cli和中断返回指令iret等</p></li><li><p>这些指令再8086程序中是合法的。如果不让这些指令执行，8086代码就无法互作。为了解决这个问题，虚拟86管理程序采用模拟的方法来完成这些指令</p></li><li><p>虚拟86管理程序再异常处理程序中检查产生异常的指令，如果是中断指令，则从虚拟86任务的中断向量表中取出中断处理程序的入口地址，并将控制转移过去</p></li><li><p>如果是危机操作系统的指令，比如cli等，则简单地忽略这些指令，再异常处理程序返回的时候直接返回到下一条指令</p></li><li><p>通过这些措施，8086程序既可以正常的运行下去，再执行这些指令的时候又觉察不到已经被虚拟86管理程序做了手脚。MS-DOS应用程序再Windows操作系统中就是这样互作的</p></li></ul><h1 id="Windows的内存管理机制"><a href="#Windows的内存管理机制" class="headerlink" title="Windows的内存管理机制"></a>Windows的内存管理机制</h1><ul><li>在这一节中，我们需要通过学习解决两大疑问：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.win32汇编中，每个程序都可以用4GB的内存吗？</span><br><span class="line">2.Win32汇编源代码中为什么看不到CS,DS,ES和SS等段寄存器</span><br></pre></td></tr></table></figure><ul><li>DOS操作系统的内存安排</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Win32编程相对于DOS编程最大的区别之一就是内存的使用问题</span><br></pre></td></tr></table></figure><h2 id="1-DOS操作系统的内存安排"><a href="#1-DOS操作系统的内存安排" class="headerlink" title="1.DOS操作系统的内存安排"></a>1.DOS操作系统的内存安排</h2><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230418203047497.png" alt="image-20230418203047497"></p><ul><li><p>我们看到，由于8086处理器的寻址范围只有可怜的1MB大小，当时系统硬件使用的存储器地址被安排在高端</p></li><li><p>地址是从A0000H（即640KB）开始的384KB中，其中有用于显示的视频缓冲区和BIOS的地址空间</p></li><li><p>而在内存低端，安排了中断向量表和BIOS数据区；剩下从500h开始到A0000H总共不到640KB的内存是操作系统和应用程序所能够使用的；应用程序不可能使用这640KB以外的内存。这就是著名的“640KB限制”</p></li><li><p>而即使在这640KB中，DOS操作系统又占领了低端的一部分内存，最后剩下600KB左右的内存才是应用程序真正可以用的</p></li><li><p>如果系统中有内存驻留程序存在，那么应用程序还要和这些TSR程序共同分享这段内存空间</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TSR:[Terminate and Stay Resident]指：内存驻留程序</span><br><span class="line">占着茅坑不拉屎的程序</span><br></pre></td></tr></table></figure><h2 id="2-80386的内存寻址机制"><a href="#2-80386的内存寻址机制" class="headerlink" title="2.80386的内存寻址机制"></a>2.80386的内存寻址机制</h2><ul><li>Windows的内存管理和DOS的内存管理有很大的不同，在了解Windows的内存管理模式之前，需要对80386保护模式下内存分页机制有所了解</li><li>为了做个对比，先来看实模式下的内存寻址方式：在实模式下，一个完整的地址由段地址和偏移地址俩部分组成【因为在实模式下和8086一样】</li><li>现在我们谈回到80386处理器的互作模式：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当80386处理器互作在保护模式和虚拟8086模式的时候，可以使用全部32根地址访问4GB大的内存。段地址加偏移地址的计算方法显然无法覆盖这么大的范围</span><br><span class="line">2.但计算一下就可以发现，实在上和8086同样的限制以及不复存在，因为80386所有的通用寄存器都是32位的，2^32==4G，所以任何一个通用寄存器来间接寻址，不必分段就已经可以访问到所有的内存地址</span><br></pre></td></tr></table></figure><ul><li>这是不是说，在保护模式下，段寄存器就不在有用了呢？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.错！实际上，段寄存器就更有用了，虽然在寻址上不在有分段的限制问题，但是在保护模式下，一个地址空间是否可以被写入，可以被多久优先级的代码写入。</span><br><span class="line">2.要解决这些问题，必须对一个地址空间定义一个安全上的属性。段寄存器这个时候就排上用场了，不妨将这些属性就放在段寄存器中</span><br></pre></td></tr></table></figure><ul><li><p>但是问题来了，涉及的属性和保护模式下的段的其他参数，要表示的信息需要用64位的数据才能表示。我们把64位的属性叫做段描述（Segment Descriptor）</p></li><li><p>但是！！80386的段寄存器任然是16位的，怎么办？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把所有段的段描述符顺序放在内存中的指定位置，组成一个段描述符表</span><br></pre></td></tr></table></figure><ul><li><p>而段寄存器中的16位用来做索引信息，指定这个段的属性用段描述符表中的第几个描述符来表示</p></li><li><p>这时，段寄存器中的信息不在是段地址了，而是段选择器（segment selector）。可以通过它在段描述符表中“选择”一个项目以得到段的全部信息</p></li><li><p>段描述符表放在哪里呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">80386中引入了2个全新的寄存器来管理描述符表</span><br><span class="line">一个是48位的全局描述符表寄存器GDTR</span><br><span class="line">一个是16位的局部描述符表寄存器LDTR </span><br><span class="line">这俩个寄存器是用来管理描述符表的，不是描述符表！！</span><br></pre></td></tr></table></figure><ul><li><p>GDTR指向的描述符为全局描述符表GDT【Global Descriptor Table】它包含系统中所有任务都可用的段描述符，通常包含描述操作系统所使用的代码段，数据段和堆栈段和描述符及各任务的LDT段等；全局描述符表只有一个【也可以把这里理解成共有的属性】</p></li><li><p>LDTR则指向局部描述符表LDT（Local Descriptor Table）80386处理器设计成每个任务都有一个独立的LDT。它包含有每个任务私有的代码段，数据段，堆栈段的描述符，也包含该任务所使用的一些门描述符，比如：任务门和调用门描述符【这个和中断差差不多】</p></li><li><p>不同任务的局部描述符表分别组成不同的内存段，描述这些内存段的描述符当作系统描述符放在全局描述符表中</p></li><li><p>和GDTR直接指向内存地址不同，LDTR和CS,DS等段选择器一样只放在索引值，指向局部描述符表内存段对应的描述符在全局描述符表中的位置</p></li><li><p>随着任务的切换，只要改变LDTR的值，系统当前的局部描述符表LDT也随之切换，这样便于各任务之间数据的隔离，但GDT并不会随着任务的切换而切换</p></li><li><p>既然有全局描述符表和局部描述符表，那么段选择器【也就是段寄存器】中的索引值对应那个表中的描述符呢？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.实际上，16位的段选择器只有高13位表示索引值</span><br><span class="line">2.剩下的3个数据位中，第0，1位标识程序的当前优先级RPL；第二位TI位用来表示在段描述符的位置；TI=0表示在GDT中;TI=1表示在LDT中</span><br></pre></td></tr></table></figure><ul><li>图说寻址路线：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在保护模式下，同样在xxxx:yyyyyyyy格式表示一个虚拟地址</span><br><span class="line">2.注意：xxxx(16位，相当于8086时代的段地址)保存在段寄存器,yyyyyyyy(32位，相当于8086时代的偏移地址)保存在通用寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230418231035003.png" alt="image-20230418231035003"></p><h2 id="3-80386的内存分页机制"><a href="#3-80386的内存分页机制" class="headerlink" title="3.80386的内存分页机制"></a>3.80386的内存分页机制</h2><ul><li>在 实模式下寻址的时候，”段寄存器+偏移地址“经过转换计算后得到的地址是”物理地址“，也就是在物理内存中的实际地址</li><li>而在保护模式下，”段选择器+偏移地址“转化后的地址被称为”线性地址“而不是”物理地址“。那么线性地址就是物理地址吗？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">很显然，名字都不一样，肯定不一样啦</span><br><span class="line">这“是”or“不是”取决于80386的内存分页机制是否被使用</span><br></pre></td></tr></table></figure><ul><li>为什么会有内存分页机制？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">就是为了解决下面的不足【内存碎片化】</span><br></pre></td></tr></table></figure><ul><li><p>我们先来回顾一下：在单任务的DOS系统中，一个应用程序可以使用所有的空闲内存，程序退出后，操作系统回收所有的碎片内存并且合并成一个大块内存继续供下一个程序使用【也就是单线程】</p></li><li><p>内存合并过程中的一个极端情况是当系统中有多个TSR程序时，早装入内存的TSR被卸载后，后装入的TSR会留在内存的中间部位，把空闲内存隔离成两个区域</p></li><li><p>这时应用程序使用的最大内存块只能是这两块内存中较大的一块，无法将它们合并使用</p></li><li><p>对于一个多任务的操作系统，内存的碎片化是不行的，否则经过一段时间后，即使空闲内存的总和很大，也可能出现任何一篇内存都小到无法装入执行程序的地步</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TSR差不多就是说，会把内存给隔开，不能连续起来一起使用咯</span><br></pre></td></tr></table></figure><ul><li><p>所以对于多任务操作系统中碎片内存的合并是一个很重要的问题</p></li><li><p>如何解决？</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">80386处理器的分页机制可以很好的解决这个问题，80386处理器把4KB大小的一块内存当作“一页”内存，每页物理内存可以根据“页目录”和“页表”，随意映射到不同的线性地址上</span><br><span class="line"></span><br><span class="line">这样，就可以将物理地址不连续的内存的映射连到一起，在线性地址上视为连续</span><br></pre></td></tr></table></figure><ul><li>在80386处理器中，除了和CR3寄存器（指定当前页目录的地址）相关的指令使用的是物理地址外，其他所有指令都是线性寻址的</li><li>什么是CR3？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CR3用于保存页目录表页面的物理地址，因此被称为PDBR。由于目录是页对齐的，所以仅高20位有效，低12位保留。</span><br><span class="line">向CR3装入一个新值的时候，低12位必须是0，CR3中取值时，低12位被忽略</span><br></pre></td></tr></table></figure><ul><li>为什么是20位？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">因为：在80386CPU中能索引的内存地址是4GB，然后一页是4KB</span><br><span class="line">4GB=4194304KB</span><br><span class="line">4194304KB/4KB=1048576=2^20</span><br><span class="line">所以只需要用到20位啦</span><br></pre></td></tr></table></figure><ul><li>还有是否启用内存分页机制是由80386处理器新增的CR0寄存器中的位31（PG位）决定的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果PG=0,则分页机制不启用，这个时候指令的寻址地址（线性地址）页就是系统中的实际的物理地址</span><br><span class="line"></span><br><span class="line">如果PG=1，则80386分页机制开启，所有的线性地址要经过页表的映射才得到最后的物理地址</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230418231107344.png" alt="image-20230418231107344"></p><ul><li>一个xxxx:yyyyyyyy格式的虚拟地址，经过段地址转换不走后得到一个32位的线性地址zzzzzzzz（步骤1）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.当禁用分页机制时，线性地址就是物理地址，处理器直接从物理内存存取数据(步骤2)</span><br><span class="line">2.当启用分页机制时，得到线性地址的方法还是一样(步骤1’)但是还要根据页目录和页表指定的映射关系把地址映射到物理内存的真正位置上(步骤3’)</span><br><span class="line">3.然后，CPU以映射后的物理地址在物理内存中存取数据。这个过程是透明的</span><br></pre></td></tr></table></figure><ul><li><p>内存分页管理只能在保护模式下才可以实现，实模式不支持分页机制。但是不管在那种模式下，所有寻址指令使用的都是线性地址，程序不用关系数据最后究竟存放在物理内存的哪个地方</p></li><li><p>页表规定的不仅是地址的映射，同时还规定了页访问属性。如：是否可写，可读和可执行等。比如把代码所在的内存页属性设置位可读和可执行，那么权限不够的代码向他写数据就会发生保护异常。用这个机制可以在硬件层次上直接虚拟内存的实现</p></li><li><p>页表可以指定一个页面并不真正映射到物理内存中。这样，访问这个页的指令会引发页异常错误。这时，处理器会自动转移到页异常处理程序中去</p></li><li><p>操作系统可以在异常处理程序中将硬盘上的虚拟内存读到内存中并修改表重新映射，然后重新执行引发异常的指令</p></li><li><p>这样就可以正常的执行下去</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230418232514773.png" alt="image-20230418232514773"></p><h2 id="4-Windows的内存安排"><a href="#4-Windows的内存安排" class="headerlink" title="4.Windows的内存安排"></a>4.Windows的内存安排</h2><ul><li>这节课有3个概念</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.每个应用程序都有自己的4GB的寻址空间，就算这个程序只占有1KB的内存</span><br><span class="line">2.不同应用程序的线性地址空间是隔离的，尽管他们在内存是搞在一起的</span><br><span class="line">3.时刻要记住,DLL程序是“小三”，因此他们没有自己的私有空间</span><br></pre></td></tr></table></figure><ul><li>虚拟内存安排</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.windows系统一般在硬盘上建立大小为物理内存2倍左右的交换文件用作虚拟内存</span><br><span class="line">2.利用80386处理器的内存分页机制，交换文件的寻址上可以很方便的为物理内存使用【只需要在真正调用的时候将其读入物理内存并同时修改线性地址映射到这块内存即可】</span><br><span class="line">3.同样道理，反正是映射一个地址而已，所以被执行的程序也可以不必装入内存，只需要在页表中建立映射关系，真正运行到这段代码才调入内存</span><br></pre></td></tr></table></figure><ul><li>众所周知，Windows是一个分时的多任务操作系统，CPU时间【就是CPU运行的过程】被分为一个个的时间片后分配给不同程序轮流使用</li><li>在A程序的时间片中，和这个程序执行无关的部分【B和C和其他程序的代码和数据】并不需要映射到线                                                                 性地址中</li><li>附加解析：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.内存中，所有的程序都搞在一起，关系十分混乱</span><br><span class="line">2.CPU只能看到线性地址【假的】，每个程序拥有自己的线性地址【DLL】</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230419143136426.png" alt="image-20230419143136426"></p><h3 id="WIN32编程中几个很重要的概念"><a href="#WIN32编程中几个很重要的概念" class="headerlink" title="WIN32编程中几个很重要的概念"></a>WIN32编程中几个很重要的概念</h3><ul><li>第一个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.每个应用程序都有自己的4GB的寻址空间【假的】</span><br><span class="line">2.该空间可存放操作系统，系统DLL和用戶DLL的代碼，他们之中有各种函数供应用程序调用</span><br><span class="line">3.再出去其他的一些空间，余下的是应用程序的代码，数据和可以分配的地址空间</span><br><span class="line"></span><br><span class="line">DLL动态链接库</span><br></pre></td></tr></table></figure><ul><li>第二个</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.不同应用程序的线性地址空间是隔离的</span><br><span class="line">2.虽然它们在物理内存中同时存在，但是在某个程序所属的时间片中，其他应用程序的代码和数据没有被映射到可寻址的线性地址中，所以是不可访问的</span><br><span class="line">3.从编程的角度看，程序可以使用4GB的寻址空间，而且这个空间是“私有”的</span><br></pre></td></tr></table></figure><ul><li>第三点</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.DLL程序没有自己“私有”的空间</span><br><span class="line">2.它们总是被映射到其他应用程序的地址空间中，当作其他应用程序的一部分运行</span><br><span class="line">3.原因很简单，如果它不和其他程序同属一个地址空间，应用程序就调用不到它</span><br><span class="line"></span><br><span class="line">CPU只能看到这个时间片中的内容，看不到其他</span><br></pre></td></tr></table></figure><h2 id="5-从WIN32汇编的角度看内存寻址"><a href="#5-从WIN32汇编的角度看内存寻址" class="headerlink" title="5.从WIN32汇编的角度看内存寻址"></a>5.从WIN32汇编的角度看内存寻址</h2><ul><li>WIN32汇编中的内存访问远比DOS下的分段寻址方式简单，why？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">because windows是一个多任务的操作系统，最首要的宗旨就是“稳定压倒一切”如果把描述符表以及页表等内容交给用户程序管理是很不安全的</span><br></pre></td></tr></table></figure><ul><li>  任何权限开放引发的安全问题都是很严重的</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如，windows 9x中的中断描述符表是可写的，CIH病毒可利用它将自己的权限提高到优先级0</span><br></pre></td></tr></table></figure><ul><li><p>而windows NT 下的中断描述符表就不能写了哦</p></li><li><p>windows操作系统帮用户“安排好了一切”</p></li><li><p>用户程序的代码段，数据段和堆栈段全部预定义好了段描述符。这些段的起始地址为0，限长ffffffff，所以用它们可以直接寻址全部的4GB地址空间</p></li><li><p>程序在开始执行的时候，CS，DS，ES，SS都已经指向了正确的描述符，在整个程序的生命周期内，程序员不必改动这些段寄存器，也不必关心它们的值是多少【因为想改也改不了】</p></li></ul><h1 id="windows的特权保护"><a href="#windows的特权保护" class="headerlink" title="windows的特权保护"></a>windows的特权保护</h1><ul><li>windows的特权保护和处理器硬件的支持是分布来的</li><li>优先级的划分，指令的权限和超出权限访问的异常处理等是构成特权保护的基础</li><li>有2个问题需要解决</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.win32汇编中为什么找不到中断指令？</span><br><span class="line">2.windows错误的“蓝屏”是从哪里来的？ </span><br></pre></td></tr></table></figure><h2 id="1-80386的中断和异常"><a href="#1-80386的中断和异常" class="headerlink" title="1.80386的中断和异常"></a>1.80386的中断和异常</h2><ul><li>什么是中断？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 中断指当程序执行过程中有更重要的事情需要实时处理的时候【如串口中有数据到达，不及时处理数据会丢失，串行控制器就提交了一个中断信号给处理器要求处理】，硬件通过中断控制器通知处理器</span><br><span class="line">- 接到命令后，处理器暂时挂起当前运行的程序，转移到中断处理程序中</span><br><span class="line">- 当中断处理程序处理完毕后，通过iret指令回到原先被打断的程序中继续执行</span><br></pre></td></tr></table></figure><ul><li>什么是异常？</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 异常指令执行中发生不可忽略的错误的时候【比如遇到无效的指令编码，除法指令除0之类的】处理器用和中断处理相同的操作方法挂起当前运行的程序转移到异常处理程序中</span><br><span class="line">- 异常处理程序决定在修正错误后时候回到原来的地方继续执行</span><br><span class="line">- 中断和异常的处理的方式是一样的，引发方式不同</span><br></pre></td></tr></table></figure><ul><li>实模式下的中断或者异常处理</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.实模式下的中断和异常服务程序地址放在中断向量表中</span><br><span class="line">2.中断向量表位于物理内存中，每个中断向量是一个xxxx:yyyy格式的地址，占用4个字节</span><br><span class="line">3.当发生n号中断或者异常的时候，或者执行到int n指令的时候，CPU首先到内存n*4的地方取出服务程序的地址aaaa:bbbb</span><br><span class="line">4.然后将标志寄存器，中断时的CS IP压入堆栈，然后转移到aaaa:bbbb处执行</span><br></pre></td></tr></table></figure><ul><li><p>保护模式下，中断或异常处理往往从用户代码切换到操作系统代码中执行</p></li><li><p>由于保护模式下的代码分优先级，因此出现了从低到高……</p></li><li><p>为了使高优先级的代码能够安全的被低优先级代码调用，在保护模式下增加了“门”的概念</p></li><li><p>“门”指向某个优先级高的程序所规定的入口点，所有优先级低的程序调用优先级高的程序只能通过门重定向，进入门所规定的入口点</p></li><li><p>这样可以避免低级别的程序代码从任意位置进入优先级高的程序的问题</p></li><li><p>保护模式下的中断和异常等服务程序也要从“门”进入，80386的门分为中断门，自陷门，和任务门</p></li></ul><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230420135910000.png" alt="image-20230420135910000"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/img/image-20230420140206634.png" alt="image-20230420140206634"></p><ul><li><p>在保护模式下把所有的中断描述符放在一起组成‘’中断描述符表IDT“为此80386处理器引入了一个新的48位寄存器IDTR。IDTR的高32位指定了IDT在内存中的基址【线性地址】，低16位指定了IDT的长度，相当于指定了可以支持的中断数量</p></li><li><p>保护模式下发生异常或中断时，处理器先根据IDTR寄存器得到中断描述符的地址，然后取出n号中断/异常的门描述符，再从描述符中得到中断服务程序的地址：xxxx:yyyyyyyy，经过段地址转换后得到服务程序的32位线性地址并转移后执行</p></li><li><p>在windows中，操作系统使用动态链接库来代替中断服务程序提供系统功能，所以在win32汇编中int指令也就失去了存在的意义。这就是在win32汇编代码中看不到int指令的原因。其实那些调用api的指令原本就是用int指令实现的</p></li><li><p>windows会在处理程序中经常系统会用”蓝屏“来通知用户程序视图访问不存在的内存页</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> WIN32程序设计 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-基础知识（1）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>汇编语言是直接在硬件之上互作的编程语言</p><p>学会用汇编的思维去使用C语言</p><p>比汇编更底层的  –&gt;  机器语言</p><p>【进制转化】【可以再去学一下】</p><p>【王爽的汇编语言】</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">简单讲是CPU中可以存储数据的器件，一个CPU中有多个寄存</span><br><span class="line">AX</span><br><span class="line">BX</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以后还会讲咯</span><br></pre></td></tr></table></figure><p>程序–&gt;汇编指令–&gt;编译器–&gt;机器码</p><p>汇编语言和机器指令是一一调用的</p><h3 id="汇编语言的组成"><a href="#汇编语言的组成" class="headerlink" title="汇编语言的组成"></a>汇编语言的组成</h3><p>1.汇编语言有3类组成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.汇编指令【机器码的助记符】</span><br><span class="line">2.伪指令【由编译器执行】</span><br><span class="line">3.其他符号【由编译器识别】</span><br></pre></td></tr></table></figure><p>2.汇编语言的核心是汇编指令，它决定了汇编语言的特性</p><p>【编码的奥秘】这本书推荐看看。</p><h3 id="储存器"><a href="#储存器" class="headerlink" title="储存器"></a>储存器</h3><p>1.CPU是计算机的核心部件，它控制整个计算机的运作并进行运算，要想让一个CPU互作，就必须向它提供指令和数据</p><p>2.指令和数据在存储器中存放，也就是平时说的内存</p><p>3.在一台PC中的内存的作用仅次于CPU</p><p>4.离开了内存，性能在好的CPU也无法互作</p><p>5.磁盘不同于内存，磁盘上的数据或程序如果不读到内存中，就无法被cpu使用</p><h3 id="指令和数据"><a href="#指令和数据" class="headerlink" title="指令和数据"></a>指令和数据</h3><p>1.指令和数据是应用上的概念</p><p>2.在内存或磁盘上，指令和数据没有任何区别，都是二进制信息</p><p>3.二进制信息：–&gt;【进制转化】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1000100111011000  ==&gt;转成Hex</span><br><span class="line">--&gt;89D8H(数据)</span><br><span class="line">1000100111011000</span><br><span class="line">--&gt;MOV AX,BX(程序)</span><br></pre></td></tr></table></figure><h3 id="存储单元"><a href="#存储单元" class="headerlink" title="存储单元"></a>存储单元</h3><p>1.储存区被划分为若干个存储单元，每个存储单元从0开始顺序编号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如：一个储存区有128个存储单元，那么编号从0~127</span><br></pre></td></tr></table></figure><p>2.对于大容量的储存区一般还用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KB = 1024B</span><br><span class="line">MB = 1024KB</span><br><span class="line">GB = 1024MB</span><br><span class="line">TB = 1024GB</span><br></pre></td></tr></table></figure><p>3.磁盘的容量单位同内存的一样，实际上以上单位是微机中常用的计量单位</p><h3 id="CPU对储存区的读写"><a href="#CPU对储存区的读写" class="headerlink" title="CPU对储存区的读写"></a>CPU对储存区的读写</h3><p>1.CPU要想进行数据的读写，必须和外部器件（标准的说法是芯片）进行三类信息的交互：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.存储单元的地址（地址信息）</span><br><span class="line">2.器件的选择，读或写命令（控制信息）</span><br><span class="line">3.读或写的数据（数据信息）</span><br></pre></td></tr></table></figure><h3 id="CPU对储存区的读写-1"><a href="#CPU对储存区的读写-1" class="headerlink" title="CPU对储存区的读写"></a>CPU对储存区的读写</h3><p>1.那么CPU是通过什么将地址，数据和控制信息传递到存储芯片的呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">电子计算能处理，传递的信息都是电信号，电信号当然要用导线传送</span><br></pre></td></tr></table></figure><p>2.在计算机中专门有连接CPU和其他芯片的导线【称为总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">在物理上：一根根导线的集合；</span><br><span class="line">逻辑上划分为：</span><br><span class="line">地址总线</span><br><span class="line">数据总线</span><br><span class="line">控制总线</span><br><span class="line"></span><br><span class="line">通过哪条线过来的数据就当作某来算</span><br><span class="line">就像上面的：</span><br><span class="line">1000100111011000  ==&gt;转成Hex</span><br><span class="line">--&gt;89D8H(数据)  【通过数据总线】</span><br><span class="line">1000100111011000</span><br><span class="line">--&gt;MOV AX,BX(程序)  【通过控制总线】</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230404232205006.png" alt="image-20230404232205006"></p><p>3.CPU是如何进行读和写的？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先通过地址总线，找到相对应的地址。</span><br><span class="line">然后通过控制总线，传入要读或者写的命令</span><br><span class="line">最后通过数据总线进行数据上的传递</span><br><span class="line">如果是读，就是从内存上的该地址通过数据总线把内容传递给CPU</span><br><span class="line">写，就是在CPU上通过数据总线找到该地址，写入内存中</span><br></pre></td></tr></table></figure><p>对于8086CPU，下面的机器码能完成从三号单元读数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">机器码：101000000000001100000000</span><br><span class="line">含义：从三号单元读取数据送入寄存器AX</span><br><span class="line">CPU接受这条机器码后将完成上面所述的读写互作</span><br></pre></td></tr></table></figure><h3 id="地址总线"><a href="#地址总线" class="headerlink" title="地址总线"></a>地址总线</h3><p>1.CPU是通过地址总线来指定存储单元的</p><p>2.地址总线上能传送多少个不同的信息，CPU就可以堆叠多少个存储单元进行寻址</p><p>3.一个CPU有N根地址总线，则可以说整个CPU的地址总线的宽度为N</p><p>4.这样的CPU最多可以寻找2的N次方个内存单元</p><p>5.地址是从下面往上面读</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405103334221.png" alt="image-20230405103334221"></p><p>这样读出来的是1011【前面的补上0】</p><h3 id="数据总线"><a href="#数据总线" class="headerlink" title="数据总线"></a>数据总线</h3><p>1.CPU与内存或其他器件之前的数据传送是通过数据总线来进行的</p><p>2.数据总线的宽度决定了CPU和外界数据传送速度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">宽度越高，一次传入的数据就越多。</span><br></pre></td></tr></table></figure><h3 id="控制总线"><a href="#控制总线" class="headerlink" title="控制总线"></a>控制总线</h3><p>1.CPU对外部器件的控制是通过控制总线来进行的。在这里控制总线是一个总称，控制总线是一些不同的控制线的集合</p><p>2.有多少根控制总线，就意味着CPU提供了对外部器件的多少种控制</p><p>3.所以，控制总线的宽度决定 看CPU对外部器件的控制能力</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制总线上发送的控制信息</span><br></pre></td></tr></table></figure><p>4.前面所讲的内存读或写的命令是由几根控制线综合发出的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.其中由一根名为读信号输出控制线负责由CPU向外传送读信号，CPU向该控制线上输出低电平表示将要读取数据</span><br><span class="line">2.有一根名为写信号输出控制线负责又CPU向外传送写信号</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>1.汇编指令是机器指令的助记符，同机器指令一一对应</p><p>2.每种CPU都有自己的汇编指令集</p><p>3.CPU可以直接使用的信息在存储器中存放</p><p>4.在存储器中指令和数据没有任何区别都是二进制信息</p><p>5.存储单元从零开始顺序编号</p><p>6.一个存储单元可以存储8个bit，即8位二进制数。</p><p>7.每一个CPU芯片都有许多管脚，这些管脚和总线相连。也可以说，这些管脚引出总线。一个CPU可以引出三种总线的宽度标志了这个CPU不同方面的性能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.地址总线的宽度决定了CPU的寻址能力；</span><br><span class="line">2.数据总线的宽度决定了CPU与其他器件进行数据传送时的一次数据传送量；</span><br><span class="line">3.控制总线宽度决定了CPU对系同种其他器件的控制能力</span><br></pre></td></tr></table></figure><p>8.在汇编课程中，我们从功能的角度介绍了这三类中线，对实际的连接情况不做讨论。</p><h3 id="内存地址空间（概述）"><a href="#内存地址空间（概述）" class="headerlink" title="内存地址空间（概述）"></a>内存地址空间（概述）</h3><p>1.上面是内存地址空间？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个CPU的地址线宽度为10，那么可以寻址1024个内存单元，这1024可寻到的内存单元就构成了这个CPU的内存地址空间</span><br></pre></td></tr></table></figure><p>2.主板</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在每一台PC机中，都有一个主板，主板上有核心器件和一些主要器件</span><br><span class="line">2.这些器件通过总线（地址，数据，控制）相连接</span><br></pre></td></tr></table></figure><p>3.接口卡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.计算机系统中，所有可用程序控制其互作的设备，必修收到CPU的控制</span><br><span class="line">2.CPU对外部设备不能直接控制。直接控制这些设备进行互作的是插在扩展插槽上的接口卡</span><br></pre></td></tr></table></figure><p>4.各类储存区芯片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.从读写属性上看分为2类：</span><br><span class="line">随机存储器（RAM）【比如内存】和只读存储器（ROM）</span><br><span class="line"></span><br><span class="line">2.从功能和连接上分类：</span><br><span class="line">随机存储器RAM</span><br><span class="line">装有BIOS的ROM</span><br><span class="line">BIOS：基本输入输出系统</span><br><span class="line">BIOS：是由主板和各类接口卡（比如：显卡，网卡...）厂商提供的软件系统，可以通过它利用该硬件设备进行最基本的输入输出。在主板和某些接口卡上插由存储相应的BIOS的ROM</span><br><span class="line">接口上的RAM</span><br><span class="line">PC机中各类存储器的逻辑相连接情况</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405125056876.png" alt="image-20230405125056876"></p><h3 id="内存地址空间"><a href="#内存地址空间" class="headerlink" title="内存地址空间"></a>内存地址空间</h3><p>1.上述的拿下存储器在物理上是独立的器件</p><p>2.但是它们在一下俩点上是相同的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.都和CPU的总线相连</span><br><span class="line">2.CPU对他们进行读或写的时候都通过控制线发出内存读写命令</span><br></pre></td></tr></table></figure><p>3.将各类存储器看作一个逻辑存储器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.所有的物理存储器被看作一个由若干存储单元组成的逻辑存储器；</span><br><span class="line">2.每个物理存储器在这个逻辑存储器中占有一个地址段，即一段地址空间；</span><br><span class="line">3.CPU在这段地址空间中读写数据，实际上就是在相对应的物理存储器中读写数据</span><br><span class="line"></span><br><span class="line">每一个PC的内存地址空间都是不一样的</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405125649612.png" alt="image-20230405125649612"></p><p>内存地址空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.最终运行的程序都是CPU，我们用汇编编程的时候，必须要从CPU角度考虑问题</span><br><span class="line">2.核心思维</span><br><span class="line">3.对CPU来讲，系统中的所有存储器中的存储单元都是处于一个统一的逻辑存储器中，它的容量受到CPU寻址能力的限制。这个逻辑存储器即是我们所说的内存地址空间</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-使用BIOS进行键盘和磁盘的读写（17）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-17-%E4%BD%BF%E7%94%A8BIOS%E8%BF%9B%E8%A1%8C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-17-%E4%BD%BF%E7%94%A8BIOS%E8%BF%9B%E8%A1%8C%E9%94%AE%E7%9B%98%E8%BE%93%E5%85%A5%E5%92%8C%E7%A3%81%E7%9B%98%E8%AF%BB%E5%86%99/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>大多数有用的程序都需要处理用户的输入，家农安的输入是最基本的输入</p><p> 程序和数据通常需要长期存储，磁盘是我们常用的存储设备。BIOS为这两种外设的I/O提供了最基本的中断例程</p><h2 id="1-int-9-中断例程对键盘输入的处理"><a href="#1-int-9-中断例程对键盘输入的处理" class="headerlink" title="1.int 9 中断例程对键盘输入的处理"></a>1.int 9 中断例程对键盘输入的处理</h2><p>CPU在9号中断发生后，执行int 9 中断例程，从60H端口读出扫描码，并将其转化为相应的SCII码或状态信息，存储在内存的指定空间【键盘缓冲区或状态字节】种</p><p>所以，一般的键盘输入，在CPU执行完int 9 中断例程后，都放到了键盘缓冲区中</p><h2 id="2-使用int-16h中断例程读取键盘缓冲区"><a href="#2-使用int-16h中断例程读取键盘缓冲区" class="headerlink" title="2.使用int 16h中断例程读取键盘缓冲区"></a>2.使用int 16h中断例程读取键盘缓冲区</h2><p>BIOS提供了int 16h 中断例程供程序员调用</p><p>int 16h 中断例程中包含的一个最重要的功能是从键盘缓冲区中读取一个键盘输入，该功能的编号为0</p><p>下面的指令从键盘缓冲区中读取一个键盘输入，并将其从缓冲区删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ah,0</span><br><span class="line">int 16h</span><br><span class="line">结果：</span><br><span class="line">(ah)=扫描码,(al)=ASCII码</span><br></pre></td></tr></table></figure><p>int 16h 中断例程的0号功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.检测键盘缓冲区中是否有数据</span><br><span class="line">2.没有则继续做第一步</span><br><span class="line">3.读取缓冲区第一个字单元中的键盘输入</span><br><span class="line">4.将读取的扫码送入ah，ASCII码送入al中</span><br><span class="line">5.将已读取的键盘输入从缓冲区中删除</span><br></pre></td></tr></table></figure><p>所以 int 9和int 16h中断例程是一对相互配合的程序，int 9中断例程向键盘缓冲区写入，int 16h中断例程从缓冲区中读出</p><p>它们写入和读出的时机不同，int 9 中断例程在有健按下的时候向键盘缓冲区写入数据</p><p>而int 16h中断例程是在应用程序对其进行调用的时候，将数据从键盘缓冲区读出来</p><h2 id="3-字符串的输入"><a href="#3-字符串的输入" class="headerlink" title="3.字符串的输入"></a>3.字符串的输入</h2>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-直接定址表（16）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-16-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-16-%E7%9B%B4%E6%8E%A5%E5%AE%9A%E5%9D%80%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-描述了单元长度的标号"><a href="#1-描述了单元长度的标号" class="headerlink" title="1.描述了单元长度的标号"></a>1.描述了单元长度的标号</h2><p>一般来说，普通的标号仅仅代表了内存单元的地址</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a: db 1,2,3,4,5,6,7,8</span><br><span class="line">b: dw 0</span><br><span class="line">start:</span><br><span class="line">mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>还有一种标号，还可以表示内存的单元长度</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">start:</span><br><span class="line">mov si,offset a</span><br><span class="line">mov bx,offset b</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">mov al,cs:[si]</span><br><span class="line">mov ah,0</span><br><span class="line">add cs:[bx],ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在code段中使用的标号a和b中没有:  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这就说明了:</span><br><span class="line">标号a:描述了地址code:0和从这个地址开始，以后的内存单元都是字节单元</span><br><span class="line">标号b:描述了地址code:8和从这个地址开始，以后的内存单元都是字单元</span><br></pre></td></tr></table></figure><p>这样就nb了</p><p>比如：对于程序中的b dw 0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">指令:mov ax,b 相当于：mov ax,cs:[8]</span><br><span class="line">指令:mov b,2 相当于： mov word ptr cs:[8],2</span><br><span class="line">指令:inc b 相当于： inc word ptr cs:[8]</span><br></pre></td></tr></table></figure><p>再比如：对于程序中的 a db 1,2,3,4,5,6,7,8</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,a[si]相当于 mov al,cs:0[si]</span><br><span class="line">mov al,a[3]相当于mov al,cs:0[3]</span><br><span class="line">mov al,a[bx+si+3]相当于 mov al,cs:0[bx+si+3]</span><br></pre></td></tr></table></figure><p>这种标号叫做数据标号，它标记了存储数据的单元的地址和长度【字？字节？】</p><p>【我咋感觉这个和数组差不多，数组首地址……】</p><h2 id="2-再其他段中使用数据标号"><a href="#2-再其他段中使用数据标号" class="headerlink" title="2.再其他段中使用数据标号"></a>2.再其他段中使用数据标号</h2><p>1.一般来说：我们不在代码段中定义数据，而是将数据定义到其他段中。再其他段中，我们也可以使用数据标号来描述存储数据的单元的地址和长度</p><p>注意：再后面又” : “ 的地址标号，只能再代码段中使用，不能再其他段中使用</p><p>下面的程序将data段中a标号处的8个数据累加，结果存储到b标号处的字中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segemnt </span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">mov al,a[si]</span><br><span class="line">mov ah,0;这个可以扔到外面去吧？</span><br><span class="line">add b,ax</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意：如果想在代码段中，直接使用数据标号访问数据，则需要用伪指令assume将标号所在的段和一个段寄存器联系起来</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data....</span><br></pre></td></tr></table></figure><p>2.可以将标号当作数据来定义，此时，编译器将标号所表示的地址当作数据的值</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>相当于:数据标号存储的2个字型数据为标号a b的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dw offset a,offset b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>再比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd a,b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><p>相当于：c处存储的2个双字数据为标号a的偏移地址和段地址，标号b的偏移地址和段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">a db 1,2,3,4,5,6,7,8</span><br><span class="line">b dw 0</span><br><span class="line">c dd offset a, seg a, offset b, seg b</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seg操作符，功能是取得某一个标号的段地址</span><br></pre></td></tr></table></figure><h2 id="3-直接定址表"><a href="#3-直接定址表" class="headerlink" title="3.直接定址表"></a>3.直接定址表</h2><p>需要用到多种映射关系的时候，我们可以将它制成一张表，这样有利于我们查找</p><p>比如：0<del>15和字符0</del>f之间建立一个映射关系</p><p>思路</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以数值N为table表中的偏移来找到对应的字符</span><br></pre></td></tr></table></figure><p>子程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">;用 al 传送要显示的数据</span><br><span class="line">showbyte:</span><br><span class="line">jmp short show</span><br><span class="line">table db &#x27;0123456789ABCDEF&#x27;;建立表单</span><br><span class="line"></span><br><span class="line">show:</span><br><span class="line">;设置子程序</span><br><span class="line">push bx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov ah,al</span><br><span class="line">mov bl,4</span><br><span class="line">shr ah,bl;右移4位，ah中得到高4位的值</span><br><span class="line">and al,00001111b;al为低4位</span><br><span class="line"></span><br><span class="line">mov bl,ah</span><br><span class="line">mov bh,0</span><br><span class="line">mov ah,table[bx];用高4位的值作为table的偏移，取得相应的字符</span><br><span class="line"></span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov es:[160*12+40*2],ah</span><br><span class="line"></span><br><span class="line">mov bl,al</span><br><span class="line">mov bh,0</span><br><span class="line">mov al,table[bx];用低4位作为相对于table的偏移，取得相对于的字符</span><br><span class="line"></span><br><span class="line">mov es:[160*12+40*2+2],al</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop bx</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-程序入口地址的直接定址表"><a href="#4-程序入口地址的直接定址表" class="headerlink" title="4.程序入口地址的直接定址表"></a>4.程序入口地址的直接定址表</h2><p>首先就是说：我们可以将这些字功能的入口地址存储再一个表中，它们在表中的位置和功能号相对应。</p><p>来设计功能吧</p><p>1.清屏：也就是将显存中当前屏幕中的字符串设为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sub1:</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">mov bx,0b800H</span><br><span class="line">mov es,bx</span><br><span class="line">mov bx,0</span><br><span class="line">mov cx,2000</span><br><span class="line">subls:</span><br><span class="line">mov byte ptr es:[bx],&#x27; &#x27;</span><br><span class="line">add bx,2</span><br><span class="line">loop subls</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>2.设置前景色:设置显存中当前屏幕中处于奇地址的属性字节的第0，1，2位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">sub2:</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line"></span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">sub2s:</span><br><span class="line">and byte ptr es:[bx],11111000b;先将0，1，2位设置为0</span><br><span class="line">or es:[bx],al;然后用or来设置前景色中的值为al</span><br><span class="line">add bx,2</span><br><span class="line">loop subs2</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>3.设置背景色：设置显存中当前屏幕中处于奇地址的属性字节的 4 5 6位</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">sub3:</span><br><span class="line">push bx</span><br><span class="line">push cx</span><br><span class="line">push es</span><br><span class="line">mov cl,4</span><br><span class="line">shl al,cl</span><br><span class="line">mov bx,0b800h</span><br><span class="line">mov es,bx</span><br><span class="line">mov bx,1</span><br><span class="line">mov cx,2000</span><br><span class="line">sub3s:</span><br><span class="line">and byte ptr es:[bx],10001111B</span><br><span class="line">or es:[bx],al;因为要改变4 5 6 的位置，所以在前面需要shl 将al的值移动到456位置的地方</span><br><span class="line">add bx,2</span><br><span class="line">loop sub3s</span><br><span class="line"></span><br><span class="line">pop es</span><br><span class="line">pop cx</span><br><span class="line">pop bx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>4.向上滚动一行：也就是n+1行的内容复制到第n行；最后一行为空</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">sub4:</span><br><span class="line">push cx</span><br><span class="line">push si</span><br><span class="line">push di</span><br><span class="line">push es</span><br><span class="line">push ds</span><br><span class="line">;因为下面需要用到，所以要保存到</span><br><span class="line">mov si,0b800h</span><br><span class="line">mov es,si</span><br><span class="line">mov ds,si</span><br><span class="line">mov si,160</span><br><span class="line">mov di,0</span><br><span class="line">cld;设置copy的方向</span><br><span class="line">mov cx,24;一共要复制24行</span><br><span class="line"></span><br><span class="line">sub4s:;把n+1行的东东复制到n行</span><br><span class="line">push cx</span><br><span class="line">mov cx,160</span><br><span class="line">rep movsb;进行复制咯ds:si复制到es:di中</span><br><span class="line">pop cx</span><br><span class="line">loop sub4s</span><br><span class="line"></span><br><span class="line">mov cx,80</span><br><span class="line">mov si,0</span><br><span class="line">sub4s1:;将最后一行清空</span><br><span class="line">mov byte ptr [160*24+si],&#x27; &#x27;</span><br><span class="line">add si,2</span><br><span class="line">loop sub4s1</span><br><span class="line"></span><br><span class="line">pop ds</span><br><span class="line">pop es</span><br><span class="line">pop di</span><br><span class="line">pop si</span><br><span class="line">pop cx</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-外中断（15）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-15-%E5%A4%96%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-15-%E5%A4%96%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>之前我们讨论的都是CPU对指令的执行。我们知道CPU在计算机系统中，除了能够执行指令外，还能进行运算，还应该能够对外部设备进行控制，接受它们的输入，向他们输出</p><p>也就是说：CPU除了运算能力外，还有I/O（input/output）能力</p><h2 id="1-接口芯片和端口"><a href="#1-接口芯片和端口" class="headerlink" title="1.接口芯片和端口"></a>1.接口芯片和端口</h2><p>在PC系统的接口卡和主板上，装有各种接口芯片。这些外设接口芯片的内部有若干寄存器，CPU将这些寄存器当作端口来访问。</p><p>外设的输入和CPU的输出都不是直接的，而是通过送入相关的接口芯片的端口中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">每一个外部设备都有一个小小的，类似于内存一样的端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU通过端口和外部设备进行联系</span><br></pre></td></tr></table></figure><h2 id="2-外中断信息"><a href="#2-外中断信息" class="headerlink" title="2.外中断信息"></a>2.外中断信息</h2><p>由CPU的自己产生的中断信息叫内中断，非CPU由外部中断的叫外中断</p><p>外中断一共有2种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.可屏蔽中断【要看IF位的设置】</span><br><span class="line">2.不可屏蔽中断【少】</span><br></pre></td></tr></table></figure><p>当CPU检测到可屏蔽信息的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果IF=1，则CPU在执行完当前指令后，响应中断</span><br><span class="line">如果IF=0，则不响应中断</span><br><span class="line"></span><br><span class="line">所以在进入某个中断的时候，就会自动的把IF设置为0</span><br></pre></td></tr></table></figure><p>内中断的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.取得中断类型码N</span><br><span class="line">2.pushf</span><br><span class="line">3.TF = 0,IF = 0</span><br><span class="line">4.push CS</span><br><span class="line">5.push IP</span><br><span class="line">6.(IP)=(N*4),(CS)=(N*4+2)</span><br><span class="line">转去执行</span><br></pre></td></tr></table></figure><p>外中断信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可屏蔽中断所引发的中断的过程和内中断基本一样，除了第一个</span><br><span class="line">取得中断信息，由于中断信息是来自CPU外部，中断类型码是通过数据总线送入CPU的</span><br><span class="line">而内中断的中断类型码是在CPU内部产生的</span><br></pre></td></tr></table></figure><p>8086CPU提供了设置IF的指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sti。将IF设置为1</span><br><span class="line">cli，将IF设置为0</span><br></pre></td></tr></table></figure><p>不可屏蔽中断的中断过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">标志寄存器入栈，IF=0,TF=0</span><br><span class="line">CS,IP入栈</span><br><span class="line">(IP)=(8),(CS)=(0AH)</span><br><span class="line">这是一个固定的地址</span><br></pre></td></tr></table></figure><h2 id="3-PC键盘的处理过程"><a href="#3-PC键盘的处理过程" class="headerlink" title="3.PC键盘的处理过程"></a>3.PC键盘的处理过程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.键盘输入</span><br><span class="line">2.引发9号中断</span><br><span class="line">3.执行int 9 中断例程</span><br></pre></td></tr></table></figure><p>键盘上每一个健相当于一个开关，键盘中由一个芯片对减半上的每一个健的开关状态进行扫描</p><p>按下一个健的时候，就会产生一个扫描码，这个扫描码就会被送入接口芯片的寄存器中，改寄存器的端口地址就是60H</p><p>,松开的时候也会产生一个扫描码</p><p>按下的码【通码】，松开【断码】</p><p>扫描长度是一个字节，通码的第七位为0，断码的第七位为1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">断码 = 通码 + 80H</span><br></pre></td></tr></table></figure><p>bios提供了 int 9 中断例程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.读取60H端口的扫描码</span><br><span class="line">2.如果是字符集键的扫描码，改扫描码和它所对应的字符吗（ASCII）送入内存中的BIOS键盘缓冲区</span><br><span class="line">3.如果是控件健和切换键的扫描码，则将其转变为状态字节（用二进制记录控制键和切换键状态的字节）写入内存中粗存状态字节的单元</span><br></pre></td></tr></table></figure><p>一般情况下，CPU在执行当前指令后，如果检测到中断信息，就响应中断，引发中断过程</p><p>可是在有些情况下，CPU在执行当前指令后，即便是发生中断，也不会响应</p><p>该内存区可以存储15个键盘输入，因为int 9 中断例程除了接收扫描码外，还要产生 字符吗，所以BIOS键盘缓冲区中，一个键盘输入用一个字单元存放，高位字节存放扫描码，低位字节存放字符码</p><p>0040：17单元控制着键盘键的状态字节</p><h2 id="4-编写int-9-中断例程"><a href="#4-编写int-9-中断例程" class="headerlink" title="4.编写int 9 中断例程"></a>4.编写int 9 中断例程</h2><p>过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.键盘产生扫描码</span><br><span class="line">2.扫描码送入60H端口</span><br><span class="line">3.一旦检测到60H端口有动静，引发9号中断</span><br><span class="line">4.CPU执行int 9 中断例程处理键盘输入【只能控制这里】</span><br></pre></td></tr></table></figure><p>啦啦啦</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s1:</span><br><span class="line">sub ax,1;当ax=0减去1的时候会变成FFFF，然后会借位，所以CF会变成1</span><br><span class="line">sbb dx,0;只有在CF中为1的时候，dx才会被减1</span><br><span class="line">cmp ax,0</span><br><span class="line">jne s1</span><br><span class="line">cmp dx,0</span><br><span class="line">jne s1</span><br></pre></td></tr></table></figure><p>这个代码和c语言中的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">for(i=0; i&lt;100; i++)&#123;</span><br><span class="line">for(j=0;j&lt;10000;j++)&#123;</span><br><span class="line">***</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">是一模一样的</span><br></pre></td></tr></table></figure><p>实现IF和TF=0的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushf </span><br><span class="line">pop ax</span><br><span class="line">and ah,11111100B</span><br><span class="line">;if和tf是标志寄存器的9 和 8 位</span><br><span class="line"></span><br><span class="line">push ax</span><br><span class="line">popf</span><br></pre></td></tr></table></figure><h2 id="5-总结一下啦"><a href="#5-总结一下啦" class="headerlink" title="5.总结一下啦"></a>5.总结一下啦</h2><p>8086CPU提供一下几个大类的指令</p><p>1.数据传送指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov push pop pushf popf xchg</span><br><span class="line">都是数据传送指令，这些指令实现寄存器和内存，寄存器和寄存器之间的单个数据传送</span><br></pre></td></tr></table></figure><p>2.算数运算指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add sub adc sbb inc dec cmp imul idiv aaa</span><br><span class="line">都是算术运算指令，这些指令实现寄存器和内存中的数据的算数运算</span><br><span class="line">它们的执行结果会影响标志寄存器：</span><br><span class="line">sf zf of cf pf af</span><br></pre></td></tr></table></figure><p>3.逻辑指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">and or not xor test shl shr sal sar rol ror rcl rcr</span><br><span class="line">除了not，它们的执行结果都会影响标志寄存器的相关标志位</span><br></pre></td></tr></table></figure><p>4.转移指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">可以修改IP，或者CS和IP</span><br><span class="line">1.无条件转移指令：jmp</span><br><span class="line">2.条件转移指令：jcxz je jb ja jnb jna</span><br><span class="line">3.循环指令：loop</span><br><span class="line">4.过程：call ret retf</span><br><span class="line">5.中断：int iret</span><br></pre></td></tr></table></figure><p>5.处理机控制指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对标志寄存器或者其他处理机状态进行设置</span><br><span class="line">cld std cli sti nop clc cmc stc hlf wait essc lock </span><br></pre></td></tr></table></figure><p>6.串处理指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对内存中的批量数据进行处理</span><br><span class="line">movsb movsw cmps scas lods stos</span><br><span class="line">一般需要和rep repe repne前缀指令配合使用</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-端口（14）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-14-%E7%AB%AF%E5%8F%A3/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-14-%E7%AB%AF%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>CPU可以直接读取3个地方的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.CPU内部的寄存器</span><br><span class="line">2.内存单元</span><br><span class="line">3.端口</span><br></pre></td></tr></table></figure><h2 id="1-端口的读写"><a href="#1-端口的读写" class="headerlink" title="1.端口的读写"></a>1.端口的读写</h2><p>端口的读写不能用 mov </p><p>1.只能用in out</p><h3 id="访问内存"><a href="#访问内存" class="headerlink" title="访问内存"></a>访问内存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[8]</span><br><span class="line">1.CPU通过地址线将地址信息8发出</span><br><span class="line">2.CPU通过控制线发出内存读命令，选中存储器芯片，并通知它，将要从中读取数据</span><br><span class="line">存储器将8号单元中的数据通过数据线送入CPU</span><br></pre></td></tr></table></figure><h3 id="访问端口"><a href="#访问端口" class="headerlink" title="访问端口"></a>访问端口</h3><p>in是读，out是写</p><p>in al,60h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">从60H号端口读入一个字节</span><br></pre></td></tr></table></figure><p>执行的时候操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.CPU通过地址将地址信息60h发出</span><br><span class="line">2.CPU通过控制线发出端口读命令，选中端口所在的芯片，并通知它，将要从中读取数据</span><br><span class="line">3.端口所在的芯片将60h端口中的数据通过数据线送入CPU</span><br></pre></td></tr></table></figure><p>2.注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在in 和 out 指令中，只能使用ax或al 来存从端口中读入的数据或要发送到端口中的数据。访问8位端口的时候，用al，访问16位端口的时候，用ax</span><br></pre></td></tr></table></figure><p>3.对0~255以内的端口进行读写</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in al,20h;从20h端口读入一个字节，放到al中</span><br><span class="line">out 20h,al;往20h端口写入一个字节</span><br></pre></td></tr></table></figure><p>4.对256~65535的端口进行读写的时，端口号放在dx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov dx,3f8h;将端口号3f8送入dx中</span><br><span class="line">in al,dx;从3f8h端口读入一个字节</span><br><span class="line">out dx,al;向3f8h端口写入一个字节</span><br><span class="line"></span><br><span class="line">读或者写数据是放在al或者ax中，端口号是放在dx中的</span><br></pre></td></tr></table></figure><h2 id="2-CMOS-RAM-芯片"><a href="#2-CMOS-RAM-芯片" class="headerlink" title="2.CMOS RAM 芯片"></a>2.CMOS RAM 芯片</h2><p>PC机中有一个CMOS RAM芯片</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.包含一个实时钟和一个有128个存储单元的RAM寄存器</span><br><span class="line">2.改芯片靠电池供电。</span><br><span class="line">3.128个字节的RAM中，内部实时种占用0~0dh单元来保存时间信息，其他大部分分单元用于保存系统配置信息，供系统启动的时候BIOS程序读取</span><br></pre></td></tr></table></figure><p>2.bios也提供了相关的程序，使我们可以在开机的时候，配置CMOS RAM种的系统会给信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">改芯片内部有2个端口，端口地址是70H和71H</span><br><span class="line">70H为地址端口，存放要访问的CMOS RAM单元的地址；71为数据端口，存放从选定的COS RAM 单元种读取的数据，或要写入到其中的数据</span><br></pre></td></tr></table></figure><p>比如：读CMOS RAM 的2号单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.将2送入端口70h</span><br><span class="line">2.从71h读出2号单元的内容</span><br></pre></td></tr></table></figure><h2 id="3-shl和shr指令"><a href="#3-shl和shr指令" class="headerlink" title="3.shl和shr指令"></a>3.shl和shr指令</h2><p>1.shl和shr是逻辑位移指令，后面的课程中我们要用到位移指令</p><p>2.shl是逻辑左移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.将一个寄存器或者内存单元中的数据向左移位</span><br><span class="line">2.将最后移出的一位写入CF中</span><br><span class="line">3.最低位用0补充</span><br></pre></td></tr></table></figure><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,01001000b</span><br><span class="line">shl al,1;将al中的数据左移1位</span><br><span class="line">执行后(al)=10010000b,cf=0</span><br></pre></td></tr></table></figure><p>如果移动位数大于1的时候，必须将移动位数放在cl中</p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,01010001b</span><br><span class="line">mov cl,3</span><br><span class="line">sha al,cl</span><br><span class="line">执行后(al)=10001000b cf=0</span><br></pre></td></tr></table></figure><p>可以看出，将x逻辑左移一位，相当于执行x=x*2</p><p>3.shr就是shl的反向操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">移出的最后一个存入cf中</span><br></pre></td></tr></table></figure><p>逻辑右移一位，相当于x=x/2</p><h2 id="4-CMOS-RAM中存储的时间信息"><a href="#4-CMOS-RAM中存储的时间信息" class="headerlink" title="4.CMOS RAM中存储的时间信息"></a>4.CMOS RAM中存储的时间信息</h2><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230503145254486.png" alt="image-20230503145254486"></p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-int指令（13）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-13-int%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-13-int%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>无</p><h2 id="1-int-指令"><a href="#1-int-指令" class="headerlink" title="1.int 指令"></a>1.int 指令</h2><p>1.CPU指令int n 指令，相当于引发一个 n 号中断的中断过程，执行过程如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.取中断类型码 n ；</span><br><span class="line">2.标志寄存器入栈，IF=0 TF=0</span><br><span class="line">3.CS,IP入栈</span><br><span class="line">4.(IP)=(N*4),(CS)=(N*4+2)</span><br><span class="line">从此转去执行n号中断的中断处理程序</span><br></pre></td></tr></table></figure><p>2.int指令和call指令类似，但是int是调试中断指令，但是call是函数</p><h2 id="2-编写供应用程序调用的中断例程"><a href="#2-编写供应用程序调用的中断例程" class="headerlink" title="2.编写供应用程序调用的中断例程"></a>2.编写供应用程序调用的中断例程</h2><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230416230210682.png" alt="image-20230416230210682"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.编写实现平方功能的程序</span><br><span class="line">2.安装程序，我们将其安装在0:200中</span><br><span class="line">3.设置中断向量表，将程序的入口地址保存在7ch表项中，使其成为中断7ch的中断例程</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code </span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,3456;(ax)=3456</span><br><span class="line">int 7ch;调用中断7ch的中断例程，计算ax中的数据的平方</span><br><span class="line"></span><br><span class="line">add ax,ax</span><br><span class="line">adc dx,dx;将结果乘以2</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">;编写：安装中断7ch的中断例程</span><br><span class="line">;功能：求-word型数据的平方</span><br><span class="line">;参数：(ax) = 要计算的数据</span><br><span class="line">;返回值：dx,ax中存放结果的高和低16位</span><br><span class="line"></span><br><span class="line">assume cs:code </span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax,cs</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,offset sqr;设置ds和si的值，指向源程序</span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,200H;设置es:di指向目的地址；也就是那个安全空空间，在安全空间里面写入指令，然后让向量表指向这个写了代码的安全空间</span><br><span class="line">mov cx,offset sqrent - offset sqr</span><br><span class="line"></span><br><span class="line">cld</span><br><span class="line">rep movsb;ds:si的传入es:bi</span><br><span class="line"></span><br><span class="line">mov ax,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov word ptr es:[7ch*4],200H;设置中断向量表，</span><br><span class="line">mov word ptr es:[7ch*4+2],0;修改了7ch所指定的地址到了我们写入的安全空间</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">sqr:mul ax;mul指令是乘法指令，它默认的是al或ax中的值和某一个8/16位单元中乘法，放在ax 或者dx和ax中</span><br><span class="line">iret;iret是返回中断【int】，ret是返回普通的【call】</span><br><span class="line"></span><br><span class="line">sqrend:nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="3-对int，iret和栈的深入理解"><a href="#3-对int，iret和栈的深入理解" class="headerlink" title="3.对int，iret和栈的深入理解"></a>3.对int，iret和栈的深入理解</h2><p>int 7ch 引发中断过程后，它会把flag，ip和cs都压入栈中，此时压入的CS和IP中的内容，分辨是调用程序的段地址（可以认为是标号s的段地址）和int 7ch后一条指令的偏移地址（也就是标号se的偏移地址）</p><p>可见，在中断例程中，可以从栈里面取得标号s的段地址和标号se的偏移地址，而用se的偏移地址加上bx中存放的转移位移就可以得到s的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">;中断例程如下：</span><br><span class="line">lp:</span><br><span class="line">push bp</span><br><span class="line">mov bp,sp</span><br><span class="line">dec cx</span><br><span class="line">jcxz lpret;当cx为0的时候跳转</span><br><span class="line">add [bp+2],bx在使用bp的时候是默认是用ss段地址</span><br><span class="line">;这里bp+2是因为，对于8086CPU每一个都占用2个字节</span><br><span class="line">;</span><br><span class="line">lpret:</span><br><span class="line">pop bp</span><br><span class="line">iret</span><br></pre></td></tr></table></figure><p>这里因为要访问栈，使用bp,在程序开始处将bp入栈，结束的时候出栈恢复。当要修改栈中se的偏移地址的时候，栈中的情况是：栈顶处是bp原来的数值，下面是se的偏移地址，在下面是s的段地址，在下面是标志寄存器的值。而此时，bp中为栈顶的偏移地址，所以((ss)*16+(bp)+2)处是se的偏移地址，将他加上bx中的位移也就变成了s的偏移地址。最后用iret出栈返回，CS:IP即从标号s处开始执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int 入栈的时候相当于是push </span><br><span class="line">它是往上走的</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.pop IP</span><br><span class="line">2.pop CS</span><br><span class="line">3.popf</span><br></pre></td></tr></table></figure><h2 id="4-BIOS和DOS中断例程的安装过程"><a href="#4-BIOS和DOS中断例程的安装过程" class="headerlink" title="4.BIOS和DOS中断例程的安装过程"></a>4.BIOS和DOS中断例程的安装过程</h2><p>int 10H中断例程是bios提供的中段例程，其中包含了多个屏幕输出相关的子程序</p><p>一般来说，一个供程序员调用的中断例程中往往包含多个子程序，中断例程内部用传递进来的参数来决定执行那个子程序</p><p>bios 和 dos 提供的中断例程，都是用ah来传递内部子程序的编号</p><p>int 10H中断例程的设置光标位置功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ah,22号子程序</span><br><span class="line">mov bh,0行号</span><br><span class="line">mov dh,5列号</span><br><span class="line">mov dl,12页数</span><br><span class="line">int 10h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-内中断（12）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-12-%E5%86%85%E4%B8%AD%E6%96%AD/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-12-%E5%86%85%E4%B8%AD%E6%96%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>中断：外部终端和内部终端</p><h2 id="1-中断处理程序"><a href="#1-中断处理程序" class="headerlink" title="1.中断处理程序"></a>1.中断处理程序</h2><p>1.CPU的设计者必须在中断信息和其处理程序的入口地址之间建立某种联系，使得COU根据中断信息可以找到要执行的处理程序</p><p>2.中断信息包含有标志中断源的类型码。根据CPU的设计，中断类型码的作用就是用来定位中断处理程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">比如CPU根据中断类型码4，就可以找到4号的处理程序</span><br></pre></td></tr></table></figure><h2 id="2-中断向量表"><a href="#2-中断向量表" class="headerlink" title="2.中断向量表"></a>2.中断向量表</h2><p>1.CPU中8位的中断类型码，通过中断向量表找到相应的中断处理程序的入口地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">起始就是一个索引</span><br><span class="line">一个类型码有一个对应的地址</span><br></pre></td></tr></table></figure><p>2.中断向量表在内存中存放，对于8086CPU机，中断向量表指定放在内存地址0处</p><p>从内存0000:0000到0000:03ff的1024个内存单元中存放着中断向量表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">为什么是1024？</span><br><span class="line">1.一个地址是段地址和偏移地址组成【都是16位，也就是2个字节】</span><br><span class="line">所以一个地址就需要4个字节，一共是8位的中断类型码，也就是有256个中断类型码，所以需要1024个内存单元</span><br></pre></td></tr></table></figure><h2 id="3-中断过程"><a href="#3-中断过程" class="headerlink" title="3.中断过程"></a>3.中断过程</h2><p>1.8086CPU的中断过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.（从中断信息中）取得中断类型码</span><br><span class="line">2.标志寄存器的值入栈【PSW】--用于保护标志位</span><br><span class="line">3.设置标志寄存器的第8位TF和第9位IF的值为0</span><br><span class="line">4.CS的值入栈</span><br><span class="line">5.IP的值入栈</span><br><span class="line">6.从内存地址为中断类型码*4和中断类型码*4+2的两个字单元中读取处理程序的入口地址，设置IP和CS</span><br></pre></td></tr></table></figure><p>简单点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.取得中断类型码N</span><br><span class="line">2.pushf</span><br><span class="line">3.TF = 0,IF = 0</span><br><span class="line">4.push CS</span><br><span class="line">5.push IP</span><br><span class="line">6.(IP)=(N*4),(CS)=(N*4+2)</span><br><span class="line">取地址的时候，首先取的是偏移地址，在是段地址</span><br></pre></td></tr></table></figure><p>中断处理程序的步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.保存用到的寄存器</span><br><span class="line">2.处理中断</span><br><span class="line">3.恢复用到的寄存器</span><br><span class="line">4.用iret指令返回</span><br></pre></td></tr></table></figure><h2 id="4-iret指令的功能"><a href="#4-iret指令的功能" class="headerlink" title="4.iret指令的功能"></a>4.iret指令的功能</h2><p>1.用汇编语法解释</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.pop IP</span><br><span class="line">2.pop CS</span><br><span class="line">3.popf</span><br><span class="line">恢复之前保护的</span><br></pre></td></tr></table></figure><p>2.iret通常和硬件自动完成的中断过程配合使用</p><h2 id="5-除法错误中断的处理"><a href="#5-除法错误中断的处理" class="headerlink" title="5.除法错误中断的处理"></a>5.除法错误中断的处理</h2><p> 编写一个程序，让发生除法错误中断的时候，在屏幕上输出xxx</p><p>分析</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当发生除法溢出的时候，会参数0号中断信息，从而引发中断过程</span><br><span class="line">CPU</span><br><span class="line">取得中断类型：0</span><br><span class="line">标志寄存器入栈，TF和IF设置为0</span><br><span class="line">CS，IP入栈</span><br><span class="line">(IP)=(0*4),(CS)=(0*4+2) //找到中断类型所对应的地址</span><br></pre></td></tr></table></figure><h2 id="6-有一个编程"><a href="#6-有一个编程" class="headerlink" title="6.有一个编程"></a>6.有一个编程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">看12.10play</span><br></pre></td></tr></table></figure><h2 id="7-单步中断"><a href="#7-单步中断" class="headerlink" title="7.单步中断"></a>7.单步中断</h2><p>CPU在执行完一条命令后，如果检测到编制寄存器的TF位1，则残生单步中断</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说TF=1是产生中断的标志</span><br></pre></td></tr></table></figure><p>步骤</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.取得中断类型码1</span><br><span class="line">2.标志寄存器入栈，TF，IF设置为0</span><br><span class="line">3.CS,IP入栈</span><br><span class="line">4.(IP)=(1*4),(CS)=(1*4+2)</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230416214427516.png" alt="image-20230416214427516"></p><h2 id="8-响应中断的特殊情况"><a href="#8-响应中断的特殊情况" class="headerlink" title="8.响应中断的特殊情况"></a>8.响应中断的特殊情况</h2><p>一般情况下，CPU在执行当前指令后，如果检测到中断信息，就响应中断，引发中断过程</p><p>可是在有些情况下，CPU在执行当前指令后，即便是发生中断，也不会响应</p><p>因为某些过程需要连续完成，不能卡在中间，比如ss:sp的设置就不能中断，在完成ss的设置后，即使发送中断CPU也不会中断，sp的设置因该连续完成</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-标志寄存器（11）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-11-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-11-%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>1.8086CPU的标志寄存器有16位，其中存储信息通常被称为程序状态字(PSW)</p><p>2.我们已经使用过8086CPU的ax,bx,cx,dx,si,di,bp,sp,ip,cs,ss,ds,es等13个寄存器</p><p>3.本章中的标志寄存器【flag】是我们的最后一个寄存器</p><p>4.flag和其他寄存器不一样，其他寄存器是用存放数据的，都是整个寄存器具有一个含义</p><p>5.而flag寄存器是安位起作用，也就是说：它的每一位都有专门的含义，记录特定的信息</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230414160205653.png" alt="image-20230414160205653"></p><p>6.flag在8086CPU中，只有 0 2 4 6 7 8 9 10 11具有特殊的含义，其他位置都没有意义</p><h2 id="1-ZF标志"><a href="#1-ZF标志" class="headerlink" title="1.ZF标志"></a>1.ZF标志</h2><p>1.flag的第6位是ZF，零标志位，它记录相关指令执行后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为0, ZF=1</span><br><span class="line">结果不为0，ZF=0</span><br></pre></td></tr></table></figure><p>2.比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1执行后结果为0，则ZF=1</span><br><span class="line"></span><br><span class="line">mov ax,2</span><br><span class="line">sub ax,1执行后结果为1，则ZF=0</span><br></pre></td></tr></table></figure><p>3.对于ZF的值，我们可以这样来看，ZF标志相关指令的计算结果是否为0，如果是0，则在ZF要记录下“是0”这样的肯定信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">add ax,0</span><br><span class="line">执行后，结果为0，则ZF=1  表示结果是0</span><br></pre></td></tr></table></figure><p>4.我们使用一条指令的时候，要注意这条指令的全部功能，其中包括，执行结果对标志寄存器的哪些标志位造成影响</p><h2 id="2-PF标志"><a href="#2-PF标志" class="headerlink" title="2.PF标志"></a>2.PF标志</h2><p>1.PE，奇偶标志位。它记录指令执行后，结果的所有二进制位中的1的个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">为偶数，PE=1</span><br><span class="line">为奇数，PE=0</span><br></pre></td></tr></table></figure><p>2.比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">addal,10</span><br><span class="line">执行后，结果为00001011B，其中有3个1，则PE=0</span><br><span class="line">mov al,1</span><br><span class="line">or al,10</span><br><span class="line">执行后，结果为00000011B，其中有2个1，则PE=1</span><br></pre></td></tr></table></figure><h2 id="3-SF"><a href="#3-SF" class="headerlink" title="3.SF"></a>3.SF</h2><p>1.flag的第7位是SF，符号标志位，它记录指令执行后</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">结果为负SF = 1</span><br><span class="line">结果为正SF = 0</span><br></pre></td></tr></table></figure><h3 id="有符号数和补码-课外知识，得学"><a href="#有符号数和补码-课外知识，得学" class="headerlink" title="有符号数和补码[课外知识，得学]"></a>有符号数和补码[课外知识，得学]</h3><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">00000001B，可以看作无符号1，或者有符号数+1</span><br><span class="line">10000001B，可以看作无符号数129，或者看作有符号数-127</span><br></pre></td></tr></table></figure><p>2.示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001B</span><br><span class="line">add al,1</span><br><span class="line">结果(al)=10000010B</span><br></pre></td></tr></table></figure><p>我们可以将add指令的运算当作无符号数的运算，那么add指令相当于计算129+1，结果是130【10000010B】</p><p>也可以将add指令进行的运算当作有符号的运算，那么add指令相当于计算-127+1，结果为-126【10000010B】</p><p>不管我们如何看待，cpu在执行add等指令的时候，就已经包含了两种含义，也就得到用同一种信息来记录的2中结果</p><p>关键在于我们需要哪一种结果</p><p>3.SF标志，就是CPU对有符号数运算结果的一种记录，它记录数据的正负</p><p>4.CPU在执行add等指令的时候，必然要影响到SF标志位的值</p><p>5.至于需不需要，关键是看我们自己需不需要</p><p>某些指令将影响标志寄存器中的多个标志位，这些被影响的标志位比较全面的记录了指令执行结果，为相关的处理提供了所需的依据，至于需不需要这些结果全都看我们自己</p><h2 id="4-CF标志"><a href="#4-CF标志" class="headerlink" title="4.CF标志"></a>4.CF标志</h2><p>【相对于无符号数而言】</p><p>1.flag的第0位是CF，进位标志位</p><p>2.一般情况下，在进行无符号数运算的时候，它记录了运算结果的最高有效位向更高位的进位值，或从更高位的借位值</p><p>3.对于位数为N的无符号数来说，其对应的二进制信息的最高位，也就是第N-1位，的最高有限位，而假象存在的第N位，就是相对于最高有效位的更高位</p><p>我们知道，当2个数据相加的时候，可能产生从最高有效位向更高位的进位，这个更高位去哪里了呢？</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230414164826803.png" alt="image-20230414164826803"></p><p>比如</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,98H</span><br><span class="line">add al,al;</span><br><span class="line">执行后，al=30H ,cf=1</span><br><span class="line">cf记录了最高有效位向更高位的进位值</span><br></pre></td></tr></table></figure><p>在比如</p><p>两个8位的数据97H-98H，将产生借位，借位后，相当于是197H-98H,,而flag的cf位也可以用来记录这个借位值</p><h2 id="5-OF标志"><a href="#5-OF标志" class="headerlink" title="5.OF标志"></a>5.OF标志</h2><p>【对有符号数而言】</p><p>1.溢出</p><p>在进行有符号运算的时候，如结果超过了机器所能表示的范围称为溢出</p><p>2.什么是机器所能表示的范围？</p><p>add al,3 那么对于8位的有符号数据，机器所能表示的范围就是-128~127</p><p>3.如果我们使用add指令进行的是有符号数运算，则98+99=-59，这样的结果让人无法接受</p><p>造成这种情况的原因，就是实际结果是197，作为一个有符号数，在8位寄存器al中存放不下</p><p>由于在进行有符号数运算的时候，可能发生溢出而造成结果的错误。所以CPU需要对指令执行后是否参数溢出进行记录，从而有了OF</p><h3 id="区别：CF和OF"><a href="#区别：CF和OF" class="headerlink" title="区别：CF和OF"></a>区别：CF和OF</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.CF是对无符号数运算有意义的标志位</span><br><span class="line">用CF来记录是否产生了进位</span><br><span class="line"></span><br><span class="line">2.OF是对无符号数运算有意义的标志位</span><br><span class="line">用OF记录是否产生了溢出</span><br><span class="line">用SF来记录结果的符号</span><br></pre></td></tr></table></figure><p>无符号CF有符号PF+SF</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230414175326095.png" alt="image-20230414175326095"></p><h2 id="6-adc指令"><a href="#6-adc指令" class="headerlink" title="6.adc指令"></a>6.adc指令</h2><p>1.adc是带有进位加法指令，它利用了CF上记录的进位值</p><p>2.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adc 操作对象1,操作对象2</span><br></pre></td></tr></table></figure><p>3.功能：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">操作对象1=操作对象1+操作对象2+CF</span><br><span class="line">add ax,bx</span><br><span class="line">(ax)=(ax)+(bx)+cf</span><br></pre></td></tr></table></figure><p>4.在执行adc指令的时候加上的cf的值的含义，由adc指令前面的指令决定的，也就是说，关键在于所加上的cf的值是被什么指令设置的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显然，如果CF的值是被sub指令设置的，那么它的含义就是借位值；如果是被add指令设置的，那么就是进位值</span><br></pre></td></tr></table></figure><p>5.我们来看一下两个数据：0198H和0183H如何相加</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可以看出：分2步</span><br><span class="line">1.低位相加；</span><br><span class="line">2.高位相加加上低位相加产生的进位值</span><br></pre></td></tr></table></figure><p>6.和 add ax,bx有相同结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br></pre></td></tr></table></figure><p>可以看出adc指令的目的就是，进行加法的第二步运算</p><p>adc指令和add指令相配合可以对更大的数据进行运算</p><h3 id="编程小任务"><a href="#编程小任务" class="headerlink" title="编程小任务"></a>编程小任务</h3><p>编程计算1EF000H+201000H，结果放在ax（高16位）和bx（低16位）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure><p>adc指令执行后，也可能产生进位值，所以也会对CF位进行设置</p><h2 id="7-sbb指令"><a href="#7-sbb指令" class="headerlink" title="7.sbb指令"></a>7.sbb指令</h2><p>1.sbb是带借位减法指令，它利用了CF位上记录的借位值</p><p>2.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbb操作对象1，操作对象2</span><br></pre></td></tr></table></figure><p>3.功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作对象1=操作对象1-操作对象2-CF</span><br></pre></td></tr></table></figure><p>4..比如：sbb ax，bx</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ax)=(ax)-(bx)-CF</span><br></pre></td></tr></table></figure><p>5.利用sbb指令，我们可以对任意大的数据进行剑法运算</p><p>比如：计算003E100OH-00202000H，结果放在ax 和 bx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H</span><br><span class="line">mov ax,003EH</span><br><span class="line">sub bx,2000H</span><br><span class="line">sbb ax,0020</span><br></pre></td></tr></table></figure><h2 id="8-cmp指令"><a href="#8-cmp指令" class="headerlink" title="8.cmp指令"></a>8.cmp指令</h2><p>1.cmp是比较指令，功能相当于减法指令，只是不保存结果</p><p>2.cmp指令执行后，将对标志寄存器产生影响</p><p>3.其他相关指令通过识别这些被影响的标志寄存器位来得知比较结果</p><p>4.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp 操作对象1 - 操作对象2</span><br></pre></td></tr></table></figure><p>5.功能：计算操作对象1-操作对象2，但并不能保存结果，仅仅根据计算结果对标志寄存器进行设置 </p><p>比如：cmp ax,ax</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZF=1;PF=1;SF=0;CF=0;OF=0</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230415125533748.png" alt="image-20230415125533748"></p><p>6.在使用cmp指令的时候，也包含了2中含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.进行无符号运算</span><br><span class="line">2.进行有符号运算</span><br></pre></td></tr></table></figure><p>对于有符号数的操作，不能说SF=1则操作对象&lt;操作对象2 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(ah)=22H,(bh)=0A0H</span><br><span class="line">则(ah)-(bh)=34-(-96)=130=82H,82Hshi -126的补码，所以SF=1,但是不能说ah&lt;bh</span><br></pre></td></tr></table></figure><p>当产生溢出的时候，就会影响半段</p><p>所以我们就需要一起考虑到溢出的情况，也就是    OF寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.SF=1,OF=0</span><br><span class="line">没有溢出，所以就是小于</span><br><span class="line">2.SF=1,OF=1</span><br><span class="line">有溢出的，所以就是大于</span><br><span class="line">3.SF=0,OF=1</span><br><span class="line">有溢出，所以就是小于</span><br><span class="line">4.SF=0,OF=0</span><br><span class="line">没有溢出，所以就是大于</span><br><span class="line"></span><br><span class="line">总的来说，当有溢出的时候就取反。</span><br></pre></td></tr></table></figure><h2 id="9-检测比较结果的条件转移指令"><a href="#9-检测比较结果的条件转移指令" class="headerlink" title="9.检测比较结果的条件转移指令"></a>9.检测比较结果的条件转移指令</h2><p>1.被cmp指令影响的标志位，这些田间转移指令通常和cmp相配合使用</p><p>cmp指令的比较结果进行转移的指令分为2种</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">对于无符号数的检测</span><br><span class="line">ZF CF</span><br><span class="line">对于有符号数的检测</span><br><span class="line">SF OF ZF</span><br></pre></td></tr></table></figure><p>2.条件转移指令小结【对于无符号】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">je等于则转移ZF=1</span><br><span class="line">jne不等于则转移ZF=0</span><br><span class="line">jb低于则转移CF=1</span><br><span class="line">jnb不低于则转移CF=0</span><br><span class="line">ja高于则转移CF=0,ZF=0</span><br><span class="line">jna不高于则转移CF=1或者ZF=1</span><br></pre></td></tr></table></figure><h3 id="编程训练"><a href="#编程训练" class="headerlink" title="编程训练"></a>编程训练</h3><p>实现如果(ah)=(bh)则(ah)=(ah)+(ah)否则（ah）=（ah）+（bh）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cmp ah,bh</span><br><span class="line">je s</span><br><span class="line">add,ah,bh</span><br><span class="line">jmp short ok</span><br><span class="line">s:add ah,ah</span><br><span class="line">ok:ret</span><br></pre></td></tr></table></figure><p>虽然je的含义是相等则转移，但是它进行的操作的是ZF=1则转移</p><p>je检测的是ZF位置，不管je前面是什么指令，只要CPU实现的时候je指令的时候，ZF=1那么就会发生转移</p><h3 id="课堂练习"><a href="#课堂练习" class="headerlink" title="课堂练习"></a>课堂练习</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">计算出data段种的8的个数</span><br><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db 8,11,8,1,8,5,63,38</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov dax,data</span><br><span class="line">mov dsLax</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,0</span><br><span class="line"></span><br><span class="line">s:cmp byte ptr [bx],8</span><br><span class="line">jne next</span><br><span class="line">inc ax</span><br><span class="line"></span><br><span class="line">next:inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="10-DF标志和串传送指令"><a href="#10-DF标志和串传送指令" class="headerlink" title="10.DF标志和串传送指令"></a>10.DF标志和串传送指令</h2><p>1.flag的第10位是DF，方向标志位</p><p>2.在串 处理指令中，控制每次操作后si和di的增减</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DF=0 , 每次操作后 si di 递增</span><br><span class="line">DF=1 ， 每次操作后 si di 递减 </span><br></pre></td></tr></table></figure><p>3.格式    movsb</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">功能（以字节位单位传送）</span><br><span class="line">1.((es)*16+(di))=((ds)*16+(si))</span><br><span class="line">如果DF=0 DF=1 </span><br></pre></td></tr></table></figure><p>4.格式    movsw</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以字来传递</span><br></pre></td></tr></table></figure><p>5.movsb和movsw进行的是串传送操作中第一个不走，一般来说，movsb和movsw都和rep配合使用，格式rep movsb</p><p>rep的作用是根据cx的值，重复执行后面串传送指令</p><p>由于没执行依次movsb si di都会变化，则rep movsb就可以循环实现(cx)个字符的传送</p><p>6.如何修改DF?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cld 将DF设置成0</span><br><span class="line">std 将DF设置成1</span><br></pre></td></tr></table></figure><p>7.练习一手</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">data segment</span><br><span class="line">db &#x27;welcome to masm!&#x27;</span><br><span class="line">db 16 dup(0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov dx,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov es,ax</span><br><span class="line">mov di,16</span><br><span class="line"></span><br><span class="line">mov cx,16</span><br><span class="line"></span><br><span class="line">cld;设置DF=0</span><br><span class="line">rep movsb;1.((es)*16+(di))=((ds)*16+(si))</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">mov 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>11.pushf 和 popf</p><p>1.pushf：将标志寄存器的值压入栈中</p><p>popf：从栈中弹出数据，送入标志寄存器中</p><p>2.pushf和popf，为直接访问标志寄存器提供了一种方法</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-CALL和RET指令（10）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-10-CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-10-CALL%E5%92%8CRET%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p> 1.程序之间的加载和返回</p><p>2.call和ret指令都是转移指令，它们大都修改IP，或者同时修改CS和IP</p><p>3.它们经常被同用来实现自程序的设计</p><h2 id="1-ret和retf-指令"><a href="#1-ret和retf-指令" class="headerlink" title="1.ret和retf  指令"></a>1.ret和retf  指令</h2><p>1.ret指令是用栈中的数据，修改IP的内容，从而实现进转移</p><p>2.在CPU执行ret指令的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.(IP)=((SS)*16+(SP))</span><br><span class="line">2.(sp)=(sp)+2</span><br><span class="line">IP中的值变成ss:[sp]中的</span><br><span class="line">sp+2【】</span><br><span class="line"></span><br><span class="line">pop ip</span><br></pre></td></tr></table></figure><p>3.retf指令用栈中的数据，修改CS和IP的内容，从而实现远转移</p><p>4.在CPU执行retf指令的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">(IP)=((ss)*16+(sp))</span><br><span class="line">(sp)=(sp)+2</span><br><span class="line">2.</span><br><span class="line">(cs)=((ss)*16+(sp))</span><br><span class="line">(sp)=(sp)+2</span><br><span class="line">低地址放的是ip，高地址放cs，都是字型单位</span><br><span class="line"></span><br><span class="line">pop ip</span><br><span class="line">pop cs </span><br></pre></td></tr></table></figure><h2 id="2-call指令"><a href="#2-call指令" class="headerlink" title="2.call指令"></a>2.call指令</h2><p>1.call指令经常和ret指令配合使用，因此CPU执行call指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.当前的IP或者CS和IP压入栈中</span><br><span class="line">2.转移(jmp)</span><br></pre></td></tr></table></figure><p>2.call指令不能实现段转移，除此之外，call指令实现转移的方法和jmp指令的原理相同</p><h2 id="3-依据位移进行转移的call指令"><a href="#3-依据位移进行转移的call指令" class="headerlink" title="3.依据位移进行转移的call指令"></a>3.依据位移进行转移的call指令</h2><p>1.格式：call 标号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">将当前的IP压入栈后，转移到标号处指令指令</span><br><span class="line">相当于：</span><br><span class="line">push IP</span><br><span class="line">jmp near ptr 标号</span><br></pre></td></tr></table></figure><p>2.CPU</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.  (SP)=(SP)-2</span><br><span class="line">((ss)*16+(sp))=(IP);这一步感觉就像是：push 当前的IP[这么理解就错了]【它是push  call 指令的下一条指令的IP】</span><br><span class="line">2.(IP)=(IP)+16位位移</span><br><span class="line">;这里和jmp的依据位移进行转移差不多也就是</span><br><span class="line">“标号”处的地址-jmp指令后的第一个字节的地址;相互减</span><br><span class="line">这里必须是16位的，不能是8位的哦</span><br><span class="line">16位的范围</span><br><span class="line">-32768~32767</span><br></pre></td></tr></table></figure><h2 id="4-转移的目的地址在指令中的call指令"><a href="#4-转移的目的地址在指令中的call指令" class="headerlink" title="4.转移的目的地址在指令中的call指令"></a>4.转移的目的地址在指令中的call指令</h2><p>1.call far ptr 标号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">1.</span><br><span class="line">(sp)=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(cs)</span><br><span class="line">(sp)=(sp-2)</span><br><span class="line">((ss)*16+(sp))=(ip)</span><br><span class="line">2.</span><br><span class="line">(cs)=标号处的段地址</span><br><span class="line">(ip)=标号所在的偏移地址</span><br><span class="line">3.</span><br><span class="line">push CS</span><br><span class="line">push IP</span><br><span class="line">jmp far ptr 标号</span><br></pre></td></tr></table></figure><h2 id="5-转移地址在寄存器中的call指令"><a href="#5-转移地址在寄存器中的call指令" class="headerlink" title="5.转移地址在寄存器中的call指令"></a>5.转移地址在寄存器中的call指令</h2><p>1.格式：call 16位寄存器</p><p>2.功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">()=(sp)-2</span><br><span class="line">((ss)*16+(sp))=(ip)</span><br><span class="line">(ip)=(16位寄存器)</span><br><span class="line"></span><br><span class="line">push IP</span><br><span class="line">jmp 16位寄存器</span><br></pre></td></tr></table></figure><h2 id="6转移地址在内存中的call指令"><a href="#6转移地址在内存中的call指令" class="headerlink" title="6转移地址在内存中的call指令"></a>6转移地址在内存中的call指令</h2><p>1.call word ptr 内存单元地址</p><p>安装字型的数据来索引【短转移】 </p><p>2.call dword ptr 内存单元地址</p><p>高cs 低 ip </p><h2 id="7-call和ret的配合使用"><a href="#7-call和ret的配合使用" class="headerlink" title="7.call和ret的配合使用"></a>7.call和ret的配合使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">db 8 dup(0)1000:0000   00 00 00 00 00 00 00 00</span><br><span class="line">db 8 dup(0)1000:0008   00 00 00 00 00 00 00 00</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:mov ax,stack1001:0000B8 00 10 </span><br><span class="line">mov ss,ax1001:00038E D0</span><br><span class="line">mov sp,161001:0005BC 10 00</span><br><span class="line">mov ax,10001001:0008B8 E8 03</span><br><span class="line">call s1001:000BE8 05 00</span><br><span class="line">mov ax,4c00H1001:000EB8 00 4C</span><br><span class="line">int 21h1001:0011CD 21</span><br><span class="line">s:add ax,ax1001:001303 C0</span><br><span class="line">ret1001:0015C3</span><br><span class="line">code ends</span><br><span class="line">endstart</span><br></pre></td></tr></table></figure><p>让我们来看看程序的主要执行过程</p><p>1，前三条指令执行后，栈的情况如下：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413204516225.png" alt="image-20230413204516225"></p><p>2.call 指令读入后，(IP)=00EH，cpu指令缓冲器中的代码是     B8 05 00</p><p>cpu执行B8 05 00；首先栈中的变化为： </p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413204646240.png" alt="image-20230413204646240"></p><p>然后，(IP)=(IP)+0005=0013H</p><p>3.CPU从cs:0013H处（即标号s处）开始执行</p><p>4.ret指令读入后：（IP）=0016H【IP永远都是指向的下一个指令，将要执行的IP】，cpu指令缓冲区中的代码为C3</p><p>​    当CPU执行C3，相当于进行pop IP，执行后，栈中的情况为</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230413205239588.png" alt="image-20230413205239588"></p><p>（IP）=000EH</p><p>5.CPU回到cs:000EH处(即call指令后面的指令处)继续执行</p><p>从上面的讨论中我们发现，可以写一个具有一定功能的程序段，我们称其为子程序，在需要的时候，用call指令转去执行</p><p>可是执行完子程序后，如何让CPU接着call指令向下执行？</p><p>没错就是ret</p><p>call指令后面的指令的地址存储在栈中，所以可以在子程序后面使用ret指令，用栈中的数据设置IP的值，从而转到call指令后面的代码继续执行</p><p>这样，我们可以利用call和ret来实现子程序的机制【函数】</p><h2 id="8-mul-指令"><a href="#8-mul-指令" class="headerlink" title="8.mul 指令"></a>8.mul 指令</h2><p>1.因下面要用到，所以我们就来介绍一下mul指令，mul是乘法指令，使用mul做乘法的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.相乘的2个数，要么都是8位，要么都是16位</span><br><span class="line">8位：al中和8位寄存器或内存字节单元中</span><br><span class="line">16位：ax中和16位寄存器或内存字单元中</span><br></pre></td></tr></table></figure><p>2.结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8位：AX中</span><br><span class="line">16位：DX（高位）和AX（低位）中</span><br></pre></td></tr></table></figure><p>3.格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mul reg【寄存器】</span><br><span class="line">mul 内存单元</span><br></pre></td></tr></table></figure><p>1.mul byte ptr ds:[0]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8位的</span><br><span class="line">含义：(ax)=(al)*((ds)*16+0)</span><br><span class="line">乘数一个由mul给处一个是在al中</span><br></pre></td></tr></table></figure><p>2.mul word ptr [bx+si+8]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">16位：</span><br><span class="line">含义位：</span><br><span class="line">(ax)=(ax)*((ds)*16+(bx)+8)结果的低16位</span><br><span class="line">(dx)=(ax)*((ds)*16+(bx)+8)结果的高16位</span><br><span class="line">乘数一个由mul给出一个由ax中</span><br></pre></td></tr></table></figure><p>比如：100*10</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov bl,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure><p>比如：100*10000</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,100</span><br><span class="line">mov bx,10000</span><br><span class="line">mul bx</span><br></pre></td></tr></table></figure><h2 id="9-模块化程序设计"><a href="#9-模块化程序设计" class="headerlink" title="9.模块化程序设计"></a>9.模块化程序设计</h2><p>从上面我们看到，call和ret指令共同支持了汇编语言编程中的模块化设计，在实际编程中，程序的模块化是必不可少的</p><p>用call和ret指令==【面对过程的思想】</p><h2 id="10-参数和结果传递的问题"><a href="#10-参数和结果传递的问题" class="headerlink" title="10.参数和结果传递的问题"></a>10.参数和结果传递的问题</h2><p>子程序一般都要根据提供的参数处理一定的事务，处理后，将结果(返回值)提供给调用者</p><p>其实，我们讨论参数和返回值传递的问题，实际上是在探讨，应该如何存储子程序需要的参数和产生的返回值</p><p>我们设计一个子程序，可以根据提供的N，来计算N的3次方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.我们将这个参数N存储在什么地方？</span><br><span class="line">很显然，用寄存器来存储。可以将参数放到bx中</span><br><span class="line">2.计算得到的数值，我们存储在什么地方？</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cube:mov ax,bx</span><br><span class="line">mul bx</span><br><span class="line">mul bx                       </span><br><span class="line">ret</span><br></pre></td></tr></table></figure><h2 id="11-批量数据的传递"><a href="#11-批量数据的传递" class="headerlink" title="11.批量数据的传递"></a>11.批量数据的传递</h2><p>前面的例程中，子程序cube只有一个参数放在bx中。如果有两个参数，那么可以用两个寄存器来放，可是如果需要传递的数据有3个4个甚至多到N个呢，我们应该如何存放呢？</p><p>这个时候，我们将数据放在内存中，然后它们所在内存空间的首地址放在寄存器中，传递给需要的子程序。对于具有批量数据的返回结果，也可用同样的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">db &#x27;conversation&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:movax,data</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0;ds:[si]指向字符串（批量数据）所在空间的首地址</span><br><span class="line">mov cx,12;cx 存放字符串的长度</span><br><span class="line">call capital</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">capital:and byte ptr [si],11011111B;将ds:si所指单元中的字母转化为大写</span><br><span class="line">inc si;ds:si 指向下一个单元</span><br><span class="line">loop capital</span><br><span class="line">ret</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>注意，除了用寄存器传递参数外，还有一种通用的方法是用栈来传递参数。</p><h2 id="12-寄存器冲突的问题-10-12-play"><a href="#12-寄存器冲突的问题-10-12-play" class="headerlink" title="12.寄存器冲突的问题[10.12.play]"></a>12.寄存器冲突的问题[10.12.play]</h2><p>设计一个子程序，功能：将一个全是字母，以0结尾的字符串，转化为大写</p><p>程序要处理的字符串以0作为结尾符，这个字符串可以定义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db &#x27;conversation&#x27;,0</span><br></pre></td></tr></table></figure><p>应用这个子程序，字符串的内容后面一定要有一个 0 ，标记字符串的结束。子程序可以依次读取每一个字符进行检测，如果不是0 ，就进行大写的转化；如果是0，就结束处理。由于可通过检测0而知道是否处理完这整个字符串，所以子程序不需要字符串的长度作为参数。可以用jcxz来检测0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">capital:push cx</span><br><span class="line">push si</span><br><span class="line"></span><br><span class="line">mov cl,[si]</span><br><span class="line">mov ch,0</span><br><span class="line">jcxz ok</span><br><span class="line">and byte ptr [si],11011111B</span><br><span class="line">inc si</span><br><span class="line">jmp short capital</span><br><span class="line"></span><br><span class="line">ok:pop si</span><br><span class="line">pop cx</span><br><span class="line">ret</span><br><span class="line">这个就是说cl是data中的数据，当访问到0的时候就去运行了jcxz</span><br></pre></td></tr></table></figure><h2 id="实验10"><a href="#实验10" class="headerlink" title="实验10"></a>实验10</h2><p>编写子程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXP 自己查看</span><br></pre></td></tr></table></figure><h2 id="自我总结一下最近学的把"><a href="#自我总结一下最近学的把" class="headerlink" title="自我总结一下最近学的把"></a>自我总结一下最近学的把</h2><p>1.乘法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">首先乘法：mul 乘数2</span><br><span class="line">乘数1，是在寄存器或者内存单元中</span><br><span class="line">乘数2如果是</span><br><span class="line">8位：得到的是一个16位的数，放在ax中</span><br><span class="line">16位：得到的是一个32位的数，放在dx【高】和ax【低】</span><br></pre></td></tr></table></figure><p>2.除法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">然后是除法：div 除数</span><br><span class="line">被除数可能是ax也可能是dx和ax</span><br><span class="line"></span><br><span class="line">当除数是8位的时候，就调用的是ax</span><br><span class="line">当除数是16位的时候，就调用dx和ax</span><br><span class="line"></span><br><span class="line">8位的时候，al中放的是商ah中放的是余数</span><br><span class="line">16位的时候，ax中放的是商dx中放的是余数</span><br><span class="line"></span><br><span class="line">这个8位还是16位</span><br><span class="line">看的是寄存器或者是内存空间的大小</span><br></pre></td></tr></table></figure><p>3.循环的使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.已知或者能求出循环次数的循环</span><br><span class="line">用 cx 和 loop</span><br><span class="line">2.未知循环次数的循环</span><br><span class="line">用cl和ch的结合 或者 cx 和jcxz</span><br></pre></td></tr></table></figure><p>loop 如何使用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个很简单，设定循环的次数，cx</span><br><span class="line">写入代码 </span><br><span class="line">loop 标号</span><br><span class="line">就好了</span><br></pre></td></tr></table></figure><p>jcxz 如何使用呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">这个比较复杂，我已知2种办法</span><br><span class="line">1.对于 对字符串的处理【这里需要设置字符串的结束条件是0】</span><br><span class="line">这样可以设置</span><br><span class="line">s:mov ch,0</span><br><span class="line">mov cl,ds:[si]</span><br><span class="line">jcxz 标号【可以跳出去，这里是跳出循环】</span><br><span class="line">代码</span><br><span class="line">jmp short s【写了这个过后，它就会一直循环到标号s处，知道某个条件也就是cl=0的时候就会从jcxz挑走】</span><br><span class="line"></span><br><span class="line">2.对于除法，需要取出某个数种的每一个数的时候</span><br><span class="line">可以这样设置</span><br><span class="line">s:div 某个16位mov ch,0</span><br><span class="line">mov cx,ax    div 某个8位</span><br><span class="line">          mov cl,al</span><br><span class="line">          </span><br><span class="line">       jcxz 标号</span><br><span class="line">       </span><br><span class="line">       jmp short s</span><br><span class="line">       </span><br><span class="line">总的来说，在标号和 jmp short 标号 中间的都是循环语句，在中间的jcxz在满足条件的时候才会跳出去</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-转移指令的原理（9）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-9-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-9-%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4%E7%9A%84%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>1.8086CPU的转移指令分为以下几个类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.无条件转移指令【jmp】</span><br><span class="line">2.条件转移指令</span><br><span class="line">3.循环指令【loop】</span><br><span class="line">4.过程</span><br><span class="line">5.中断</span><br></pre></td></tr></table></figure><h2 id="1-操作符offset"><a href="#1-操作符offset" class="headerlink" title="1.操作符offset"></a>1.操作符offset</h2><p>1.offset：伪指令，取得标号的偏移地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,offset start ;相当于mov ax,0 就是取得start这个标号的偏移地址</span><br><span class="line">s:mov ax,offset s;相当于mov ax,3 也是去取得了s这个标号的偏移地址 </span><br></pre></td></tr></table></figure><p>小小的练习</p><p>填写指令，使改程序在运行中将s处的一条指令复制到s0处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">s:mov ax,bx;mov ax,bx的机器码占2个字节</span><br><span class="line">mov si,offset s</span><br><span class="line">mov di,offset s0</span><br><span class="line">__________</span><br><span class="line">__________</span><br><span class="line"></span><br><span class="line">s0:nop</span><br><span class="line">nop</span><br><span class="line">codesg ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure><p>分析一下咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.s和s0处的指令所在的内存地址是多少？</span><br><span class="line">cs:offset s 和 cs:offset s0</span><br><span class="line">因为这个指令是在cs:ip下的咯</span><br><span class="line">2.将s处的指令复制到s0处，将cs:offset s处的数据复制到cs:offset s0处</span><br><span class="line">因为它们底层的代码【二进制】是一样的</span><br><span class="line">3.段地址已知在cs中，偏移地址offset s 和 pffset s0 送入 si和di中</span><br><span class="line"></span><br><span class="line">4.要复制的数据长度有多长？</span><br><span class="line">mov ax,bx</span><br><span class="line">    指令的 长度是2个字节</span><br></pre></td></tr></table></figure><p>程序来咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">s:mov ax,bx;mov ax,bx的机器码占2个字节</span><br><span class="line">mov si,offset s</span><br><span class="line">mov di,offset s0</span><br><span class="line">mov ax,cs:[si]</span><br><span class="line">mov cs:[di],ax</span><br><span class="line"></span><br><span class="line">s0:nop</span><br><span class="line">nop</span><br><span class="line">codesg ends</span><br><span class="line">end s</span><br></pre></td></tr></table></figure><h2 id="2-jmp指令"><a href="#2-jmp指令" class="headerlink" title="2.jmp指令"></a>2.jmp指令</h2><p>1.jmp为无条件转移，可以只修改IP，也可以同时修改CS和IP</p><p>2.jmp指令要给处俩种信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.转移的目的地址</span><br><span class="line">2.转移的距离（段间转移，段内段转移，段内近转移）</span><br></pre></td></tr></table></figure><h2 id="3-依据位移进行转移的jmp指令"><a href="#3-依据位移进行转移的jmp指令" class="headerlink" title="3.依据位移进行转移的jmp指令"></a>3.依据位移进行转移的jmp指令</h2><p>1.jmp short 标号(转到标号处执行指令)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这种格式的jmp指令实现的是段内短转移，它对IP的修改范围是-128~127，也就是说，它向前可以越过128个字节，向后可以最多越过127个字节【越后面数越大】</span><br></pre></td></tr></table></figure><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg;左边的程序执行后，ax种的值为1，因为执行</span><br><span class="line">csdesg segment;jmp short s 后，越过了add ax,1 ip指向</span><br><span class="line">start:mov ax,0;了标号s处的inc ax。也就是说程序只进行了</span><br><span class="line">jmp short s;一次 ax加1操作</span><br><span class="line">add ax,1</span><br><span class="line">s:inc ax;在这个jmp中所对应的机器码是没有对应的地址的</span><br><span class="line">codesg ends;而是有偏移地址，某个数【执行了add IP,某个数】</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>2.jmp short s指令的读取和执行过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.(cs)=0BBDH,(IP)=0006,CS:IP指向EB 03(jmp short s 的机器码)</span><br><span class="line">2.读取指令码 EB 03 进入指令缓冲器；</span><br><span class="line">3.(IP)=(IP)+所读指令的长度==&gt;(IP)+2=0008,cs:ip指向add ax,1</span><br><span class="line">4.CPU指向指令缓冲器中的指令EB 03;</span><br><span class="line">5.指令EB 03 执行后，(IP)=000BH,CS:IP指向 inc ax</span><br></pre></td></tr></table></figure><p>3.实际上，指令“jmp short 标号”的功能为(IP)=(IP)+8位位移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.8位位移=“标号”处的地址-jmp指令后的第一个字节的地址;相互减</span><br><span class="line">2.short 指明此处的位移为8位位移</span><br><span class="line">3.8位位移的范围为-128~127，用补码表示</span><br><span class="line">4.8位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">！！它不给地址，只给偏移地址！！</span><br></pre></td></tr></table></figure><p>4.还有一种和“jmp short 标号”功能相近的指令格式</p><p>==&gt;jmp near ptr 标号</p><p>功能就是</p><p>IP=IP+16位位移</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.16位位移=“标号”处的地址 - jmp指令后的第一个字节的地址</span><br><span class="line">2.near ptr 指明此处的16位位移，进行的是段内进转移</span><br><span class="line">3.16位位移的范围：-32768~32767，用补码表示</span><br><span class="line">4.16位位移由编译程序在编译时算出</span><br></pre></td></tr></table></figure><h2 id="4-转移的目的地址在指令中的jmp指令"><a href="#4-转移的目的地址在指令中的jmp指令" class="headerlink" title="4.转移的目的地址在指令中的jmp指令"></a>4.转移的目的地址在指令中的jmp指令</h2><p>1.前面讲的jmp指令，其对应的机器码中并没有转移目的的地址，而是相对于当前IP的转移位移</p><p>2.现在要有一个新的</p><h4 id="jmp-far-ptr-标号：实现的是段间转移，又称为远转移"><a href="#jmp-far-ptr-标号：实现的是段间转移，又称为远转移" class="headerlink" title="jmp far ptr 标号：实现的是段间转移，又称为远转移"></a>jmp far ptr 标号：实现的是段间转移，又称为远转移</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.(CS)=标号所在段的段地址</span><br><span class="line">2.(IP)=标号所在段中的偏移地址</span><br><span class="line">3.far ptr 指明了指令用标号的段地址和偏移地址修改CS和IP</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,0</span><br><span class="line">mov bx,0</span><br><span class="line">jmp far ptr s;jmp所对应的机器码其中是包含转移的目标地址的</span><br><span class="line">db 256 dup(0)</span><br><span class="line">s:add ax,1</span><br><span class="line">inc ax</span><br><span class="line">codesg ends</span><br><span class="line">end start </span><br></pre></td></tr></table></figure><h2 id="5-转移地址在寄存器中的jmp指令"><a href="#5-转移地址在寄存器中的jmp指令" class="headerlink" title="5.转移地址在寄存器中的jmp指令"></a>5.转移地址在寄存器中的jmp指令</h2><h4 id="1-指令格式：jmp-16位的寄存器"><a href="#1-指令格式：jmp-16位的寄存器" class="headerlink" title="1.指令格式：jmp 16位的寄存器"></a>1.指令格式：jmp 16位的寄存器</h4><p>功能： IP = (16位寄存器)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp ax</span><br></pre></td></tr></table></figure><h2 id="6-转移地址在内存中的jmp指令有2种格式"><a href="#6-转移地址在内存中的jmp指令有2种格式" class="headerlink" title="6.转移地址在内存中的jmp指令有2种格式"></a>6.转移地址在内存中的jmp指令有2种格式</h2><h4 id="1-jmp-word-ptr-内存单元地址【段内转移】"><a href="#1-jmp-word-ptr-内存单元地址【段内转移】" class="headerlink" title="1.jmp word ptr 内存单元地址【段内转移】"></a>1.jmp word ptr 内存单元地址【段内转移】</h4><p>功能：从内存单元地址开始存放着一个字，是转移的目的的偏移地址</p><p>内存单元地址可用寻址方式的任一格式给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123Hmov ax,0123H</span><br><span class="line">mov ds:[0],axmov [bx],ax</span><br><span class="line">jmp word ptr ds:[0] jmp word ptr [bx]</span><br><span class="line">执行后(IP)=0123H执行后(IP)=0123H</span><br></pre></td></tr></table></figure><h4 id="2-jmp-dword-ptr-内存单元地址【段间转移】"><a href="#2-jmp-dword-ptr-内存单元地址【段间转移】" class="headerlink" title="2.jmp dword ptr 内存单元地址【段间转移】"></a>2.jmp dword ptr 内存单元地址【段间转移】</h4><p>功能：从内存单元地址处开始存放着2个字，高地址处的字是转移的目的段地址，低地址处是转移的目的的偏移地址</p><p>​    (CS)=(内存单元地址+2)</p><p>​     (IP)=(内存单元地址)</p><p>内存 单元可以由寻址的方式的任意格式给出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">jmp dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">执行后【高地址种是cs 低地址种是ip】</span><br><span class="line">（CS）=0</span><br><span class="line">（IP）=0123</span><br></pre></td></tr></table></figure><h2 id="7-jcxz指令"><a href="#7-jcxz指令" class="headerlink" title="7.jcxz指令"></a>7.jcxz指令</h2><p>1.jcxz指令为有条件转移指令，所有的有条件跳转指令都是短转移，在对应的机器码中包含转移的位移，而不是目的地址。对IP的修改范围都是-128~127</p><p>2.指令格式：jcxz 标号</p><p>：如果（cx）=0 则跳转到标号处执行</p><p>3.jcxz 标号 指令操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.当(cx)=0时，（ip）=（ip）+8位位移</span><br><span class="line">1.8位位移=“标号”处的地址 - jcxz指令后的第一个字节的地址</span><br><span class="line">2.8位位移的范围是-128~127 用补码表示</span><br><span class="line">3.8位位移由编译程序在编译时算出</span><br><span class="line"></span><br><span class="line">2.当(cs)！=就什么也不做</span><br></pre></td></tr></table></figure><p> 相当于</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if((cx)==0)&#123;</span><br><span class="line">jmp short 标号;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="8-loop指令"><a href="#8-loop指令" class="headerlink" title="8.loop指令"></a>8.loop指令</h2><p>1.loop指令为循环指令，所有的循环指令都是短位移，在对应的机器码中包含转移的位移，而不是目的地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loop 是用于知道循环次数的循环</span><br><span class="line">(cx)=(cx)-1 </span><br><span class="line">jcxz 用于不知道循环次数的循环</span><br></pre></td></tr></table></figure><h2 id="9-根据位进行转移的意义"><a href="#9-根据位进行转移的意义" class="headerlink" title="9.根据位进行转移的意义"></a>9.根据位进行转移的意义</h2><p>1.前面讲到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp short 标号</span><br><span class="line">jmp near ptr 标号</span><br><span class="line">jcxz 标号</span><br><span class="line">loop 标号</span><br></pre></td></tr></table></figure><p>这几种汇编指令，它们对IP的修改是根据转移目的地址和转移起始地址之间的位移来进行的。</p><p>在它们对应的机器码中不包含位移的目的地址，而包含的是到目的地址的位移距离</p><p>2.这样设计是为了，方便了程序段在内存中的浮动装配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    mov cx,6B9 06 00</span><br><span class="line">    mov ax,10B8 10 00</span><br><span class="line">s:add ax,ax01 C0</span><br><span class="line">loop sE2 FC</span><br></pre></td></tr></table></figure><p>3.这段程序在内存中的不同位置都可以正确执行，因为loop s 在执行时只涉及到s 的位移(-4 ， 前移4个字节，补码表示为 FCH)而不是s的地址</p><p>4.如果loop s的机器码中包含的是s的地址，则就对程序段在内存中的偏移地址就有了严格的限制，就不能封装起来放在其他地方使用</p><p>5.因为机器码中包含的是s的地址，如果s处的指令不在目的地址处，程序的执行就会出错</p><p>我们之前在第二章中讲到的</p><p>jmp cs:ip</p><p>这种是在debug中的指令，汇编编译器并不认识</p><h2 id="实验8"><a href="#实验8" class="headerlink" title="实验8"></a>实验8</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exp8.exe</span><br></pre></td></tr></table></figure><h2 id="实验九"><a href="#实验九" class="headerlink" title="实验九"></a>实验九</h2>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-数据处理的俩个基本方法（8）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-8-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-8-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%9F%BA%E6%9C%AC%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>1.描述性符号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.reg 来表示一个寄存器</span><br><span class="line">2.sreg 来表示一个段寄存器</span><br></pre></td></tr></table></figure><h2 id="1-bx-si-di-bp"><a href="#1-bx-si-di-bp" class="headerlink" title="1.bx,si,di,bp"></a>1.bx,si,di,bp</h2><p>1.对 bx si di 进行一下小小的总结</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在8086CPU中，只有【bx,bp,si,di】可以用在[]中来进行内存单元的寻址</span><br><span class="line"></span><br><span class="line">[ax]这样是错的！！！！</span><br></pre></td></tr></table></figure><p>2.在[]中，这4个寄存器可以单个出现，或者只能有4种组合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[bx+si];[bx+di]</span><br><span class="line">[bp+si];[bp+di]</span><br><span class="line"></span><br><span class="line">si和di 不行</span><br><span class="line">bx和bp 不行</span><br></pre></td></tr></table></figure><p>3.在[]内使用bp和bx的区别</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果是使用[bx]则默认段地址是ds</span><br><span class="line">ds是数据段地址</span><br><span class="line">如果使用[bp]则默认段地址是ss</span><br><span class="line">ss是栈段地址</span><br><span class="line">所以这个bp和sp类似咯</span><br></pre></td></tr></table></figure><h2 id="2-机器指令处理的数据在什么地方"><a href="#2-机器指令处理的数据在什么地方" class="headerlink" title="2.机器指令处理的数据在什么地方"></a>2.机器指令处理的数据在什么地方</h2><p>1.绝大部分的机器指令都是进行数据处理的指令，处理大致可分为</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取，写入，运算</span><br></pre></td></tr></table></figure><p>2.在机器指令这一层来讲，并不关系数据的值是多少，而是关心指令执行前一刻，它将要处理的数据所在的位置</p><p>3.所要处理的数据可以在三个地方</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.CPU内部</span><br><span class="line">2.内存</span><br><span class="line">3.端口</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">汇编指令命令执行前数据的位置</span><br><span class="line">mov bx,[0]内存, ds:0单元</span><br><span class="line">mov bx,axCPU内部,ax寄存器</span><br><span class="line">mov bx,1CPU内部,指令缓冲区</span><br></pre></td></tr></table></figure><p>4.在汇编语言种有3个概率来表达数据的位置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.立即数(idata)</span><br><span class="line">CPU的指令缓冲区</span><br><span class="line">2.寄存器()</span><br><span class="line">CPU内部的寄存器种</span><br><span class="line">3.段地址(SA)和偏移地址(EA)</span><br><span class="line">内存中</span><br><span class="line">可以用ds:[这个里面不能写idata]</span><br></pre></td></tr></table></figure><h2 id="3-汇编语言中数据位置的表达"><a href="#3-汇编语言中数据位置的表达" class="headerlink" title="3.汇编语言中数据位置的表达"></a>3.汇编语言中数据位置的表达</h2><p>1.显性的给出段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,ds:[sp]</span><br></pre></td></tr></table></figure><p>2.使用默认的段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]默认就是ds:[bx]</span><br></pre></td></tr></table></figure><h2 id="4-寻址方式"><a href="#4-寻址方式" class="headerlink" title="4.寻址方式"></a>4.寻址方式</h2><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230412112201335.png" alt="image-20230412112201335"></p><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CPU首先是读取：</span><br><span class="line">也就是CS:IP 通过地址加法器，然后走地址总线去找到相对应的地址，拿出里面的指令【机器码】【A1E100啥的】，把这个东西放入指令缓冲区。</span><br><span class="line">CPU就会对这个机器码读取</span><br><span class="line">然后去进行通过这个机器码读取出来的命令来工作</span><br><span class="line">工作完成后，又会去读取CS:IP【这个时候ip是递增后的】</span><br></pre></td></tr></table></figure><h2 id="5-指令要处理的数据有多长？"><a href="#5-指令要处理的数据有多长？" class="headerlink" title="5.指令要处理的数据有多长？"></a>5.指令要处理的数据有多长？</h2><p>1.有2中 byte 和 word 型的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.通过寄存器名字来指明需要处理数据的尺寸</span><br><span class="line">ax bx </span><br><span class="line">al </span><br><span class="line"></span><br><span class="line">2.在没有寄存器名存在的情况下，用操作符X ptr指明内存单元的长度，X在汇编指令中可以为 word 或 byte</span><br></pre></td></tr></table></figure><p>2.型方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov word ptr ds:[0],1</span><br><span class="line">inc word ptr [bx]===&gt;这个是内存单元 ds:[bx]</span><br><span class="line">inc word ptr ds:[0]</span><br><span class="line"></span><br><span class="line">inc byte ptr [bx]</span><br></pre></td></tr></table></figure><p>3.在没有寄存器参与的内存单元访问指令中，用word ptr 或者byte ptr 来指明需要访问的内存单元</p><p>否则CPU很shabi</p><h2 id="6-寻址方式的综合应用"><a href="#6-寻址方式的综合应用" class="headerlink" title="6.寻址方式的综合应用"></a>6.寻址方式的综合应用</h2><p>这里有一个例子，自己去看书</p><p>1.我们可以看到，8086CPU提供了如[bx+si+idata]的寻址方式为结构化数据的处理提供了方便</p><p>2.使得我们可以在编程的时候，从结构化的角度去看待所要处理的数据</p><p>3.从上面我们就可以看到，一个结构化的数据包含了多个数据项，而数据项的类型又不相同，又的是字型数据，有的是字节型数据，有的和是数组【字符串】</p><p>4.所以，一般来说，我们可以用[bx + idata+si]的方式来访问结构体中的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用bx来定位整个结构体，用idata来定位结构体中的某一个数据项，用si定位数组项中的每个元素</span><br><span class="line">为此，汇编语言提供了[bx].idata[bx]idata[si]的方式</span><br></pre></td></tr></table></figure><p>5.所以在C语言中我们看到的 dec.cp[i];dec是一个变量名，指明了结构体变量的地址，cp是一个名称，指明了数据项cp的地址，而用i来定位cp中的每一个字符</p><p>在汇编语言中：bx.10H[si]</p><h2 id="7-div指令"><a href="#7-div指令" class="headerlink" title="7.div指令"></a>7.div指令</h2><p>1.div指令就是÷</p><p>在使用div作为除法的时候</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">除数：8位或16位，在寄存器或者内存单元中</span><br><span class="line">被除数：（默认）放在ax或者dx和ax中</span><br><span class="line"></span><br><span class="line">被除数是用AX还是DX+AX是看除数的大小</span><br><span class="line"></span><br><span class="line">除数被除数</span><br><span class="line">8位16位(AX)</span><br><span class="line">16位32位(DX+AX)【这里的+不是加而是放在前面】</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">运算 8位  16位</span><br><span class="line">商  ALAX</span><br><span class="line">余数    AHDX</span><br></pre></td></tr></table></figure><p>格式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.div reg</span><br><span class="line">2.div 内存单元</span><br></pre></td></tr></table></figure><p>现在我们可以用多种方法来表示一个内存单元咯</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">div byte ptr ds:[0]</span><br><span class="line">含义就是：</span><br><span class="line">(al)=(ax)/((ds)*16+0)的商</span><br><span class="line">(ah)=(ax)/((ds)*16+0)的余数</span><br><span class="line">div后面的内存单元或者寄存器，里面的数据都是当作被除数来解析</span><br><span class="line"></span><br><span class="line">div word ptr es:[0]</span><br><span class="line">含义为：</span><br><span class="line">(ax)=[(dx)*10000H+(ax)]/((ds)*16+0)的商</span><br><span class="line">(dx)=[(dx)*10000H+(ax)]/((ds)*16+0)的余数</span><br></pre></td></tr></table></figure><p>实现：计算100001/100</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">;首先100001是186a1H   大于FFFFH所以需要用dx和ax</span><br><span class="line"></span><br><span class="line">mov dx,1</span><br><span class="line">mov ax,86a1H</span><br><span class="line">mov bx,100;会自动的选取ax和dx来进行除法</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure><h2 id="8-伪指令dd"><a href="#8-伪指令dd" class="headerlink" title="8.伪指令dd"></a>8.伪指令dd</h2><p>1.前面我们学过db 和 dw 来定义字型数据和字型数据</p><p>dd是用来定义dword(double word双字节)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CPU是64位，操作系统要64位，在操作系统的软件是64位</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data segment</span><br><span class="line">db 1</span><br><span class="line">dw 1</span><br><span class="line">dd 1</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">在data 段中定义了3个数据</span><br><span class="line">第一个数据是 01H 在data:0处，占用1个字节</span><br><span class="line">第二个数据是 0001H 在data:1处，占2个字节</span><br><span class="line">第三个数据是00000001H 在data:3处，占4个字节</span><br></pre></td></tr></table></figure><p>问题：8.1计算data段中第一个数据/第二个数据后的结果，商放在第三个数据存储单元中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data segment </span><br><span class="line">dd 100001</span><br><span class="line">dw 100</span><br><span class="line">dw 0</span><br><span class="line">data ends</span><br></pre></td></tr></table></figure><h2 id="9-dup"><a href="#9-dup" class="headerlink" title="9.dup"></a>9.dup</h2><p>1.dup 是一个操作符号，在汇编语言中和db ，dw ，dd 等一样，都是由编译器识别处理的符号</p><p>2.它和db dw dd 等数据定义伪指令配合使用，用来进行数据的重复</p><p>3.实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.db 3 dup(0)</span><br><span class="line">定义了3个字节，它们的值都是0</span><br><span class="line">相当于 db 0,0,0</span><br><span class="line"></span><br><span class="line">2.db 3 dup(0,1,2)</span><br><span class="line">定义了9个字节，每3个是0,1,2</span><br><span class="line">相当于：db 0,1,2,0,1,2,0,1,2</span><br><span class="line"></span><br><span class="line">3.db 3 dup(&#x27;abc&#x27;,&#x27;ABC&#x27;)</span><br><span class="line">相当于：db &#x27;abcABCabcABCabcABC&#x27;</span><br></pre></td></tr></table></figure><p>4.所以说dup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db【数据定义的伪指令】 次数 dup(内容)</span><br></pre></td></tr></table></figure><h2 id="10-实验七-寻址方式在结构化数据访问中的应用"><a href="#10-实验七-寻址方式在结构化数据访问中的应用" class="headerlink" title="10.实验七-寻址方式在结构化数据访问中的应用"></a>10.实验七-寻址方式在结构化数据访问中的应用</h2><p>自己去看</p><p>exp7.asm</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-更灵活的定位内存地址的方法（7）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-7-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-7-%E6%9B%B4%E7%81%B5%E6%B4%BB%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80%E7%9A%84%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="1-and-和-or-指令"><a href="#1-and-和-or-指令" class="headerlink" title="1.and 和 or 指令"></a>1.and 和 or 指令</h2><p>1.and指令:逻辑与指令，按位进行与运算 【一假即假】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">按位与就是按位与咯</span><br><span class="line">01=0;10=0;11=1;00=0</span><br><span class="line">比如：</span><br><span class="line">mov al,01100011B</span><br><span class="line">and al,00111011B</span><br><span class="line">执行后   al=00100011B</span><br></pre></td></tr></table></figure><p>功能：通过该指令可以将操作对象的相应位设置成0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">将al中的第6位设为0</span><br><span class="line">and al,10111111B</span><br><span class="line">将第0位设为0</span><br><span class="line">and al,11111110B</span><br></pre></td></tr></table></figure><p>2.or指令：逻辑或，按位进行或运算【一真即真】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">mov al,01100011B</span><br><span class="line">or  al,00111011B</span><br><span class="line">执行后： al=01111011B</span><br></pre></td></tr></table></figure><p>功能：通过该指令可将操作对象的相应位设为1，其他位不变</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">al的第6位设置位1</span><br><span class="line">or al,01000000B</span><br></pre></td></tr></table></figure><h2 id="2-关于ASCII码"><a href="#2-关于ASCII码" class="headerlink" title="2.关于ASCII码"></a>2.关于ASCII码</h2><p>没什么…</p><h2 id="3-以字符形式给处的数据"><a href="#3-以字符形式给处的数据" class="headerlink" title="3.以字符形式给处的数据"></a>3.以字符形式给处的数据</h2><p>1.在汇编中，我们可以用   ‘ xxx ‘   的方式指明数据是以字符的形式给出的，编译器将把它们转化为相对应的ASCII码</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume ds:data</span><br><span class="line">data segment</span><br><span class="line">db &#x27;unIX&#x27;;这里会把u n I X 会转化成ASCII码，然后ASCII码只需要8为，所以用db</span><br><span class="line">db &#x27;foRK&#x27;</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segemnt</span><br><span class="line">start:   mov al,&#x27;a&#x27;;这里ascii码就是是 MOV AL,61H</span><br><span class="line">mov vl,&#x27;b&#x27;</span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end satrt</span><br></pre></td></tr></table></figure><h2 id="4-ASCII码大小也转化"><a href="#4-ASCII码大小也转化" class="headerlink" title="4.ASCII码大小也转化"></a>4.ASCII码大小也转化</h2><p>改变字母的大小写，其实就是改写ASCII码的值</p><p>十进制：a 97     A65   相差32</p><p>十六进制 :a61  41A   相差20h</p><p>其实在二进制的时候，也就是在第五位0改成1</p><p>所以小写&lt;–&gt;大写  可以用and 和 or 完成大小写的转变  </p><p>哈哈哈练个手：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg</span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;BaSiC&#x27;</span><br><span class="line">db &#x27;iNfOrMaTiOn&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">  start:mov ax,datasg</span><br><span class="line">     mov ds,ax;设置ds指向datasg段</span><br><span class="line">     </span><br><span class="line">     mov bx,0;设置(bx)=0,将ds:bx指向&#x27;BaSiC&#x27;中的第一个字母</span><br><span class="line">     </span><br><span class="line">     mov cx,5;设置循环5次，因为BaSiC有五个字母</span><br><span class="line">     s:mov al,[bx];将ASCII码从ds:bx所指向的内存单元中取出一个放入al中</span><br><span class="line">     and al,11011111B;将dl中ASCII码的第五位转成0，将其变成大写字母</span><br><span class="line">     mov [bx],al;将转化有的ASCII码又放回去</span><br><span class="line">     inc bx;(bx)++，将ds:bx指向下一个字母</span><br><span class="line">     loop s</span><br><span class="line">     </span><br><span class="line">     mov bx,5</span><br><span class="line">     </span><br><span class="line">     mov cx,11</span><br><span class="line">     s0:mov al,[bx];</span><br><span class="line">     or al,00100000B;这里是把字母全部转化成小写</span><br><span class="line">     mov [bx],al</span><br><span class="line">     inc bx</span><br><span class="line">     loop s0</span><br><span class="line">     </span><br><span class="line">     mov ax,4c00H</span><br><span class="line">     int 21h</span><br><span class="line"> codesg ends</span><br><span class="line"> end start</span><br></pre></td></tr></table></figure><h2 id="5-bx-idata"><a href="#5-bx-idata" class="headerlink" title="5.[bx+idata]"></a>5.[bx+idata]</h2><p>1.在前面我们可以用[bx]的方式来指明一个内存单元，我们还可以用一种更为灵活的方式来搞</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bx+idata]</span><br><span class="line">这个就相当于是:偏移地址=(bx)+idata</span><br></pre></td></tr></table></figure><p>2.变形</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[bx+idata]</span><br><span class="line">idata[bx]</span><br><span class="line">[bx].idata</span><br><span class="line">这三种方式都可以</span><br></pre></td></tr></table></figure><h2 id="6-用-bx-idata-的方式进行数组的处理"><a href="#6-用-bx-idata-的方式进行数组的处理" class="headerlink" title="6.用[bx+idata]的方式进行数组的处理"></a>6.用[bx+idata]的方式进行数组的处理</h2><p>我们观察datasg段中的俩个字符串，一个起始地址为0，另外一个是5</p><p>我们就可以用[0+bx]和[5+bx]在同一个循环中定位这俩个字符串中的字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在这里0和5给定了2个字符的起始偏移地址，bx中给出了从起始偏移地址开始的相对地址</span><br></pre></td></tr></table></figure><p>所以现在就可以把上面的改进</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    mov ax,datasg</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov bx,0</span><br><span class="line"></span><br><span class="line">    mov cx,5</span><br><span class="line">s:mov al[bx]</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx],al</span><br><span class="line"></span><br><span class="line">mov al[5+bx]</span><br><span class="line">or al,00100000B</span><br><span class="line">mov [5+bx],al</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><h2 id="7-SI和DI"><a href="#7-SI和DI" class="headerlink" title="7.SI和DI"></a>7.SI和DI</h2><p>1.SI和DI是8086CPU中和bx功能相近的寄存器，但是SI和DI不能够分成8位寄存器来使用</p><p>问题：用寄存器SI和DI实现将字符串   ‘welcome to masm!’复制到它后面的数据区中</p><p>思路：用ds:si指向要复制的原始位置，用ds:di来指向复制的位置</p><p>写代码咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:  mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov di,16</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:mov ax,[si]</span><br><span class="line">mov [di],ax</span><br><span class="line">add si,2;因为si 和di 都是16位所以+2</span><br><span class="line">add di,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">ends start</span><br></pre></td></tr></table></figure><p>我们也可以用数组的思想</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,8</span><br><span class="line">s:mov ax,0[si]</span><br><span class="line">mov 16[si],ax</span><br><span class="line">add si,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="8-bx-si-和-bx-di"><a href="#8-bx-si-和-bx-di" class="headerlink" title="8.[bx+si]和[bx+di]"></a>8.[bx+si]和[bx+di]</h2><p>1.[bx+si]表示一个内存单元，它的偏移地址是(bx)+(si)</p><p>2.看看 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx+si]</span><br><span class="line">将一个内存单元的内容送入ax中，这个内存单元的长度为2【字单元】</span><br><span class="line">偏移地址是：bx中的数值+si中的数值，段地址默认是ds</span><br></pre></td></tr></table></figure><p>3.同类</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[bx+si]</span><br><span class="line">[bx][si]</span><br><span class="line">这俩种其实是同一种</span><br></pre></td></tr></table></figure><h2 id="9-bx-si-idata-和-bx-di-idata"><a href="#9-bx-si-idata-和-bx-di-idata" class="headerlink" title="9.[bx+si+idata]和[bx+di+idata]"></a>9.[bx+si+idata]和[bx+di+idata]</h2><p>emmm和上面的雷同，我吐了</p><h2 id="10-用不同的寻址方式的灵活应用"><a href="#10-用不同的寻址方式的灵活应用" class="headerlink" title="10.用不同的寻址方式的灵活应用"></a>10.用不同的寻址方式的灵活应用</h2><p>1.比较一下之前用到的几种定位内存地址的方法（也就是寻址的方式）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.[idata]用一个常量来表示一个地址，可以用于之间定位一个内存单元</span><br><span class="line">2.[bx]用一个变量来表示内存地址，可用于间接定位一个内存单元</span><br><span class="line">3.[bx+idata]这个感觉就是一个一维数组idata[bx]和a[]可以雷同。用一个变量和常量表示地址，可在一个起始地址的基础上用变量间接定位一个内存单元</span><br><span class="line">4.[bx+si]用2个变量来表示地址</span><br><span class="line">5.[bx+si+idata]用两个变量和一个常量来表示地址</span><br></pre></td></tr></table></figure><p>2.EMMM这里听得太入迷了，忘了写笔记</p><p>无所谓了，那就不写了，记录一点有用的就好了</p><p>题目：</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411225142572.png" alt="image-20230411225142572"></p><p>3.我们在进行一次循环的时候使用CX 会递减，这个是没有问题的</p><p>但是如果我们要用循环里面套循环，这个时候，在里面的循环又需要调用一次cx，这样就会形成cx被覆盖！！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为了解决这个问题</span><br><span class="line">我们就应该每次开始内层循环的时候，将外层循环的cx中的数值保存起来，在执行外层循环的loop指令前，再回复外层循环的cx数值</span><br><span class="line"></span><br><span class="line">我们可以用寄存器dx来保存cx中的值</span><br></pre></td></tr></table></figure><p>改进后的循环</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0;用bx来定位行</span><br><span class="line"></span><br><span class="line">mov cx,4</span><br><span class="line">s0:mov dx,cx;用dx来保存外层的cx中的值</span><br><span class="line">mov si,0</span><br><span class="line"></span><br><span class="line">mov cx,3</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx+si],al</span><br><span class="line"></span><br><span class="line">inc si</span><br><span class="line">loop s;这个时候cx中的值已经变成0了</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">mov cx,dx;将外层的cx还原</span><br><span class="line">loop s0;cx=cx-1 再判断是否为0是否再循环</span><br></pre></td></tr></table></figure><p>上面的程序中就是用的dx，但是如果dx被使用了，或者说找不到合适的寄存器怎么办呢？</p><p>就是说，我们这些数据就是需要展示存放一下</p><p>为了寻找一个通用的方案，所以我们就可以用内层，我们就可以将需要暂时存的数据放到一段内存单元中，需要使用的时候，再从内存单元中恢复，这样我们就需要开辟一段内存空间</p><p>改进后的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">dw 0;这里定义一个字，开辟一个字空间来保存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">    mov bx,0</span><br><span class="line">    </span><br><span class="line">    mov cx,4</span><br><span class="line">s0:mov ds:[40H],cx;将外层循环的cx值保存在datasg:40H单元中</span><br><span class="line">mov si,0;用si来表示列</span><br><span class="line"></span><br><span class="line">mov cx,3;设置内存循环次数</span><br><span class="line">s:mov al,11011111B</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx+si],al;[bx+si]bx就是行si就是列，虽然在内存中是线性排列的，但是我们可以这么理解</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16;这里用bx来表示行</span><br><span class="line">mov cx,ds:[40H]</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mobv ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>但是，这样的作法有点麻烦 </p><p>所以我们又进步了！！用栈</p><p>push 后 pop</p><p>又来写代码了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">datasg segment</span><br><span class="line">db &#x27;ibm.............&#x27;</span><br><span class="line">db &#x27;dec.............&#x27;</span><br><span class="line">db &#x27;dos.............&#x27;</span><br><span class="line">db &#x27;vax.............&#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0;定义一个段，用来做栈段，容量为16个字节</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line"></span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,4</span><br><span class="line">s0:push cx;把外层循环的cx值放入栈中保存起来，保护cx</span><br><span class="line">mov si,0</span><br><span class="line">mov cx,3;cx设置成内存循环的次数</span><br><span class="line">s:mov al,[bx+si]</span><br><span class="line">and al,11011111B</span><br><span class="line">mov [bx+si],al</span><br><span class="line">inc si</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">add bx,16</span><br><span class="line">pop cx;在需要外层的cx的时候，在把他pop出来</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>7.9</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">;将datasg段中的每个单词的前4个字母改成大写字母</span><br><span class="line">assume cs:codesg,ss:stacksg,ds:datasg</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">db &#x27;1. display      &#x27;</span><br><span class="line">db &#x27;2. brows        &#x27;</span><br><span class="line">db &#x27;3. replace      &#x27;</span><br><span class="line">db &#x27;4. modify       &#x27;</span><br><span class="line">datasg ends</span><br><span class="line">;[bx+si+idata][bx];当列;[si+idata]当行数</span><br><span class="line">codesg segment</span><br><span class="line">start:mov ax,stacksg</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16;等会儿外层循环需要push的栈</span><br><span class="line"></span><br><span class="line">mov ax,datasg</span><br><span class="line">mov ds,dx;确定数据的段地址</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,4;外层需要4行也就是4次循环</span><br><span class="line">s:push cx;把cx保护起来</span><br><span class="line"></span><br><span class="line">mov si,0;因为每一次循环的时候，每一列都行重新索引字母的位置，所以si需要设置在外面</span><br><span class="line"></span><br><span class="line">mov cx,4;把后面的4个字母都需要改成大写所以要循环4次</span><br><span class="line">s0:mov dl,ds:[bx+3+si];这样索引住第一个字母，通过si的自增来索引后面的4个字母</span><br><span class="line">mov dl,11011111B;这样就是改成大写</span><br><span class="line">mov ds:[bx+3+si],dl;这里需要把dl中的值放回原来的内存中</span><br><span class="line">inc si;si++索引下一个</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">add bx,16;选中下一行</span><br><span class="line">pop cx;把原来的cx还回来</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="总结一下啦"><a href="#总结一下啦" class="headerlink" title="总结一下啦"></a>总结一下啦</h2><p>1.si di</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这两个寄存器和ax一样，但是不能被拆开</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">主要用于：</span><br><span class="line">[bx+si+idata]</span><br></pre></td></tr></table></figure><p>2.用栈来保护数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">push cx</span><br><span class="line">pop cx</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-包含多个段的程序（6）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-6-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-6-%E5%8C%85%E5%90%AB%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-在代码段中使用数据"><a href="#1-在代码段中使用数据" class="headerlink" title="1.在代码段中使用数据"></a>1.在代码段中使用数据</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment </span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s</span><br><span class="line">   </span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>1.dw的含义【dw 也是 define word】也就是定义字型数据</p><p>【每一个数据之前都需要用  ,  隔开】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同样可以衍生处db 【define byte】也就是定义字节型数据</span><br></pre></td></tr></table></figure><p>问题1：这八个字型数据是放在哪里的呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw xxxxxx</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这8个数据肯定是放在这个定义好的cs【也就是代码段中】【所以他们的段地址肯定是cs】</span><br><span class="line">那这8个的偏移地址是多少呢？</span><br><span class="line">因为是在最开始的地方，所以偏移地址就是：2 4 6 8 ...</span><br></pre></td></tr></table></figure><p>emmm，这8个字型数据放在了代码段，cpu就会把这8个字型的数据当作代码来运行【因为cpu都是去认二进制，而不会知道你这个是代码还是数据】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment </span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">mov bx,0</span><br><span class="line">mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s</span><br><span class="line">   </span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end</span><br><span class="line">如果单纯的使用这个，就会错误</span><br><span class="line">所以我们需要改进一下，把cs的指向mov bx,0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment </span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">start: mov bx,0</span><br><span class="line">  mov ax,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s: add ax,cs:[bx]</span><br><span class="line">   add bx,2</span><br><span class="line">   loop s</span><br><span class="line">   </span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>在这里，我们在程序的第一条指令的前面加上了一个标号start，而这个标号在伪指令end的后面出现</p><p>也就是说：end的作用，除了通知编译器程序结束外，还可以通知编译器程序的入口在什么地方</p><p>就比如说这里，它通知了编译器的入口是在 start后面，所以就不会去把dw中的内容粗错</p><p>cpu 在找入口的时候，是首先去找到end  而不是去找start 因为这个start是可以改变的</p><p>在使用了这个end  start这个标号之后，就可以在代码段中使用数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是这里的dw xxx</span><br></pre></td></tr></table></figure><p>也就是衍生出来了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">..</span><br><span class="line">数据</span><br><span class="line">..</span><br><span class="line">startL</span><br><span class="line">..</span><br><span class="line">代码</span><br><span class="line">..</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h2 id="2-在代码段中使用栈"><a href="#2-在代码段中使用栈" class="headerlink" title="2.在代码段中使用栈"></a>2.在代码段中使用栈</h2><p>完成下面的程序，利用栈，将程序中定义的数据逆序存放</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line"></span><br><span class="line">?</span><br><span class="line">code ends</span><br></pre></td></tr></table></figure><p>分析一波</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说：我们需要把cs:0~cs:15单元中，一共8个字单元。依次将这8个子单元的数据入栈，然后再依次出栈到这8个字单元中，从而实现了数据的逆序存放</span><br></pre></td></tr></table></figure><p>问题来了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们就需要由一个空间来定义一个栈</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以像之前一样，通过定义数据来取得一段空间，然后将这段空间当作栈空间来使用</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一定要注意的是：我们是通过定义数据来取得一段空间【dw】，然后将这段空间来当作栈空间来使用</span><br></pre></td></tr></table></figure><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">csdesg segment </span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">dw 0,0,0,0,0,0,0,0;用dw定义空间，人为的当作栈来使用</span><br><span class="line">;上面的一串就是说：cs:0~cs:15  和  cs:16~cs:1fH[31]都是数据【前面的一段当作数据段使用，后面的一段当作栈来使用】</span><br><span class="line"></span><br><span class="line">start: </span><br><span class="line">mov ax,cs</span><br><span class="line">mov ss,ax;这里就是把代码段地址给栈段地址，因为他们都是在这个cs段里面，只是偏移地址不同罢了</span><br><span class="line">mov sp,32;这里是设置栈顶，原本的底部是31所以栈顶的位置是32【这里用的是10进制而非16进制】</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:</span><br><span class="line">push cs:[bx];这里就是把cs:[bx]中的值依次放入ss:[sp]中，也就是cs:16~cs:1fH中，倒着入栈</span><br><span class="line">add bx,2</span><br><span class="line">loop s;这次循环的代码就是让前面的8个数据入栈</span><br><span class="line"></span><br><span class="line">mov bx,0;把bx重新定义回去</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s0:</span><br><span class="line">pop cs:[bx];就是pop 把栈中的数据送入cs:[bx]中</span><br><span class="line">add bx,2</span><br><span class="line">loop s0;这一串代码就是说把原本入了栈的数据，从上往下依次出栈,送入cs[bx]中，原本最先入栈的最后出栈</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><h3 id="检测点6-1"><a href="#检测点6-1" class="headerlink" title="检测点6.1"></a>检测点6.1</h3><h2 id="3-将数据，代码，栈，放入不同的段"><a href="#3-将数据，代码，栈，放入不同的段" class="headerlink" title="3.将数据，代码，栈，放入不同的段"></a>3.将数据，代码，栈，放入不同的段</h2><p>1.在前面的内容中，我们在程序中用到了数据和栈，我们将数据，栈，代码都放到了一个段里面。我们在编程的时候要注意何处是数据，何处是栈，何处是代码。这样就很垃圾</p><p>2.放到一个段中，这样很乱，而且不能放大量的数据，因为在8086CPU中一个段也就是64KB</p><p>3.如何实现，把数据，栈，代码放到不同的段中呢？</p><p>把上面写的代码改造改造</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">dw 0123H,0456H,0789H,0abcH,0defH,0fedH,0cbaH,0987H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:   mov ax,stack</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,20H;上面是假设ss和stack联系起来，通过这一步后，就是真正的联系起来了</span><br><span class="line"></span><br><span class="line">mov ax,data</span><br><span class="line">mov ds,ax;同理，补充--&gt;段寄存器是不能之间被值给赋予的，必须要通过寄存器这个媒介</span><br><span class="line">;data 其实本质就是地址也就是数据，得先放入ax后放入段寄存器</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push [bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov bx,0;总结一下</span><br><span class="line">;这里 要记住：segment和ends是一段伪指令，它们中间是这个段寄存器中的内容</span><br><span class="line">mov cx,2</span><br><span class="line">s0:pop [bx];end 才是开始的地方，也就是说编译器会告诉CPU让CPU中的CS:IP去指向end xxx的位置</span><br><span class="line">         add bx,2;在这里是start，也就是说，end后面的标号，回去告诉cpu 这个命令执行开始的地方</span><br><span class="line">loop s0</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>成功肯定是离不开一步一步的成长，所以我们现在来分析一下这个代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code, ds:data, ss:stack</span><br><span class="line">假设 cs和code, ds和data, ss和stack连接起来了【给编译器看的，伪指令咯】</span><br></pre></td></tr></table></figure><h3 id="实验五"><a href="#实验五" class="headerlink" title="实验五"></a>实验五</h3><p>;编写code段中的代码，将a段和b段中的数据相加，结果保存到到c段</p><p>这里可以参考 m1.sam写的代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">;编写code段中的代码，将a段和b段中的数据相加，结果保存到到c段</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment </span><br><span class="line">db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">db 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">mov ax, a</span><br><span class="line">mov ds, ax;这里把ds中指向a也就是说需要用到a中的值的时候是用的ds:[bx]来索引</span><br><span class="line"></span><br><span class="line">mov ax, b</span><br><span class="line">mov es, ax;这里把es中指向b【段地址】</span><br><span class="line"></span><br><span class="line">;mov ax,c</span><br><span class="line">;mov ss,ax;这里把ss中指向了c</span><br><span class="line">;mov sp,8</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:mov dl,ds:[bx];这里把a中的第一个数据放进去</span><br><span class="line">add dl,es:[bx];</span><br><span class="line">;sub bx,1</span><br><span class="line">;inc bx;自己加上去</span><br><span class="line">;这里已经把a和b中的值相加放到了dl中，所以现在需要把dl中的值放入c中</span><br><span class="line">;也就是需要有一个 mov c地址,dl,当然这个c地址也要递增也需要用到bx，所以上面的inc bx先不慌加</span><br><span class="line">;智商有限，这个只剩下了ss栈段，我们把c定义成栈，然后把数据放入栈也可以吧</span><br><span class="line">;push dl</span><br><span class="line">;loop s;总体的思路就是吧c当作栈段，然后吧数据push进去，这里push的时候要注意是栈顶也就是sp指的位置，sp-2</span><br><span class="line">;卧槽，写一半的时候发现push 是sp-2，这里是内存单元是8个字节，所以不能用push</span><br><span class="line"></span><br><span class="line">;所以这里就不能用ss 也不能用push 只能用ds咯</span><br><span class="line"></span><br><span class="line">push ds ;原本的ds是a这里零时用一下，所以需要把ds保护起来，也就是放入栈中</span><br><span class="line">mov ax,c</span><br><span class="line">mov ds,ax;现在的ds是指向c</span><br><span class="line">mov ds:[bx],dl</span><br><span class="line">pop ds;这里把ds还原</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>;只能用push指令将a段中的前8个字型数据，逆序存储到b段中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">;只能用push指令将a段中的前8个字型数据，逆序存储到b段中</span><br><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">dw 1,2,3,4,5,6,7,8,9,0ah,0bh,0ch,0eh,0fh,0ffh</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment </span><br><span class="line">dw 0,0,0,0,0,0,0,0</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:</span><br><span class="line">;首先，只能用push说明，b段的段地址也就是我们定义的栈段的段地址，然后把a中的玩意push进去就好了三</span><br><span class="line">mov ax,a</span><br><span class="line">mov ds,ax</span><br><span class="line"></span><br><span class="line">mov ax,b</span><br><span class="line">mov ss,ax</span><br><span class="line">mov sp,16</span><br><span class="line"></span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov cx,8</span><br><span class="line">s:push ds:[bx]</span><br><span class="line">add bx,2</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">ends start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-[BX]和loop指令（5）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-5-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-5-BX-%E5%92%8Cloop%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="描述性符号“-”"><a href="#描述性符号“-”" class="headerlink" title="描述性符号“()”"></a>描述性符号“()”</h3><p>描述性符号()来表示一个寄存器或者一个内存单元中的！！内容！！</p><p>只能用来描述罢了 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">举个例子：</span><br><span class="line">1.ax中的内容是0010H则</span><br><span class="line">(ax)=0010H</span><br><span class="line">2.2000:1000处的内容为0010H则</span><br><span class="line">(21000H)=0010H</span><br><span class="line">3.对于mov ax,[2]的功能，我们可以这样来描述：</span><br><span class="line">(ax)=((ds)*16+2)</span><br><span class="line">4.对于push ax</span><br><span class="line">(sp)=(sp-2) ; 一定要注意是先改掉sp的位置在入栈</span><br><span class="line">((ss)*16+(sp))=(ax) ;这个就是把ax中的值入栈</span><br><span class="line">5.对于pop</span><br><span class="line">(ax)=((ss)*16+(sp))</span><br><span class="line">(sp)=(sp)+2</span><br></pre></td></tr></table></figure><h3 id="约定符号idata表示常量"><a href="#约定符号idata表示常量" class="headerlink" title="约定符号idata表示常量"></a>约定符号idata表示常量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">比如说 mov ax,[idata] 就代表 mov ax,[1] mov ax,[2] </span><br><span class="line"></span><br><span class="line">在这里回顾一个知识点,段寄存器比如ds</span><br><span class="line">不能使用</span><br><span class="line">mov ds,[1]</span><br><span class="line">所以在这里段寄存器就不能使用</span><br><span class="line">mov ds,[idata]</span><br><span class="line">因为段寄存器只能通过其他的寄存器来赋予</span><br><span class="line">mov ds,[ax]</span><br></pre></td></tr></table></figure><h2 id="1-bx"><a href="#1-bx" class="headerlink" title="1.[bx]"></a>1.[bx]</h2><h3 id="bx-和内存单元的描述"><a href="#bx-和内存单元的描述" class="headerlink" title="[bx]和内存单元的描述"></a>[bx]和内存单元的描述</h3><p>1.[bx]是什么呢？</p><p>​    和[0]有些类似【这个[0]是在之前的ds:[]中有遇到的数据的段地址】[0]表示内存单元，它的偏移地址是0</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[0] ;这个是以字为大小的</span><br><span class="line">mov al,[0] ;这个是以字节为大小的</span><br></pre></td></tr></table></figure><p>2.我们要完整地描述一个内存单元，需要俩种信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.内存单元的地址</span><br><span class="line">2.内存单元的长度【类型】</span><br></pre></td></tr></table></figure><p>3.我们在使用[0]表示一个内存单元的时候 ， 0表示单元的偏移地址，段地址默认是ds！！单元的长度【类型】是由指令中的其他操作对象所指出的【寄存器，ax ，al】</p><p>4.[bx]同样也表示一个内存单元，它的偏移地址在bx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mov ax,[bx]</span><br><span class="line">mov al,[bx]</span><br><span class="line"></span><br><span class="line">为什么要这么写呢，而不是直接 mov ax,[0]?</span><br><span class="line">是因为：编译器和debug的认知不一样，在debug中它认为 mov ax,[0]就是把偏移地址=0的内存内容放进ax存储器中，但是!!在编译器中它会认为是mov ax,0 而不是mov ax,[0],</span><br><span class="line">所以在使用编译器写的时候，需要使用到[bx]这样</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">mov bx,[0]</span><br><span class="line">mov ax,[bx]</span><br><span class="line">这样写就和在debug中</span><br><span class="line">mov ax,[0]</span><br><span class="line">是一样的</span><br></pre></td></tr></table></figure><p>5.下面来简单的看一串代码分析分析最后的样子应该是什么样子的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2000H;在内存中21000H 是BE 21001H 是00</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ax,[bx];这里是把ds:[bs]中的内容放入ax中 也就是段地址:偏移地址==2000H:1000H也就是物理地址等</span><br><span class="line">inc bx于2000H*16+1000H ==&gt;21000H</span><br><span class="line">inc bx ;这个inc就是自加1就和++一样</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],ax</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br><span class="line">inc bx</span><br><span class="line">mov [bx],al</span><br><span class="line"></span><br><span class="line">一定要记住：高存高，低存低</span><br></pre></td></tr></table></figure><p>最后得到应该是 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">21000HBE</span><br><span class="line">21001H00</span><br><span class="line">21002HBE</span><br><span class="line">21003H00</span><br><span class="line">21004HBE</span><br><span class="line">21005HBE</span><br><span class="line">21006HBE</span><br><span class="line">21007H</span><br></pre></td></tr></table></figure><h2 id="2-Loop指令"><a href="#2-Loop指令" class="headerlink" title="2.Loop指令"></a>2.Loop指令</h2><p>1.英文单词loop由循环的意思，显然这个指令就是和循环由关系</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">俩步走</span><br><span class="line">1.CX=CX-1【这里是CX哦 而不是CS】【CX是一个新的通配符】</span><br><span class="line">2.判断cx中的值，不为0则跳转到标号处，如果是0则执行吓一条指令</span><br></pre></td></tr></table></figure><p>2.这说明，CX中的值影响着LOOP指令的执行结果</p><p>3.通常下，我们用loop指令来实现循环功能CX中存放着循环的次数</p><h3 id="小小的练习1"><a href="#小小的练习1" class="headerlink" title="小小的练习1"></a>小小的练习1</h3><p>1.编程计算：2^12</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,2</span><br><span class="line">mov cx,11;这里来定义一个11次循环</span><br><span class="line">s:add ax,ax;这里的s就是标号【可以随便定义】</span><br><span class="line">loop s;这里就类似于jmp 跳到了s去运行add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这里有一个标号: s 【这个东西是可以随便定义的】</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410193828528.png" alt="image-20230410193828528"></p><p>注意看这里 LOOP 0006 这个0006其实就是 s 【标号】 也就是IP的值 也就是CS:IP的偏移地址，所以这个标号是可以随便定义的【名字】，它总会跳到上这个标号的的偏移地址的位置</p><h3 id="小小的总结"><a href="#小小的总结" class="headerlink" title="小小的总结"></a>小小的总结</h3><p>1.在CX中存放循环次数【只能是用CX 不能使用其他的！！】</p><p>2.loop指令中的标号所表示前面</p><p>3.要循环执行的程序段，要写在标号和loop指令的中间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov cx,循环次数</span><br><span class="line">s:循环执行的程序段</span><br><span class="line">loop s</span><br></pre></td></tr></table></figure><h3 id="小小的练习2"><a href="#小小的练习2" class="headerlink" title="小小的练习2"></a>小小的练习2</h3><p>1.用加法计算123×236，结果放在ax中</p><p>2.分析一下咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">我有点蠢 就想到了将123加236次</span><br><span class="line">设置ax,0 然后循环 add, ax,ax 236次</span><br></pre></td></tr></table></figure><p>写代码咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,236</span><br><span class="line">s:add ax,123</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>3.卧槽傻逼了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">可以用236  +123次</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0</span><br><span class="line">mov cx,123</span><br><span class="line">s:add ax,236</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h2 id="3-在Debug中跟踪用loop指令实现的循环语句"><a href="#3-在Debug中跟踪用loop指令实现的循环语句" class="headerlink" title="3.在Debug中跟踪用loop指令实现的循环语句"></a>3.在Debug中跟踪用loop指令实现的循环语句</h2><p>1.将ffff:0006单元中的值*3后赋值给dx</p><p>补充一点知识点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ffff:0006单元的中值 一个字节单元的值，也就是【XXH】但是通用寄存器dx的内存空间大小是字【XXXXH】</span><br><span class="line"></span><br><span class="line">这里要知道:10和0010虽然那个不一样大，但是值是一样大的，所以这里要使用dl而不是，如果使用了dx，则dx中存放的值就是ffff:0006和ffff:0007一起组合在一起的字</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ok，现在来分析咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">也就是说：我们不能直接使用dx 【这里视频里面用的ax，所以我们也用ax】</span><br><span class="line">所以我们应该令(ah)=0,(al)=(ffff6H)</span><br></pre></td></tr></table></figure><p>哈哈哈，写代码咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffH;在汇编源程序中，数据是不能以字母开头的，所以要+0</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,6</span><br><span class="line">mov al,[bx]</span><br><span class="line">mov ah,0</span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx,3</span><br><span class="line">s: add dx,ax</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>问题来咯，如果是要成1000次，这不得+1000次，在用debug跟踪的时候不得t1000次，这不得把我累死</p><p>于是乎我们有了G命令来解决</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g 命令是debug中的命令 </span><br><span class="line">用法：g 偏移地址  ; 这样它就会跳到你所指向的偏移地址的地方而且中间的代码都会运行完全，循环也会指向完全</span><br></pre></td></tr></table></figure><p>实操一下咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用 u CS:IP来查看一下咯</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410203021347.png" alt="image-20230410203021347"></p><p>emmmm 这个dx的值看着有点奇怪，</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410203359405.png" alt="image-20230410203359405"></p><p>卧槽，这个好像不对耶，我左思右想………会不会是al溢出了哦【哈哈哈，一看就是溢出了】</p><p>这种情况咋解决呢？【书上和视频里面没有，全靠我自己咯】</p><p>tmd 我是傻逼  这个地方是123不是123H</p><p>所以代码没有问题</p><p>补充一点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我在调试的时候，发现</span><br><span class="line">mov al,0 </span><br><span class="line">不能写成 mov al,00</span><br><span class="line">至于为什么</span><br><span class="line">我也不知道</span><br></pre></td></tr></table></figure><h2 id="4-Debug和汇编编译器Masm对指令的不同处理"><a href="#4-Debug和汇编编译器Masm对指令的不同处理" class="headerlink" title="4.Debug和汇编编译器Masm对指令的不同处理"></a>4.Debug和汇编编译器Masm对指令的不同处理</h2><p>1.debug和编译器中的不同理解</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1.mov ax,[0]</span><br><span class="line">这个在编译器里面写会被理解成 </span><br><span class="line">mov ax,0这样就会犯错</span><br><span class="line">但是在debug中就可以这么写</span><br><span class="line"></span><br><span class="line">2.在debug中，默认的就是16进制</span><br><span class="line">但是在编译器中16进制一定要写H</span><br><span class="line"></span><br><span class="line">但是如果我们就是想在编译中写入[0]这样的形式呢？</span><br><span class="line">那就需要写上段地址</span><br><span class="line">mov ax,ds:[0]</span><br></pre></td></tr></table></figure><p>2.在debug中的一些命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">r 查看</span><br><span class="line">t 运行一步</span><br><span class="line">u 把机器码转成汇编语言</span><br><span class="line">a 以汇编的形式写入</span><br><span class="line">a cs:ip 回车</span><br><span class="line">d 查看</span><br><span class="line">d 段地址:偏移地址</span><br></pre></td></tr></table></figure><h2 id="5-loop和-bx-的联合应用"><a href="#5-loop和-bx-的联合应用" class="headerlink" title="5.loop和[bx]的联合应用"></a>5.loop和[bx]的联合应用</h2><p>1.在计算处的结果存放在dx中，要稍微的判断一下这个值，是否能完美的装入dx中国，会不会溢出？</p><p>2.在计算ffff:0~ffff:b单元的数据和，不能将数据直接累加到dx中，因为没一个单元中的数据都是8位的，不能直接加到16位寄存器dx中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">那是否可以加到dl中呢？</span><br><span class="line">同样的问题，不能丢失数据</span><br></pre></td></tr></table></figure><p>3.所以这里有2个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.类型匹配的问题</span><br><span class="line">2.结果越界的问题</span><br></pre></td></tr></table></figure><p>4.解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们将内存单元的8位数据赋值到一个16位寄存器ax中，在将ax中的数据累加到dx中，从而使得运算对象的类型匹配，并且不会越界</span><br></pre></td></tr></table></figure><p>.在计算ffff:0~ffff:b单元的数据和</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffH</span><br><span class="line">mov ds,ax</span><br><span class="line">mov bx,0</span><br><span class="line"></span><br><span class="line">mov dx,0</span><br><span class="line"></span><br><span class="line">mov cx,12</span><br><span class="line"></span><br><span class="line">s:mov al,[bx];这里就是把ds:[bx]中的值放入al中</span><br><span class="line">    mov ah,0;我感觉这个地方有点浪费了，但是我也不知道如何改进，</span><br><span class="line">    add dx,ax</span><br><span class="line">    inc bx;inc 就是自增</span><br><span class="line">    loop s</span><br><span class="line">   </span><br><span class="line">   mov ax,4c00H</span><br><span class="line">   int 21h</span><br><span class="line">   </span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>在这里只能用变量 bx 可以用来自增， 不能用常量哦</p><p>mov al,[bx]中的bx就可以看作一个代表内存单元地址的变量，我们可以不写新的指令，仅仅通过改变bx中的数值，改变指令访问的内存单元</p><h2 id="6-段前缀"><a href="#6-段前缀" class="headerlink" title="6.段前缀"></a>6.段前缀</h2><p>1.指令mov ax,[bx]中，内存单元的偏移地址由bx给处，而段地址默认是ds中</p><p>2.我们可以在访问内存单元的指令中显示地给出内存单元的段地址所在的段寄存器</p><p>3.这些出现在访问内存单元中的指令中，用于显示地指明内存单元的段地址的ds，cs，ss，es，在汇编语言中就把这些称为段前缀</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在没有用段前缀的时候，就会默认使用ds</span><br></pre></td></tr></table></figure><h2 id="7-一段安全的空间"><a href="#7-一段安全的空间" class="headerlink" title="7.一段安全的空间"></a>7.一段安全的空间</h2><p>我们应该是自由，直接的用汇编语言去操作真实的硬件，了解那些早已被层层系统软件掩盖的真相</p><p>在dos下，一般在0:200这里开始就可以操作</p><h2 id="8-段前缀的使用"><a href="#8-段前缀的使用" class="headerlink" title="8.段前缀的使用"></a>8.段前缀的使用</h2><p>  考虑到一个问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将内存ffff:0~ffff:b单元中的数据拷贝到0:200~0:20b单元中</span><br></pre></td></tr></table></figure><p>分析一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1.0:200~0:20b单元等同于0020:0~0020:b单元，他们描述的是同一段内存空间</span><br><span class="line">2.拷贝过程应用用循环实现：</span><br><span class="line">初始化 : X=0</span><br><span class="line">循环12次</span><br><span class="line">将ffff：X单元中的数据送入0020:X(需要用一个寄存器中转一下咯)</span><br><span class="line">X=X+1</span><br><span class="line">3.在循环中，源单元中ffff:X和目标单元的0020:X的偏移地址X是变量。我们用bx来存放</span><br><span class="line">4.我们用将0:200~0:20b用0020：0~0020：b描述，就是为了使目标单元的偏移地址和源始单元的偏移地址从同一数值0开始</span><br></pre></td></tr></table></figure><p>写代码咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov bx,0;(bx)=0，偏移地址从0开始</span><br><span class="line">mov cx,12;(cx)=12，循环12次</span><br><span class="line"></span><br><span class="line">s:mov ax,0ffffH</span><br><span class="line">mov ds,ax;(ds)=0ffffh</span><br><span class="line">mov dl,[bx];(dl)=((ds)*16+(bx)),将ffff:bx中的数据送入dl中</span><br><span class="line">mov ax,0020H</span><br><span class="line">mov ds,ax;(ds)=0020h</span><br><span class="line">mov [bx],dl((ds)*16+(bx))=(dl),将dl的数据送入0020：bx中</span><br><span class="line">inc bx;(bx)=(bx)+1</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>分析一下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1.因为原单元ffff:X和目标单元0020:X相聚大于64KB，在不同的64KB段里，程序中每次都是设置俩次的ds，</span><br><span class="line">这样的效率不高</span><br><span class="line">2.所以，我们可以使用2个段寄存器分别存放原单元ffff:x和目标单元0020:x的段地址，这样就可以省略循环中需要重复做的12次设置ds的程序段</span><br><span class="line">这里的俩个段段寄存器，一个是ds 一个是es</span><br></pre></td></tr></table></figure><p>改进的代码来咯</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">mov ax,0ffffH</span><br><span class="line">mov ds,ax;(ds)=0ffffH</span><br><span class="line">mov ax,0020H</span><br><span class="line">mov es,ax;(es)=0020H  , 这里的es是以多余的段，需要的时候就可以拿来用</span><br><span class="line">mov bx,0;(bx)=0,此时ds:bx指向ffff:0,es:bx指向0020:0</span><br><span class="line">mov cx,12;(cx)=12,循环12次</span><br><span class="line"></span><br><span class="line">s:mov dl,[bx];(dl)=((ds)*16+(bx)),将ffff:bx中的数据送入dl</span><br><span class="line">mov es:[bx],dl;((es)*16+(bx))=(dl),将dl的数据收纳柜如0020:bx</span><br><span class="line">inc bx;(bx)=(bx)+1</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><h3 id="实验咯"><a href="#实验咯" class="headerlink" title="实验咯"></a>实验咯</h3><p>实验4</p><h4 id="（1）向内存0-2000-23f依次送入数据03f"><a href="#（1）向内存0-2000-23f依次送入数据03f" class="headerlink" title="（1）向内存0:2000:23f依次送入数据03f"></a>（1）向内存0:200<del>0:23f依次送入数据0</del>3f</h4><p>分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我首先想到的是用栈段依次依次的送入，但是栈中的push都是以16个字节为单位的。不能满足条件，题目是8个字节，也就是一个内存单元来放入数据。放弃这个栈段的思路</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里送入的数据是0~64也就是一步一步自增</span><br><span class="line">所以，首先找到这个内存地址，用ds:bx定位，然后用一个low寄存器从0开始依次送入，然后再递增</span><br></pre></td></tr></table></figure><p>尝试一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment </span><br><span class="line">mov ax,0</span><br><span class="line">mov ds,ax;这里把段寄存器设置成0</span><br><span class="line">mov bx,200H;这里把偏移地址设置成200，下面在实现送入数据的同时自曾1</span><br><span class="line">mov al,0;这里是把就是向把al中的数据送入ds:bx中，因为是从0开始，所以设置成0【感觉也不需要，因为上面的ax,0】</span><br><span class="line"></span><br><span class="line">mov cx,64</span><br><span class="line">s: mov [bx],al;把al中的数据送入ds:bx中</span><br><span class="line">inc bx</span><br><span class="line">inc al</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411102853483.png" alt="image-20230411102853483"></p><h4 id="2-程序中只能使用9条指令-其中包括mov-ax-4c00h-和int-21h"><a href="#2-程序中只能使用9条指令-其中包括mov-ax-4c00h-和int-21h" class="headerlink" title="(2)程序中只能使用9条指令,其中包括mov ax,4c00h 和int 21h"></a>(2)程序中只能使用9条指令,其中包括<code>mov ax,4c00h</code> 和<code>int 21h</code></h4><p>分析一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说，这里地方就是要把上面的代码进行优化，使他只有9行</span><br></pre></td></tr></table></figure><p>emmm，看了答案才知道咋搞…它就是说要把bx和al合并一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也就是说内存是：0:200-0:23F，也就是物理地址是00200-0023f,可以把这个理解成0020:0~00</span><br></pre></td></tr></table></figure><p>写一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov ax,20h</span><br><span class="line">mov ds,ax;设置ds=0</span><br><span class="line"></span><br><span class="line">mov cx,64;循环64次</span><br><span class="line">mov al,0;传送的数据</span><br><span class="line"></span><br><span class="line">s:mov [al],al</span><br><span class="line">inc al</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>抄的答案不对？？</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411105420647.png" alt="image-20230411105420647"></p><p>emmm</p><p>使用寄存器间接寻址时，只可以使用 BX, BP, SI, DI 这四个寄存器中的一个，不可以使用其它寄存器。</p><p>也就是说这里的[al]是不行的</p><p>长知识了，间接寻址的时候，不能用al，只能用BX BP SI DI </p><p>重新来一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">;又找到了一个答案，看看是怎么个费事</span><br><span class="line">;向内存`0:200-0:23F`依次传送数据0~63（3FH）</span><br><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">mov bx,0h</span><br><span class="line">mov ds,bx;这里ds就是0</span><br><span class="line">mov ax,200h;这一段是纯属没用的，要不要都可以</span><br><span class="line"></span><br><span class="line">mov cx,64</span><br><span class="line">s:  mov [bx+200h],bx;???在汇编里面可以用+号吗？</span><br><span class="line">inc bx</span><br><span class="line">loop s</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411110203257.png" alt="image-20230411110203257"></p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411110743607.png" alt="image-20230411110743607"></p><p>实践处真道理，可以用+号</p><p>这里用debug测试了一下可以用加号</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411110928917.png" alt="image-20230411110928917"></p><h3 id="（3）"><a href="#（3）" class="headerlink" title="（3）"></a>（3）</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line"></span><br><span class="line">    mov ax,___</span><br><span class="line">    mov ds,ax;ds的地址为ax</span><br><span class="line">    mov ax,0020h</span><br><span class="line">    mov es,ax;es是20h</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,___</span><br><span class="line">    </span><br><span class="line">s:mov al,[bx];将ds;bx的值赋值给al</span><br><span class="line">    mov es:[bx],al;将al的值赋值给es[bx]</span><br><span class="line">    inc bx;bx++</span><br><span class="line">    loop s</span><br><span class="line"></span><br><span class="line">    mov ax,4c00h</span><br><span class="line">    int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>这串代码是将 “mov ax, 4c00H”之前的指令复制到内存0:200处，补全程序，上级调试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">首先，在解决两个内存之前的命令的复制的时候，需要用到2个寄存器，一个存放的是目标地址，一个存放的是原地址</span><br></pre></td></tr></table></figure><p>分析这个问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">首先，我们知道的是:我们要把mov ax,4c00H之前的指令复制到内存0:200处</span><br><span class="line"></span><br><span class="line">mov ax,___</span><br><span class="line">mov ds,ax;ds的地址为ax</span><br><span class="line"></span><br><span class="line">看到这里，我们所最后所希望的是什么？</span><br><span class="line">s:mov al,[bx] ;将ds:bx的值赋值给al,这里的ds--&gt;ax</span><br><span class="line">    mov es:[bx],al ;将al的值赋值给es[bx]</span><br><span class="line">    inc bx;bx++</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">这个应该是我们所循环，也就是把命令复制过去的一个执行过程。仔细阅读</span><br><span class="line"></span><br><span class="line">也就是说，把这个命令中的内容是放入al中，然后通过al 放入0:200处【物理地址是00200】【当然我们这个地方，也可以理解成 0020:0处】【这2中写法所得到的物理地址是一样的】</span><br><span class="line"></span><br><span class="line">    mov ax,___</span><br><span class="line">    mov ds,ax;ds的地址为ax</span><br><span class="line">    mov ax,0020h</span><br><span class="line">    mov es,ax;es是20h</span><br><span class="line">    mov bx,0</span><br><span class="line">    mov cx,___</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">因为我们所需要的是:把mov ax,4c00H中的东西放到al中 然后通过al放入0:200处【也就是我们写的es:[bx]中】</span><br><span class="line">然后这里，ds:[bx]中的ds是由 ax决定 ax由我决定，所以这里ax=cs 就可以定位到ax,4c00H之前的内容</span><br></pre></td></tr></table></figure><p>问题1.复制的是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">复制的是，你所写的代码，也就是上面给出的命令， 要将这些代码复制到0:200处</span><br><span class="line">因为复制的是命令，所以要用cs:ip</span><br></pre></td></tr></table></figure><p>问题2.复制的是什么？有多少个字节？你如何知道要复制的字节的数量？</p><p>答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">第一个题是 cs</span><br><span class="line">第二个空是 17H </span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230411122659855.png" alt="image-20230411122659855"></p><p>哈哈哈【不算太理解第二个空耶】</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-第一个程序（4）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-4-%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="1-一个源程序从写出到执行的过程"><a href="#1-一个源程序从写出到执行的过程" class="headerlink" title="1.一个源程序从写出到执行的过程"></a>1.一个源程序从写出到执行的过程</h2><p>1.一个汇编语言从写出到最终执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.编写：用文本编译器，用汇编语言编写编写汇编源程序</span><br><span class="line">记事本，Nodepad++, UltraEdit</span><br><span class="line">2.编译连接</span><br><span class="line">1.使用汇编语言编译程序【MASM.EXE】对源程序文件中的源程序进行编译，生成目标文件</span><br><span class="line">2.用连接程序【LINK.EXE】对目标文件进行连接，生成可在操作系统中直接运行的可执行文件</span><br></pre></td></tr></table></figure><p>2.可执行文件包含：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.程序【从源程序中的汇编指令翻译过来的机器码】和数据【源程序中定义的数据】</span><br><span class="line">2.相关的描述信息【程序有多大，要占多少内存空间】</span><br></pre></td></tr></table></figure><p>3.执行可执行文件的程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.在操作系统中，执行可执行文件中的程序</span><br><span class="line">2.操作系统依照可执行文件中的描述信息，将可执行文件中的机器码和数据加载入内存，并进行相关的初始化（比如：设置CS:IP指向第一条要执行的指令）然后由CPU执行程序</span><br></pre></td></tr></table></figure><h2 id="2-源程序"><a href="#2-源程序" class="headerlink" title="2.源程序"></a>2.源程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure><p>1.汇编指令，有机器码一一对应的，被cpu’执行</p><p>2.伪指令 &gt; 给编译器看的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">segment 和 ends 是一对成对使用的伪指令，这是在写可被编译器编译的汇编程序时，必须要用到的一对伪指令。它们的作用就是定义一个段</span><br><span class="line"></span><br><span class="line">segment 就是段的开始</span><br><span class="line">ends 就是段的结束</span><br><span class="line">一个段，需要由一个段名来标识：</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">        段名 segment</span><br><span class="line">        段名 ends</span><br></pre></td></tr></table></figure><p>3.定义一个段</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一个汇编程序是由多个段组成的，这些段用来存放代码，数据，或者被当作栈空间来使用</span><br><span class="line">2.一个由意义的汇编程序中至少要由一个段，这个段用来存放代码</span><br></pre></td></tr></table></figure><p>4.end是一个汇编程序的结束标记，end是伪指令</p><p>5.assume：假设</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">它假设某一段寄存器和程序中的某个用segment  ends定义的段相关联</span><br><span class="line">通过assume说明这种关联，在需要的情况下，编译程序将段寄存器和某一个具体的段相联系</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">总而言之：就是说assume将有特殊用途的段和相关的段寄存器相关联起来</span><br><span class="line">比如：assume cs:codesg</span><br><span class="line">就是将要用作代码段的段--&gt;codesg【这个是人为起的名字】和CPU中的段寄存器cs联系起</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230409120205822.png" alt="image-20230409120205822"></p><p>！！！重点来了</p><p>源程序文件被编译器编译过后，就编程了程序，放在可执行文件中，可执行文件就是PE的一种格式</p><p>6.标号–相当于指针</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.一个标号指代了一个地址</span><br><span class="line">2.codesg:放在segment的前面，作为一个段的名称，这个段的名称最终被编译连接程序处理为一个段的地址</span><br></pre></td></tr></table></figure><p>7.DOS是一个单认为操作系统</p><p>8.程序返回</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.我们的程序最先以汇编指令的形式存在源程序中，经编译，连接后转变为机器码，存储在可执行文件中。</span><br><span class="line">2.一个程序结束后，将CPU的控制权交还给使他得以运行的程序，这个过程就是：程序返回</span><br><span class="line">3.mov ax,4c00H</span><br><span class="line">int 21H   ； 中断机制</span><br><span class="line">这两条指令所实现的功能就是程序返回</span><br></pre></td></tr></table></figure><h2 id="3-编辑源程序"><a href="#3-编辑源程序" class="headerlink" title="3.编辑源程序"></a>3.编辑源程序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">start: mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00h</span><br><span class="line">int 21h</span><br><span class="line">codesg ends</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">保存到1.asp</span><br></pre></td></tr></table></figure><h2 id="4-编译"><a href="#4-编译" class="headerlink" title="4.编译"></a>4.编译</h2><p>这里我不是很会</p><p>在我的电脑上是用：dosbox </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mount c d:\masm</span><br><span class="line">c:</span><br><span class="line">masm 1.asm</span><br></pre></td></tr></table></figure><p>我学汇编就只是会就好了</p><h2 id="5-连接"><a href="#5-连接" class="headerlink" title="5.连接"></a>5.连接</h2><p>连接是用link</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">具体内容可以查书</span><br></pre></td></tr></table></figure><h2 id="6-以简化的方式进行编译和连接"><a href="#6-以简化的方式进行编译和连接" class="headerlink" title="6.以简化的方式进行编译和连接"></a>6.以简化的方式进行编译和连接</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就是在最后加上  ;  </span><br><span class="line"></span><br><span class="line">masm 1.asp;</span><br></pre></td></tr></table></figure><h2 id="7-exe的执行"><a href="#7-exe的执行" class="headerlink" title="7.exe的执行"></a>7.exe的执行</h2><p>执行就好了三</p><h2 id="8-谁将可执行文件中的程序装载进入内容并使他运行？"><a href="#8-谁将可执行文件中的程序装载进入内容并使他运行？" class="headerlink" title="8.谁将可执行文件中的程序装载进入内容并使他运行？"></a>8.谁将可执行文件中的程序装载进入内容并使他运行？</h2><p>首先来补充一点知识</p><p>操作系统的外壳是什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作系统，都需要提供一个称为shell的程序【用于来操作计算机系统进行工作】</span><br></pre></td></tr></table></figure><p>可执行文件中的程序装入内存并运行的原理</p><p>汇编程序从写出到执行的过程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编程-&gt;1.asm-&gt;编译-&gt;1.obj-&gt;连接-&gt;1.exe-&gt;加载-&gt;内存中的程序-&gt;运行</span><br><span class="line">editmasmlinkcommandcpu</span><br></pre></td></tr></table></figure><h3 id="4-9程序执行过程的跟踪"><a href="#4-9程序执行过程的跟踪" class="headerlink" title="4.9程序执行过程的跟踪"></a>4.9程序执行过程的跟踪</h3><p>首先先写一个东西，放入2.asp中，然后使dosbox </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">masm 2.asp</span><br><span class="line">link 2.obj</span><br><span class="line">debug 2.exe</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line"></span><br><span class="line">fishcc:mov ax,0123H</span><br><span class="line">mov bx,0456H</span><br><span class="line">add ax,bx</span><br><span class="line">add ax,ax</span><br><span class="line"></span><br><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br><span class="line"></span><br><span class="line">codesg ends</span><br><span class="line"></span><br><span class="line">endfishcc</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410125716706.png" alt="image-20230410125716706"></p><p>首先在cs里面是指令的长度</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这里是000F</span><br><span class="line">说明长度是15字节</span><br></pre></td></tr></table></figure><p>在DOS系统中.exe文件中的程序加载过程如下</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410130359400.png" alt="image-20230410130359400"></p><p>我们从上面的那个dos窗口就可以发现CS的值比DS的值要大10H，在计算成段地址后*16后就相当于是大了100H也就是256个字节</p><p>这个是为什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">上图解释得比较清楚</span><br></pre></td></tr></table></figure><p>当然我们也可以看一下这些地方都存了什么JB玩意</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410131327202.png" alt="image-20230410131327202"></p><p>这些应该就是它所说的PSP什么什么的</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410131436362.png" alt="image-20230410131436362"></p><p>这些才是我们写入的指令，也就是程序真正的指令</p><h4 id="很重要的总结"><a href="#很重要的总结" class="headerlink" title="很重要的总结"></a>很重要的总结</h4><p>1.程序加载之后，ds中存放着程序所在内存区的段地址，这个内存区的偏移地址为0，则程序所在的内存区的地址为 ds:0</p><p>2.这个内存区的前256 [100H]个字节中存放的是psp【我也不知道是什么玩意】，反正就是用来dos和程序进行通讯</p><p>3.从256字节处向后的空间存放的是程序【也就是我们写进去的东西】</p><p>4.所以我们在ds中可以得到psp的段地址SA，psp的偏移地址是0，则物理地址就是SA*16+0</p><p>5.因为PSP占256（100H）个字节，所以程序的物理地址是：SA×16+0+256=SA×16+16×16，可用段地址和偏移地址表示SA+10:0【这里是在经过化工场之前，所以是+10而不是100，在经过化工厂后它会向左偏移一位】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用u命令查看一下其他指令：</span><br><span class="line">用T命令单步执行程序中的每一条指令，并观察美条指令执行的结果</span><br><span class="line">到了int21，就需要用p命令执行</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230410132832513.png" alt="image-20230410132832513"></p><p>看到int 21 就用p【屁股一下】</p><p>我们在dos中运行 debug 1.exe的时候</p><p>是command加载debug ，debug加载1.exe<br>所以在退出的时候，要先返回debug  这个就是 p【命令】 然后返回command  这个用 q【命令】</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-寄存器-内存访问（3）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-3-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-3-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="3-1内存种字的存储"><a href="#3-1内存种字的存储" class="headerlink" title="3.1内存种字的存储"></a>3.1内存种字的存储</h2><p>1.一个内存单元的大小是1B，任何两个地址连续的内存单元，N号单元和N+1号单元，可以将他们看成两个内存单元，也可以看出一个地址为N的字单元中的高位字节单元和低位字节单元</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406150702374.png" alt="image-20230406150702374"></p><p>**两个十六进制位是一个字节</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0地址单元中存放的字节型数据：20H</span><br><span class="line">0地址单元中存放的字型数据：4E20H</span><br><span class="line"></span><br><span class="line">后面的是高位</span><br></pre></td></tr></table></figure><h2 id="3-2DS和-address"><a href="#3-2DS和-address" class="headerlink" title="3.2DS和[address]"></a>3.2DS和[address]</h2><p>1.CPU要读取一个内存单元的时候，必须先给出 这个单元的地址；</p><p>2.在8086CPU中，内存地址由段地址和偏移地址组成</p><p>3.8086CPU中由一个DS寄存器，通常用来存放要访问的数据的段地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CS寄存器就是当前要读取指令的地址。</span><br></pre></td></tr></table></figure><p>4.例子：我们要读取1000H单元的内容，可以用如下的程序进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov bx,1000H//这里就是在bx寄存器中放入了1000H这个数据</span><br><span class="line">mov ds,bx//把bx寄存器中的1000H数据放到DS寄存器中</span><br><span class="line">mov al,[0]//[0],这里是偏移地址的意思，CPU在用到偏移地址的时候，会先去找到段地址，在第二部已经把段地址设置成1000H了，所以这句话的意思就是把地址位1000:0的数据放入al寄存器中【这个al的寄存器是ax下的一个low低位寄存器】</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">这里不能mov dx,1000H</span><br><span class="line">只能通过通用寄存器导过来</span><br></pre></td></tr></table></figure><p>5.mov指令的功能</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.将数据之间送入寄存器；【不能直接放入段寄存器】</span><br><span class="line">mov ax,2</span><br><span class="line">2.将一个寄存器中的内容送入另一个寄存器中</span><br><span class="line">mov ax,bx</span><br><span class="line">【通过这种方式来送入段寄存器】</span><br><span class="line">3.将一个内存单元中的内容送入一个寄存器</span><br><span class="line">mov ax,[0]</span><br><span class="line">某个内存单元中的内容，需要用DS[address]指向这个地址后，才会送入另外一个寄存器</span><br><span class="line">也就是说，在有[]的时候是去直接读取DS和address[偏移地址]找到这个地址里面的内容，放入ax寄存器中</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,bx ==&gt;寄存器寻址 </span><br><span class="line">mov ax,1000H  ==&gt;立即寻址</span><br><span class="line">mov ax,[0]  ==&gt;直接寻址</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">在修改DS段寄存器中的内容的时候是：利用了通用寄存器结合mov实现的</span><br><span class="line"></span><br><span class="line">但是修改CS段的寄存器的时候是直接使用jmp命令修改的</span><br><span class="line">jmp DS:IP  --&gt; 这个就是DS和IP一起修改</span><br><span class="line">jmp ax--&gt;这个就是DS不变，IP变成AX寄存器中的值</span><br></pre></td></tr></table></figure><p>6.写几条指令，将al中的数据送入内存单元10000H？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov BX,1000H</span><br><span class="line">mov DS,BX</span><br><span class="line">mov [0],AL</span><br><span class="line">这里是把数据放入某单元</span><br></pre></td></tr></table></figure><h2 id="3-3字的传送"><a href="#3-3字的传送" class="headerlink" title="3.3字的传送"></a>3.3字的传送</h2><p>1.因为8086CPU是16位结构，有16根数据线，所以一次性传入16位的数据，也就是一次性传送一个字</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">比如：</span><br><span class="line">mov bx,1000H</span><br><span class="line">mov ds,bx  //前面俩个是为了确定段地址</span><br><span class="line">mov ax,[0]//1000:0处的字型数据送入ax中</span><br><span class="line">mov [],cx//cx中16位数据送到1000:0处</span><br></pre></td></tr></table></figure><h3 id="小结一下【实验】P14"><a href="#小结一下【实验】P14" class="headerlink" title="小结一下【实验】P14"></a>小结一下【实验】P14</h3><p>首先CS:IP 和 DS[偏移地址]是密不可分的【好像有点奇怪，现在姑且这样理解】</p><p>CS:IP确定了指向命令的地址 【在我看来就是地址总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">好像也不是很对，emmmm，反正就是说在CS:IP的地址中的内容可以放入命令，然后进行执行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">首先在地址中写入要执行命令的汇编指令，</span><br><span class="line">然后用CS:IP指向这些地址，在运行的时候，这些地址里面的内容就会指向命令</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406160947921.png" alt="image-20230406160947921"></p><p>通过运行CS:IP地址中的内容就可以去改变DS中的内容，然后读取DS地址中的内容放入或者运算入AX BX CX DX通用寄存器中</p><p>DS确定了读取数据的地址 【在我看来就是数据总线】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反正就是说运行的命令，都是在CS:IP地址中的内容，如果CS:IP中的某些命令需要用到DS，则就会去调用DS[]地址中的值。</span><br><span class="line">差不多就是这个意思</span><br></pre></td></tr></table></figure><p>当通用寄存器用的是X的时候【16位的时候】就需要把该地址和该地址+1的内容当作字来看</p><p>但是如果使用的是L/H的时候，就需要当作字节来看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">因为，这个传入的内容不能大于放入的寄存器</span><br><span class="line">mov ax,[0]//这样就是当作字来看，因为ax寄存器中可以存16位【一个字】</span><br><span class="line">mov al,[0]//这样就要当作字节来看，因为al寄存器中只能放入8位【一个字节】</span><br><span class="line"></span><br><span class="line">寄存器有多大，就放多少，在选中的该地址往后加就好了</span><br><span class="line">以寄存器为标准，内存按照寄存器的大小对寄存器放入值</span><br></pre></td></tr></table></figure><h2 id="3-4mov-add-sub指令"><a href="#3-4mov-add-sub指令" class="headerlink" title="3.4mov,add, sub指令"></a>3.4mov,add, sub指令</h2><p>1.mov</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">已知：</span><br><span class="line">mov 寄存器，数据</span><br><span class="line">mov ax,100</span><br><span class="line">mov 寄存器，寄存器</span><br><span class="line">mov ax,bx</span><br><span class="line">mov 寄存器，内存单元 //内存单元这里就是DS[address]指向的位置</span><br><span class="line">mov ax,[0]</span><br><span class="line">mov 内存单元，寄存器</span><br><span class="line">mov [0],ax</span><br><span class="line">mov 段寄存器，寄存器</span><br><span class="line">mov ds,ax</span><br><span class="line">新的：</span><br><span class="line">mov 寄存器，段寄存器</span><br><span class="line">mov ax,ds</span><br></pre></td></tr></table></figure><p> 2.add【➕】和sub【➖】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">add 寄存器，数据</span><br><span class="line">add ax，3</span><br><span class="line">add 寄存器，寄存器</span><br><span class="line">add ax，bx</span><br><span class="line">add 寄存器，内存单元</span><br><span class="line">add ax，[0]</span><br><span class="line">add 内存单元，寄存器</span><br><span class="line">add [0]，ax</span><br><span class="line">注意：！！！</span><br><span class="line">add不能对段寄存器进行操作</span><br><span class="line">比如：add ds，ax  ==&gt;  这样是错误的！！【段寄存器不是这么用的，所以没有设置这个功能】</span><br><span class="line"></span><br><span class="line">##然后sub和add完全一样</span><br></pre></td></tr></table></figure><h2 id="3-5数据段"><a href="#3-5数据段" class="headerlink" title="3.5数据段"></a>3.5数据段</h2><p>1.前面讲过，对于8086PC机，我们可以根据需要将一组内存单元定义为一个段（这个段，可以是代码段，也可以是数据段）</p><p>2.我们可以将一组长度为N(N&lt;=64K)，地址连续，起始地址是16的倍数的内存单元当作专门存储数据的内存空间，这个空间就是定义的数据段</p><p>3.比如我们用123BOH~123B9H这段空间来存放数据：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">段地址：123BH  ==&gt;这里会经过加工厂*16=123BOH</span><br><span class="line">长度是10字节【123B0~123B9有10个存储单元【一个存储单元就是1B】】</span><br></pre></td></tr></table></figure><p>4.如何访问你数据段的中数据？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目1：我们将123BOH~123BAH的内存单元定义为数据段，我们现在要累加这个数据段中的前3个单元中的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">解：</span><br><span class="line">mov ax,123BH</span><br><span class="line">mov ds,ax</span><br><span class="line">mov al,0//因为数题目是前三个单元中的数据，每一个存储单元的大小是1B也就是8位，所以这里需要使用低位的al 而不是 使用ax，如果使用ax的话，就会把数据放入字中【16位】这样所求得的就不是前三个单元中的数据的累加，而是前三个字中数据的累加</span><br><span class="line">add al,[0]//计算机都是从0开始哦</span><br><span class="line">add al,[1]</span><br><span class="line">add al,[2]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">题目2：我们将123BOH~123BAH的内存单元定义为数据段，我们现在要累加这个数据段中的前3个字型中的数据</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这里就是把al改成ax就好啦，当然偏移地址也要累加2【懂的都懂，不懂的就别学了】</span><br><span class="line">add ax,[0]//为了放入ax中其实这里是[0]放入低位[1]放入高</span><br><span class="line">add ax,[2]</span><br><span class="line">add ax,[4] </span><br><span class="line">注意：一个字型数据占2个单元，所以偏移地址是0，2，4</span><br></pre></td></tr></table></figure><h3 id="3-1-3-5小结一下"><a href="#3-1-3-5小结一下" class="headerlink" title="3.1~3.5小结一下"></a>3.1~3.5小结一下</h3><p>1**.字在内存中存储的时候，要用俩个地址连续的内存单元来存放，字的低位字节【al】存放在低地址单元【0】中，高位字节【ah】存放在高地址单元【1】中</p><p>2.用mov指令要访问内存单元，可以在mov指令中只给处单元的偏移地址，此时，段地址默认在DS寄存器中</p><p>3.[address]表示一个偏移地址位address的内存单元</p><p>4.在内存和寄存器之间传送字型数据时，高地址单元和高8位寄存器，低地址单元和低8位寄存器相对应</p><p>5.mov add sub 是具有两个操作对象的指令。jmp是具有一个操作对象的指令</p><p>6.可以根据自己的推测，在debug中实验指令的新格式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">根据弹幕： mov ax,1000:[0]  ==&gt;  这样不error的【我也不确定】</span><br></pre></td></tr></table></figure><h2 id="3-6栈"><a href="#3-6栈" class="headerlink" title="3.6栈"></a>3.6栈</h2><p>1.我们研究栈的角度：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">首先：栈是内存空间的一部分</span><br><span class="line"></span><br><span class="line">栈是一种具有特殊的访问方式的存储空间，它的特殊性就在于，最后进入这个空间的数据，最先出去【迟到早退】</span><br></pre></td></tr></table></figure><p>2.栈有俩个基本的操作：入栈和出栈</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">入栈：将一个新的元素放到栈顶</span><br><span class="line">出栈：从栈顶取出一个元素</span><br></pre></td></tr></table></figure><p>3.栈顶的元素总是最后入栈，需要出栈的时候，又是最先被从栈中取出</p><p>4.栈的操作规则：LIFO</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Last In First Out</span><br><span class="line">后进先出</span><br></pre></td></tr></table></figure><h2 id="3-7CPU提供的栈机制"><a href="#3-7CPU提供的栈机制" class="headerlink" title="3.7CPU提供的栈机制"></a>3.7CPU提供的栈机制</h2><p>1.如今的CPU中都有栈的设计</p><p>2.8086CPU提供相关的指令来以栈的方式访问内存空间</p><p>3.这意味着，我们在基于8086CPU编程的时候，可以将一段内存当作栈来使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">只是我们当作栈来使用，sb计算机只会0和1</span><br></pre></td></tr></table></figure><p>4.8086CPU提供入栈和出栈指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">最基本：</span><br><span class="line">PUSH:（入栈）【入就入到最底部】</span><br><span class="line">POP（出栈）【出就是从顶部出】</span><br><span class="line">push ax：将寄存器ax中的数据送入栈中</span><br><span class="line">pop ax：从栈顶取出数据放入ax</span><br></pre></td></tr></table></figure><p>5.8086CPU的入栈和出栈操作都是以字【16位】为单位进行【这个是因为8086CPU内部是以16位为单位运算的，现在都是32/64位咯】</p><p>6.CPU如何知道一段内存空间被当作栈使用？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">首先我们知道</span><br><span class="line">段寄存器CI:IP所指向的就是指令</span><br><span class="line">段寄存器DS所指向的就是数据</span><br><span class="line">所以，以此类推，肯定有一个栈寄存器</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在8086CPU中，有俩个寄存器：</span><br><span class="line">段寄存器SS ：存放栈顶的段地址</span><br><span class="line">寄存器SP : 存放栈顶的偏移地址</span><br><span class="line">任意时刻，SS:SP指向栈顶元素</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这里我们要注意的是：栈顶不是某个栈的顶部，而是某栈存放了数据，然后栈顶就是最后放入数据的位置</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406173524469.png" alt="image-20230406173524469"></p><p>7.在执行PUSH和POP的时候，如何知道那个单元是栈顶单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在指向PUSH和POP的时候，栈顶的位置是动态变化的，那么它是如何知道的呢？</span><br></pre></td></tr></table></figure><h3 id="push-ax"><a href="#push-ax" class="headerlink" title="push ax"></a>push ax</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个步骤在计算机中其实是两步</span><br><span class="line">1.SP=SP-2//这里是-2而不是+2的原因是：在push的时候，数据会首先放入栈的最底部【也就是偏移地址最大的时候，高地址】</span><br><span class="line">//这个就类似于IP=IP+所读指令长度</span><br><span class="line">2.将ax中的内容送入SS:SP指向的内存单元出【字】，SS:SP此时指向新栈顶</span><br></pre></td></tr></table></figure><h3 id="pop-ax"><a href="#pop-ax" class="headerlink" title="pop ax"></a>pop ax</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">就是push的逆运算</span><br><span class="line">1.将SS:SP指向的字中的内容放入ax后</span><br><span class="line">2.SP=SP+2</span><br><span class="line"></span><br><span class="line">在使用POP之后，取出来原来地址上的内容还是存在的，【可以理解成，SP变了，只是把内容copy出去了】</span><br><span class="line">内存中的数据是不会被删除，只能一次一次的被覆盖被覆盖</span><br></pre></td></tr></table></figure><p>8.问题：如果我们将10000H~1000FH这段空间当作栈，初始状态栈是空的，此时SS=1000H,那SP=？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">当然是不是000FH啦</span><br><span class="line">**是最高单元的下一个地址</span><br><span class="line">SP=0010</span><br><span class="line">因为只有指向最高单元的下一个地址</span><br><span class="line">在push 的时候，整出俩个地址才会对应上哦</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230406201341990.png" alt="image-20230406201341990"></p><p>换个角度看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.任何时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就步存在栈顶元素</span><br><span class="line">2.所以在栈为空的时候，SS:SP就只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址+2【这里是字单元，如过是字节的话，就是+1】</span><br><span class="line">3.栈最底部子单元地址是1000:000E,所以栈为空的时候，SP=0010H</span><br></pre></td></tr></table></figure><h2 id="3-8栈顶超界的问题"><a href="#3-8栈顶超界的问题" class="headerlink" title="3.8栈顶超界的问题"></a>3.8栈顶超界的问题</h2><p>1.SS和SP只记录了栈顶的地址，依靠SS和SP可以保证在入栈和出栈的时候找到栈顶。</p><p>2.但是，如何能够保证在入栈和出栈的时候，栈顶不会超出栈空间</p><p>3.当栈满的时候在使用PUSH指令入栈，栈空的时候在使用POP指令出栈，都会发生栈顶出界的问题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哟~出现了溢出</span><br><span class="line">向上的溢出--push</span><br><span class="line">向下的溢出--pop</span><br></pre></td></tr></table></figure><p>4.栈顶越界是危险的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">因为我们既然将一段空间安排为栈，那么在占空间之外的空间里面很可能存放了具有其他用途的数据，代码。这些数据，代码可能是我们自己程序中的，也可能是贝格程序中的（毕竟一个计算机系统并不是只有我们自己程序在运行）</span><br><span class="line"></span><br><span class="line">相当于在溢出的时候，可以用PUSH或POP把栈之外的内容给搞出来，然后就会出现一些泄露或者，覆盖掉其他的东西。【类似吧】</span><br></pre></td></tr></table></figure><p>5.但是由于我们在入栈和出栈时候的不小心（故意）加上一些其他工具【乱说的，可能可以把这些内容收集起来，就可以无限可能】</p><p>6.8086CPU不保证对栈的操作不会越界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">8086CPU只知道栈顶在何处</span><br><span class="line">因为栈的大小是我们自己定义的，CPU不知道我们定义了多大，不知上线和下线，所以CPU就会很SB的以为还在栈里面【但是这个时候已经跑出去了】</span><br><span class="line">CPU只知道要执行的栈顶在何处，但是不知道要栈空间的大小是多少</span><br></pre></td></tr></table></figure><p>7.总的一句话，我要想办法使他溢出【哈哈】</p><h2 id="3-9PUSH和POP指令"><a href="#3-9PUSH和POP指令" class="headerlink" title="3.9PUSH和POP指令"></a>3.9PUSH和POP指令</h2><p>1.首先PUSH和POP是可以在寄存器和内存之间传送数据的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.栈空间是内存空间的一部分，它只是一段可以以一种特殊的方式进行访问的内存空间</span><br></pre></td></tr></table></figure><p>2.看看POP和PUSH指令的格式把</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">通用寄存器：</span><br><span class="line">1.PUSH 寄存器：将一个寄存器中的数据入栈</span><br><span class="line">2.POP 寄存器：出栈，用一个寄存器接受出栈的数据</span><br><span class="line">段寄存器：</span><br><span class="line"> 1.PUSH 段寄存器：将一个段寄存器中的数据入栈</span><br><span class="line"> 2.POP 段寄存器：出栈，用一个段寄存器接受出栈的数据</span><br><span class="line"> 【也就是说，PUSH和POP可以对段寄存器使用】</span><br><span class="line"> 【补充，ADD和SUB不能对段寄存器使用】</span><br><span class="line">内存单元：</span><br><span class="line">1.PUSH 内存单元：将一个内存单元处的字入栈（栈操作都是以字为单位）</span><br><span class="line">2.POP内存单元：出栈，用一个内存字单元接收出栈的数据</span><br><span class="line">PUSH [0] //字型的数据</span><br><span class="line">POP [2]</span><br><span class="line"></span><br><span class="line">指令执行的时候，CPU要知道内存单元的地址，可以在PUSH POP 指令中给处内存单元的偏移地址，段地址在指令执行的时候,CPU从DS取得</span><br><span class="line"></span><br><span class="line">数据的段地址在ds中获得   用[]来偏移地址</span><br><span class="line">代码的段地址在cs中获得   用ip来偏移地址</span><br><span class="line">栈的段地址在ss中获得    用sp来偏移地址</span><br></pre></td></tr></table></figure><h3 id="问题1："><a href="#问题1：" class="headerlink" title="问题1："></a>问题1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编程将10000H~1000FH这段空间当作栈，初始状态是空的，将AX,BX,DS中的数据入栈</span><br><span class="line">入栈就是push</span><br></pre></td></tr></table></figure><p> 解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.mov ax,1000H</span><br><span class="line"></span><br><span class="line">2.mov ss,ax //这里之前说过，段地址不能直接用数据，必须得用通用寄存器来过度。所以这里先把1000H存入ax，后放入ss</span><br><span class="line"></span><br><span class="line">3.mov sp,0010H //这个sp不是段寄存器，段寄存器【CS,DS,SS,ES】.这里为什么是0010H呢？因为栈是到1000FH所以要指向这个的下一个</span><br><span class="line"></span><br><span class="line">4.push ax</span><br><span class="line">5.push bx</span><br><span class="line">6.push ds</span><br></pre></td></tr></table></figure><h3 id="问题2："><a href="#问题2：" class="headerlink" title="问题2："></a>问题2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.将10000H~1000FH这段空间当作栈，初始状态是空的</span><br><span class="line">2.设置AX=001AH,BX=001BH</span><br><span class="line">3.将AX BX 中的数据入栈</span><br><span class="line">4.然后将AX BX 清零</span><br><span class="line">5.从栈中恢复AX BX 原来的内容</span><br></pre></td></tr></table></figure><p>解答：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个很简单啦，要注意的是</span><br><span class="line">最后进入的最先出来的</span><br><span class="line">清零是</span><br><span class="line">sub ax,ax或者mov ax,0 或者xor ax,ax[这个是异或]</span><br></pre></td></tr></table></figure><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.将10000H~1000FH这段空间当作栈，初始状态是空的</span><br><span class="line">2.设置AX=002AH,BX=002BX</span><br><span class="line">3.利用栈，交换AX和BX中的数据</span><br></pre></td></tr></table></figure><p>解答</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ax</span><br><span class="line">push bx</span><br><span class="line">pop ax //把原来bx的值放入ax</span><br><span class="line">pop bx //把原来ax的值放入bx</span><br></pre></td></tr></table></figure><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果要在10000H处写入字型数据2266H这么搞？</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax // 这步就是要让ds段寄存器指向1000H</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax //把2266H的值放入10000H</span><br><span class="line">相当于100000H是66；100001H是22</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">现在进阶</span><br><span class="line">1.________</span><br><span class="line">2.________</span><br><span class="line">3.________</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line"></span><br><span class="line">完成代码，实现上诉的结果</span><br></pre></td></tr></table></figure><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">分析一波，我们看哈，最后俩个是：</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line">读一下：这里是把2266H放入ax寄存器中，然后通过栈的PUSH把ax寄存器中的内容push进10000H处</span><br><span class="line">所以：我们需要在这个之前需要把栈的指针指向10000H处</span><br><span class="line">所以:</span><br><span class="line">1.mov ax,1000H</span><br><span class="line">2.mov ss,ax</span><br><span class="line">3.mov sp,2  //这里要想明白：sp的步骤是什么先-2后入栈，这里后面push ax,指针是在10002H的位置，然后push ax 也就是说在10001H的位置会存入22，10000H的位置会存入66</span><br><span class="line"></span><br><span class="line">这个指针是sp-2是往上【低】走</span><br></pre></td></tr></table></figure><p>总的分析：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">我想问一下:我这样的分析是不是对的</span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ds,ax</span><br><span class="line">mov ax,2266H</span><br><span class="line">mov [0],ax</span><br><span class="line"></span><br><span class="line">如果cpu运行了这段命令，然后在地址10000H处和10001H处10002H处的内容是什么？</span><br><span class="line">【我本身想实验的，但是在win11下没有debuf，然后虚拟机我没有下xp，由于急于想知道答案所以没有下】【附加上我不知道还有什么调试器可以用-目前只知道debug】</span><br><span class="line">我感觉像是：，然后在10000H中存入的是66 在10001H中是22</span><br><span class="line">【因为电子书--王爽的汇编在3.1~3.5的小结里面有字在内存中存储的时候，需要用2个连续的内存单元来存放，字的低位字节存放在低地址中[这里我认为是al]高位字节放入高地址中[这个我认为是ah]】</span><br><span class="line"></span><br><span class="line">然后在3.9中的问题3.10中有一个</span><br><span class="line"></span><br><span class="line">mov ax,1000H</span><br><span class="line">mov ss,ax</span><br><span class="line">mov ap,2</span><br><span class="line">mov ax,2266H</span><br><span class="line">push ax</span><br><span class="line">这样的代码是等价于上面的代码【书上这么说的】</span><br><span class="line"></span><br><span class="line">分析这个命令：栈的段地址是1000H，然后偏移地址是0002，所以组合在一起这个地址是10002H</span><br><span class="line">然后在push,ax的时候【这个ax里面是2266】</span><br><span class="line">在高地址中存入的是22【10001H】低地址存入的是66【10000H】</span><br></pre></td></tr></table></figure><h3 id="问题得出的结论"><a href="#问题得出的结论" class="headerlink" title="问题得出的结论"></a>问题得出的结论</h3><p>1.PUSH和POP实质上是一种内存传送指令，可以在寄存器和内存之间传送数据，和mov指令不同的是，push和pop指令访问的内存单元的地址不是在指令中给出的，而是由SS:SP指出的</p><p>2.同时，push和pop指令还会改变sp的内容</p><h2 id="3-10栈段"><a href="#3-10栈段" class="headerlink" title="3.10栈段"></a>3.10栈段</h2><p>1.段–&gt;就是一组内存单元</p><p>2.我们可以将长度为N(&lt;=64K)的一组地址连续，起始地址为16倍数的内存单元，当作栈来用，从而定义了一个栈段</p><p>3.将内存当作栈段，只是我们在编程时候的一种安排，CPU并不会知道这个空间,CPU只知道SS:SP。</p><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><p>如果我们将10000H~1FFFFH这段当作栈段是，初始状态是空的，此时SS=1000H那么SP是多少呢？</p><p>解：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">猜测的是:超出了啊不知道了FFFF已经是64KB了</span><br><span class="line"></span><br><span class="line">这里emmm SP=0</span><br></pre></td></tr></table></figure><p>换一个角度看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">任何时刻，SS:SP指向栈顶元素，当栈为空的时候，栈中没有元素，也就不存在栈顶元素，所以SS:SP只能指向栈的最底部单元下面的单元，该单元的偏移地址是栈最底部的字单元的偏移地址+2，栈最底部字单元的地址为1000:FFFE,所以栈空的时候，SP=0000H</span><br></pre></td></tr></table></figure><p> 栈的作用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">就是拿来临时保存东西的</span><br><span class="line">大概就是用来封装函数</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1.我们可以将一段内存定义为一个段，用一个段地址来指示段，用偏移地址访问段内的单元。【这完全是我们的安排】</p><p>2.我们可以用一个段存放数据，将它定义成“数据段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DS:[]</span><br><span class="line">CPU就将我们定义的数据段中的内容当作数据来访问</span><br><span class="line">比如mov add sub </span><br></pre></td></tr></table></figure><p>我们可以用一个段存放代码，将它定义成“代码段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS:IP</span><br><span class="line">CPU就将执行我们定义的代码段中的指令</span><br></pre></td></tr></table></figure><p>我们可以用一个段当作  栈，将它定义成“栈段”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SS:SP</span><br><span class="line">CPU在需要进行栈操作的时候，执行PUSH POP 指令的时候，就将我们定义的栈段当作栈空间来使用</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8086汇编-寄存器-CPU互作原理（2）</title>
      <link href="/2023/05/01/8086%E6%B1%87%E7%BC%96-2-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%E4%BA%92%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/"/>
      <url>/2023/05/01/8086%E6%B1%87%E7%BC%96-2-%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88CPU%E4%BA%92%E4%BD%9C%E5%8E%9F%E7%90%86%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="CPU概述"><a href="#CPU概述" class="headerlink" title="CPU概述"></a>CPU概述</h2><p>1.一个典型的CPU由运算器，控制器，寄存器等器件组成，这些器件靠内部的总线相连</p><p>2.区别：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">内部总线：是CPU内部的【用于运算器，控制器，寄存器】</span><br><span class="line">外部总线：是我们之间学的那些【用于和主板联系的--&gt;地址总线，数据总线，控制总线】</span><br></pre></td></tr></table></figure><p>3.内部总线实现CPU内部各个器件之间的联系</p><p>4.外部总监实现CPU和主板上其他器件的联系</p><h2 id="寄存器概述"><a href="#寄存器概述" class="headerlink" title="寄存器概述"></a>寄存器概述</h2><p>1.8086CPU有14个寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AX,BX,CX,DX,SI,DI,SP,BP,IP,CS,SS,DS,ES,PSW</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="2-1通用寄存器"><a href="#2-1通用寄存器" class="headerlink" title="2.1通用寄存器"></a>2.1通用寄存器</h3><p>1.8086CPU所有的寄存器都是16位的，可以存放2个字节，也就是一个字</p><p>2.AX  BX  CX  DX  通常用来存放一般性数据被称为通用寄存器</p><p>3.AX</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405132751383.png" alt="image-20230405132751383"></p><p>一个16位寄存器可以存储一个16位的数据</p><p>比如：数据18  –&gt; 二进制表示是10010</p><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405132946340.png" alt="image-20230405132946340">  </p><p>一个16位寄存器所能存储的数据的最大值是多少呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2^16 - 1   --&gt;  二进制就是1111,1111,1111,1111</span><br></pre></td></tr></table></figure><p>4.为了保持和上一代CPU中的寄存器【都是8位】的兼容性，这4个寄存器可以分为2个独立的8位寄存器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AX--&gt;AH AL  [high low]</span><br><span class="line">AL:0~7位</span><br><span class="line">AH:8~15位</span><br><span class="line">AL 和 AH 是可以独立使用的8位寄存器</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405133854304.png" alt="image-20230405133854304"></p><h3 id="2-2字在寄存器中的储存"><a href="#2-2字在寄存器中的储存" class="headerlink" title="2.2字在寄存器中的储存"></a>2.2字在寄存器中的储存</h3><p>1.一个字可以存放一个16位寄存器中，这个字的高位字节和低位字节自然就存在这个寄存器的高8位和低8位寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">字 --&gt; word</span><br><span class="line">1word=2Byte=16bit</span><br></pre></td></tr></table></figure><h4 id="关于数制的讨论"><a href="#关于数制的讨论" class="headerlink" title="关于数制的讨论"></a>关于数制的讨论</h4><p>1.由于1个内存单元可以放8位数据，CPU中的寄存器又可放N个8位数据。也就是说，计算机中的数据大多是由1~N个8位数据构成的。【进制转换的课程，有时间一定要去看啊】</p><p>2.用十六进制来表示数据可以直观的看出这个数据是由那些8位数据构成【每两位对应一个八进制】【4位对应一个16进制】</p><p>3.十六进制后面+H ； 二进制后面+B ； </p><h3 id="2-3几条汇编指令"><a href="#2-3几条汇编指令" class="headerlink" title="2.3几条汇编指令"></a>2.3几条汇编指令</h3><p>1.汇编的指令是不分大小写的</p><p>汇编指令                                控制CPU完成的操作                                        高级语言的写法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">move ax,18将18送入AXAX=18</span><br><span class="line">move ah,78将78送入AHAH=78</span><br><span class="line">add ax,8将寄存器AX中的值加上8AX=AX+8</span><br><span class="line">move ax,bx将寄存器BX中的数据送入寄存器AX中AX=BX</span><br><span class="line">add ax,bx将AX,BX中的内容相加，结果存在AX中AX=AX+BX</span><br><span class="line"></span><br><span class="line">在使用add的时候如果存放的数值大于了寄存器的容量怎么办？</span><br><span class="line">AX寄存器就存放2个字节，取后面的，前面的舍去掉（舍去的部分取哪里了，后面再说）</span><br><span class="line">比如：mov ax,8226H    mov bx,8226H</span><br><span class="line">add ax,bx</span><br><span class="line">这个时候的ax中的值是044cH</span><br><span class="line">但是8226H+8226H=1044c的，前面的1被抛弃</span><br><span class="line">同理：如果使用的是AL或者AH，虽然这俩个是AX分出来，但是在AL溢出的时候，也是只能放后面的</span><br><span class="line"></span><br><span class="line">比如AX中的值是00C5H</span><br><span class="line">add al,93H     ------&gt; c5+93=158 </span><br><span class="line">最后得出的AX的值是0058H</span><br></pre></td></tr></table></figure><p>**这里的丢失，指的是进制不能再8位寄存器中保存，但是CPU不是真正的抛弃这个进制位</p><h3 id="2-4物理地址"><a href="#2-4物理地址" class="headerlink" title="2.4物理地址"></a>2.4物理地址</h3><p>1.CPU访问内存单元时要给出内存单元的地址。所有的内存单元构成了存储空间是一个一维的线性空间</p><p>2.我们将这个唯一的地址称为物理地址</p><h3 id="2-6-16位结构的CPU"><a href="#2-6-16位结构的CPU" class="headerlink" title="2.6 16位结构的CPU"></a>2.6 16位结构的CPU</h3><p>1.概括的讲，16位结构描述了一个CPU具有一下几个方面的特征</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.运算器一次最多可以处理16位的数据</span><br><span class="line">2.寄存器的最大宽度是16位</span><br><span class="line">3.寄存器和运算器之间的通路是16位的</span><br></pre></td></tr></table></figure><p>2.8086CPU给出物理地址的方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.8086有20位地址总线，可传送20位地址，寻址能力是1M</span><br><span class="line">2.8086内部为16位结构，它只能传送16位的地址，表现出的寻址能力却只有64K</span><br></pre></td></tr></table></figure><p>3.问题：那么，8086CPU如何用内部16位的数据转化成20位的地址呢?</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">8086CPU采用一种再内部用俩个16位地址合成的方法形成一个20位的物理地址</span><br><span class="line"></span><br><span class="line">1.CPU中的相关部件提供两个16位的地址，一个称为段地址，另一个称为偏移地址</span><br><span class="line">2.段地址和偏移地址通过内部总线送入一个称为地址加法器的部件；</span><br><span class="line">3.地址加法器将两个16位地址合并成一个20位的地址</span><br><span class="line">4....</span><br></pre></td></tr></table></figure><p><img src="https://cdn.staticaly.com/gh/re-again/pic_bed@main/md/image-20230405175513882.png" alt="image-20230405175513882"></p><h3 id="2-7地址加法器的互作原理"><a href="#2-7地址加法器的互作原理" class="headerlink" title="2.7地址加法器的互作原理"></a>2.7地址加法器的互作原理</h3><p>问题：地址加法器的互作原理</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">地址加法器合成物理地址的方法：</span><br><span class="line">物理地址=段地址*16+偏移地址</span><br></pre></td></tr></table></figure><p><img src="C:\Users\ASUS\AppData\Roaming\Typora\typora-user-images\image-20230405180149132.png" alt="image-20230405180149132"></p><p>5.由段地址* 16引发的血案….</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">段地址*16 ==&gt; 有一个更常用的说法，就是数据左移4位（二进制位）</span><br><span class="line">移位位数二进制十六进制  十进制</span><br><span class="line">010B2H2</span><br><span class="line">1100B4H4</span><br><span class="line">21000B8H8</span><br><span class="line">310000B10H16</span><br><span class="line">4100000B20H32</span><br></pre></td></tr></table></figure><p>通过观察我们发现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.一个数据的二进制[16进制]形式左移1位，相当于该数*2[*16]</span><br><span class="line">2.一个数据的二进制形式左移N位，相当于该数*2的N次方</span><br><span class="line">3.所以段地址*16的运算就是，以二进制形式存放的段地址左移4位</span><br></pre></td></tr></table></figure><p>段地址*16+偏移地址=物理地址的本质含义</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.基础地址+偏移地址=物理地址</span><br><span class="line">2.段地址*16+偏移地址=物理地址</span><br><span class="line">就是说CPU一次只能提供不够的，第一个地址进行*16后加上去就是物理地址</span><br></pre></td></tr></table></figure><h3 id="2-8段的概念"><a href="#2-8段的概念" class="headerlink" title="2.8段的概念"></a>2.8段的概念</h3><p>1.错误的认识</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存被划分成了一个一个的段，没一个段有一个段地址</span><br></pre></td></tr></table></figure><p>2.其实</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">内存并没有分段，段的划分来自于CPU，由于8086CPU“用（段地址*16）+偏移地址=物理地址”的方式给出内存单元的物理地址，使得我们可以用分段的方式来管理内存</span><br></pre></td></tr></table></figure><p>3.以后在编程的时候，将若干个连续的内存单元看作一个段，用段地址*16 定位段的起始地址（基础地址）用偏移地址定位段中的内存单元</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.段地址*16必然十16的倍数，所以一个段的起始地址也一定是16的倍数</span><br><span class="line">2.偏移地址为16位，16位地址的寻址能力为64K,所以一个段的长度最大是64K</span><br></pre></td></tr></table></figure><h3 id="内存单元地址小结"><a href="#内存单元地址小结" class="headerlink" title="内存单元地址小结"></a>内存单元地址小结</h3><p>1.CPU访问内存单元的时候，必须向内存提供内存单元的物理地址</p><p>2.8086CPU在内部用段地址和偏移地址移位相加的方法形成最终的物理地址。</p><p>3.一个物理地址，可以由很多种段地址和偏移地址形成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>4.给定一个段地址，仅通过变化偏移地址来寻，最多可以定位64KB个内存单元</p><h3 id="没有小结的小结"><a href="#没有小结的小结" class="headerlink" title="没有小结的小结"></a>没有小结的小结</h3><p>1.段地址和偏移地址</p><p>2.数据在21F60H内存单元中。对于8086PC机中有俩种描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1.数组存在内存2000:1F60单元种</span><br><span class="line">2.数据存在内存的2000段种的1F60H单元种</span><br></pre></td></tr></table></figure><p>3.可以根据需要，将地址连续，起始地址为16的位数的一组内存单元定义为一个段</p><h3 id="2-9段寄存器"><a href="#2-9段寄存器" class="headerlink" title="2.9段寄存器"></a>2.9段寄存器</h3><p>1.段寄存器就是提供段地址的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8086CPU有4个段寄存器</span><br><span class="line">CS  DS  SS  ES </span><br></pre></td></tr></table></figure><p>2.当8086CPU要访问内存时，由这四个段寄存器提供内存单元的段地址</p><h3 id="2-10CS和IP"><a href="#2-10CS和IP" class="headerlink" title="2.10CS和IP"></a>2.10CS和IP</h3><p>1.CS和IP是8086CPU中最关键的寄存器，它们指示了CPU当前要读取指令的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CS为代码段寄存器</span><br><span class="line">IP为指令指针寄存器【偏移地址的寄存器】</span><br></pre></td></tr></table></figure><p>2.8086PC互作过程的简要描述</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从CS:IP指向内存单元读取指令，读取的指令进入指令缓冲区；</span><br><span class="line">2.IP=IP+所读取指令的长度，从而指向下一条指令</span><br><span class="line">3.执行指令。转到步骤1</span><br></pre></td></tr></table></figure><p>3.在任何时候，CPU和CS,IP中的内容当作指令的段地址和偏移地址，用它们合成指令的物理地址，到内存中读取指令码，执行</p><p>4.如果说，内存中的一段信息被CPU执行过的话，那么，它所在的内存单元必然是被CS:IP指向过</p><h3 id="2-11修改CS-IP的指令"><a href="#2-11修改CS-IP的指令" class="headerlink" title="2.11修改CS,IP的指令"></a>2.11修改CS,IP的指令</h3><p>1.在CPU中，程序员能够用指令读写的部件只有寄存器，程序员可以通过改变寄存器中的内容实现对CPU的控制</p><p>2.CPU从何处执行指令是由CS,IP中的内容决定的，程序员可以通过改变CS,IP中的内容来控制CPU执行目标指令</p><p>3.同时修改CS.IP的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jmp 段地址:偏移地址</span><br><span class="line">jmp 2AE3:3   --&gt; 3AE33</span><br><span class="line">jmp 3:OB16   --&gt; 0003</span><br><span class="line">功能：用指令中给出的地段修改CS,偏移地址修改IP</span><br></pre></td></tr></table></figure><p>4.只修改IP</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jim 某一个合法寄存器完成：</span><br><span class="line">jmp ax 指令执行前：ax=1000H CS=2000H,IP=0003H</span><br><span class="line"> 后：ax=1000H CS=2000H,IP=1000H</span><br><span class="line">这个就是类似于：mov IP,ax</span><br></pre></td></tr></table></figure><h3 id="2-12代码段"><a href="#2-12代码段" class="headerlink" title="2.12代码段"></a>2.12代码段</h3><p>1.对于8086PC机，在编程的时候，可以根据需要，将一组内存单元定义为一个段</p><p>2.可以将长度为N(N&lt;=64KB)的一组代码，存在一组地址连续，起始地址为16的倍数的内存单元中，这段内存是用来存放代码的，从而定义了一个代码段</p><p>3.如何使得代码段中的指令被执行呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用CS:IP指过去</span><br></pre></td></tr></table></figure><p>4.将一段内存当作代码段，仅仅是我们在编程时的一种安排，CPU并不会由于这种安排，就自动的将我们定义的代码段中的指令当作指令来执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CPU只认被CS:IP指向的内存单元中的内容为指令</span><br><span class="line">如果是其他的来指向就可能是数据</span><br></pre></td></tr></table></figure><p>5.所以要将CS:IP指向对应的地址</p><h3 id="2-9-2-12节的小结"><a href="#2-9-2-12节的小结" class="headerlink" title="2.9~2.12节的小结"></a>2.9~2.12节的小结</h3><p>1.段地址在8086CPU的寄存器中存放。当8086CPU要访问内存的时候，由段寄存器提供内存单元的段地址。8086CPU有4个段寄存器，其中CS用来存放指令的段地址</p><p>2.CS存放指令的段地址，IP存放指令的偏移地址。</p><p>3.8086机中，任意时刻，CPU将CS:IP指向的内容当作指令执行</p><p>4.8086CPU的互作过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.从CS:IP指向内存单元读取指令，读取的指令进入缓冲区</span><br><span class="line">2.IP指向下一条指令；</span><br><span class="line">3.执行指令（转到步骤1）</span><br></pre></td></tr></table></figure><p>5.8086CPU提供转移指令修改CS,IP的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp</span><br></pre></td></tr></table></figure><h2 id="实验【完成就结束第二章】"><a href="#实验【完成就结束第二章】" class="headerlink" title="实验【完成就结束第二章】"></a>实验【完成就结束第二章】</h2><p>1.查看CPU和内存，用机器指令和汇编指令编程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用到DEBUG</span><br><span class="line">cmd--&gt;输入debug</span><br></pre></td></tr></table></figure><p>什么是debug？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Debug是DOS，Windows都提供的实模式（8086方式）程序的调试工具，使用它可以查看CPU各种寄存器中的内容，内存的情况和在机器码级跟踪程序的运行</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">指令：</span><br><span class="line">-r查看，改变CPU寄存器的内容</span><br><span class="line">-d查看内容中的内容</span><br><span class="line">-e改写内存中的内容</span><br><span class="line">-u将内存中的机器指令翻译成汇编指令</span><br><span class="line">-t命令执行一条机器指令</span><br><span class="line">-a以汇编指令的格式在内容中写入一条机器指令</span><br></pre></td></tr></table></figure><p>这里还是去看视频吧P12</p>]]></content>
      
      
      <categories>
          
          <category> 8086汇编 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>张明宇的博客计划</title>
      <link href="/2023/04/30/%E8%AE%A1%E5%88%92/"/>
      <url>/2023/04/30/%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p><strong>为了监督我的学习和记录我的成长，我的博客计划是：</strong></p><p>一周一小更，一个月一大更。每周天晚上写一写最近的学习情况和内容【可以是几个字也能是几百字】。每一个月写一个收获到的知识内容，或者这一个月所得到的东西。</p><ul><li><p>会开放一个计划想法区：把突发奇想的东西都放上去。</p></li><li><p>会开放一个娱乐区：用来记录我学后的放松娱乐。</p></li><li><p>会开放一个日常笔记区：把写的笔记都上传到一个地方，并且把不同的笔记内容进行分类。【该功能还在探索】【因为是刚刚开始学，所以很多笔记可能有不当之处】</p></li><li><p>会开放一个汽车展览区：帅气的汽车都放上去。</p></li><li><p>会开放一个剪辑区：把酷酷的视频和美美的视频放上去。</p></li><li><p>由于我对渗透测试和二进制安全都蛮有兴趣的，加上我还年轻【才大一，刚刚接触这个网络】所以我可能两个方向都会学一学，在未来的日子里定下专攻的方向。</p></li><li><p>因为是才刚刚搭建起来的博客，很多地方都不很懂，并且有很多的东西都还未能开放【还不太会】。所以请大家多给建议，谢谢。</p></li></ul><p><strong>以前浪费的时间太多，希望我能在搭建该博客后能自觉，自立的进行学习。</strong></p><ul><li>只要即可起步，永远都不会嫌迟。</li><li>细节决定成败，习惯成就未来。</li></ul><p><strong>来自皮皮虾的正能量</strong>【简单的记录一下神评，下次我也能神评啦~】</p><ul><li>聪明是一种天赋，而善良是一种选择。</li><li>保持求同存异，不要带有知识上的优越感。</li><li>你在背后议论我，说明我走在你前面。</li></ul><p>注：现在的背景图不符合我的审美，我后面会把我的“海贼王”放上去。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
